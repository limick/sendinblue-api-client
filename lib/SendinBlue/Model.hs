{-
   SendinBlue API

   SendinBlue provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/sendinblue  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  | 

   OpenAPI spec version: 2.0
   SendinBlue API API version: 3.0.0
   Contact: contact@sendinblue.com
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : SendinBlue.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module SendinBlue.Model where

import SendinBlue.Core
import SendinBlue.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AttributeCategory
newtype AttributeCategory = AttributeCategory { unAttributeCategory :: E'AttributeCategory } deriving (P.Eq, P.Show)

-- ** AttributeCategory2
newtype AttributeCategory2 = AttributeCategory2 { unAttributeCategory2 :: E'Category } deriving (P.Eq, P.Show)

-- ** AttributeName
newtype AttributeName = AttributeName { unAttributeName :: Text } deriving (P.Eq, P.Show)

-- ** CampaignId
newtype CampaignId = CampaignId { unCampaignId :: Integer } deriving (P.Eq, P.Show)

-- ** ChildAuthKey
newtype ChildAuthKey = ChildAuthKey { unChildAuthKey :: Text } deriving (P.Eq, P.Show)

-- ** Days
newtype Days = Days { unDays :: Int } deriving (P.Eq, P.Show)

-- ** Domain
newtype Domain = Domain { unDomain :: Text } deriving (P.Eq, P.Show)

-- ** DomainName
newtype DomainName = DomainName { unDomainName :: Text } deriving (P.Eq, P.Show)

-- ** Email
newtype Email = Email { unEmail :: Text } deriving (P.Eq, P.Show)

-- ** EndDate
newtype EndDate = EndDate { unEndDate :: DateTime } deriving (P.Eq, P.Show)

-- ** EndDateDate
newtype EndDateDate = EndDateDate { unEndDateDate :: Date } deriving (P.Eq, P.Show)

-- ** EndDateText
newtype EndDateText = EndDateText { unEndDateText :: Text } deriving (P.Eq, P.Show)

-- ** Event
newtype Event = Event { unEvent :: E'Event } deriving (P.Eq, P.Show)

-- ** Event2
newtype Event2 = Event2 { unEvent2 :: E'Event2 } deriving (P.Eq, P.Show)

-- ** FolderId
newtype FolderId = FolderId { unFolderId :: Integer } deriving (P.Eq, P.Show)

-- ** Ip
newtype Ip = Ip { unIp :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Integer } deriving (P.Eq, P.Show)

-- ** ListId
newtype ListId = ListId { unListId :: Integer } deriving (P.Eq, P.Show)

-- ** MessageId
newtype MessageId = MessageId { unMessageId :: Text } deriving (P.Eq, P.Show)

-- ** ModifiedSince
newtype ModifiedSince = ModifiedSince { unModifiedSince :: DateTime } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Integer } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: E'Type } deriving (P.Eq, P.Show)

-- ** ParamType2
newtype ParamType2 = ParamType2 { unParamType2 :: E'Type7 } deriving (P.Eq, P.Show)

-- ** PhoneNumber
newtype PhoneNumber = PhoneNumber { unPhoneNumber :: Text } deriving (P.Eq, P.Show)

-- ** ProcessId
newtype ProcessId = ProcessId { unProcessId :: Integer } deriving (P.Eq, P.Show)

-- ** SenderId
newtype SenderId = SenderId { unSenderId :: Integer } deriving (P.Eq, P.Show)

-- ** Senders
newtype Senders = Senders { unSenders :: [Text] } deriving (P.Eq, P.Show)

-- ** StartDate
newtype StartDate = StartDate { unStartDate :: DateTime } deriving (P.Eq, P.Show)

-- ** StartDateText
newtype StartDateText = StartDateText { unStartDateText :: Text } deriving (P.Eq, P.Show)

-- ** Status
newtype Status = Status { unStatus :: E'Status5 } deriving (P.Eq, P.Show)

-- ** Tag
newtype Tag = Tag { unTag :: Text } deriving (P.Eq, P.Show)

-- ** Tags
newtype Tags = Tags { unTags :: Text } deriving (P.Eq, P.Show)

-- ** TemplateId
newtype TemplateId = TemplateId { unTemplateId :: Integer } deriving (P.Eq, P.Show)

-- ** TemplateStatus
newtype TemplateStatus = TemplateStatus { unTemplateStatus :: Bool } deriving (P.Eq, P.Show)

-- ** Uuid
newtype Uuid = Uuid { unUuid :: Text } deriving (P.Eq, P.Show)

-- ** WebhookId
newtype WebhookId = WebhookId { unWebhookId :: Integer } deriving (P.Eq, P.Show)

-- * Models


-- ** AddChildDomain
-- | AddChildDomain
data AddChildDomain = AddChildDomain
  { addChildDomainDomain :: !(Maybe Text) -- ^ "domain" - Sender domain to add for a specific child account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddChildDomain
instance A.FromJSON AddChildDomain where
  parseJSON = A.withObject "AddChildDomain" $ \o ->
    AddChildDomain
      <$> (o .:? "domain")

-- | ToJSON AddChildDomain
instance A.ToJSON AddChildDomain where
  toJSON AddChildDomain {..} =
   _omitNulls
      [ "domain" .= addChildDomainDomain
      ]


-- | Construct a value of type 'AddChildDomain' (by applying it's required fields, if any)
mkAddChildDomain
  :: AddChildDomain
mkAddChildDomain =
  AddChildDomain
  { addChildDomainDomain = Nothing
  }

-- ** AddContactToList
-- | AddContactToList
data AddContactToList = AddContactToList
  { addContactToListEmails :: !(Maybe [Text]) -- ^ "emails" - Emails to add to a list
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddContactToList
instance A.FromJSON AddContactToList where
  parseJSON = A.withObject "AddContactToList" $ \o ->
    AddContactToList
      <$> (o .:? "emails")

-- | ToJSON AddContactToList
instance A.ToJSON AddContactToList where
  toJSON AddContactToList {..} =
   _omitNulls
      [ "emails" .= addContactToListEmails
      ]


-- | Construct a value of type 'AddContactToList' (by applying it's required fields, if any)
mkAddContactToList
  :: AddContactToList
mkAddContactToList =
  AddContactToList
  { addContactToListEmails = Nothing
  }

-- ** AddCredits
-- | AddCredits
data AddCredits = AddCredits
  { addCreditsSms :: !(Maybe Integer) -- ^ "sms" - Required if email credits are empty. SMS credits to be added to the child account
  , addCreditsEmail :: !(Maybe Integer) -- ^ "email" - Required if sms credits are empty. Email credits to be added to the child account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddCredits
instance A.FromJSON AddCredits where
  parseJSON = A.withObject "AddCredits" $ \o ->
    AddCredits
      <$> (o .:? "sms")
      <*> (o .:? "email")

-- | ToJSON AddCredits
instance A.ToJSON AddCredits where
  toJSON AddCredits {..} =
   _omitNulls
      [ "sms" .= addCreditsSms
      , "email" .= addCreditsEmail
      ]


-- | Construct a value of type 'AddCredits' (by applying it's required fields, if any)
mkAddCredits
  :: AddCredits
mkAddCredits =
  AddCredits
  { addCreditsSms = Nothing
  , addCreditsEmail = Nothing
  }

-- ** CreateAttribute
-- | CreateAttribute
data CreateAttribute = CreateAttribute
  { createAttributeValue :: !(Maybe Text) -- ^ "value" - Value of the attribute. Use only if the attribute&#39;s category is &#39;calculated&#39; or &#39;global&#39;
  , createAttributeEnumeration :: !(Maybe [CreateAttributeEnumeration]) -- ^ "enumeration" - List of values and labels that the attribute can take. Use only if the attribute&#39;s category is \&quot;category\&quot;. For example, [{&#39;value&#39;:1, &#39;label&#39;:&#39;male&#39;}, {&#39;value&#39;:2, &#39;label&#39;:&#39;female&#39;}]
  , createAttributeType :: !(Maybe E'Type4) -- ^ "type" - Type of the attribute. Use only if the attribute&#39;s category is &#39;normal&#39;, &#39;category&#39; or &#39;transactional&#39; ( type &#39;boolean&#39; is only available if the category is &#39;normal&#39; attribute, type &#39;id&#39; is only available if the category is &#39;transactional&#39; attribute &amp; type &#39;category&#39; is only available if the category is &#39;category&#39; attribute )
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateAttribute
instance A.FromJSON CreateAttribute where
  parseJSON = A.withObject "CreateAttribute" $ \o ->
    CreateAttribute
      <$> (o .:? "value")
      <*> (o .:? "enumeration")
      <*> (o .:? "type")

-- | ToJSON CreateAttribute
instance A.ToJSON CreateAttribute where
  toJSON CreateAttribute {..} =
   _omitNulls
      [ "value" .= createAttributeValue
      , "enumeration" .= createAttributeEnumeration
      , "type" .= createAttributeType
      ]


-- | Construct a value of type 'CreateAttribute' (by applying it's required fields, if any)
mkCreateAttribute
  :: CreateAttribute
mkCreateAttribute =
  CreateAttribute
  { createAttributeValue = Nothing
  , createAttributeEnumeration = Nothing
  , createAttributeType = Nothing
  }

-- ** CreateAttributeEnumeration
-- | CreateAttributeEnumeration
data CreateAttributeEnumeration = CreateAttributeEnumeration
  { createAttributeEnumerationValue :: !(Int) -- ^ /Required/ "value" - Id of the value
  , createAttributeEnumerationLabel :: !(Text) -- ^ /Required/ "label" - Label of the value
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateAttributeEnumeration
instance A.FromJSON CreateAttributeEnumeration where
  parseJSON = A.withObject "CreateAttributeEnumeration" $ \o ->
    CreateAttributeEnumeration
      <$> (o .:  "value")
      <*> (o .:  "label")

-- | ToJSON CreateAttributeEnumeration
instance A.ToJSON CreateAttributeEnumeration where
  toJSON CreateAttributeEnumeration {..} =
   _omitNulls
      [ "value" .= createAttributeEnumerationValue
      , "label" .= createAttributeEnumerationLabel
      ]


-- | Construct a value of type 'CreateAttributeEnumeration' (by applying it's required fields, if any)
mkCreateAttributeEnumeration
  :: Int -- ^ 'createAttributeEnumerationValue': Id of the value
  -> Text -- ^ 'createAttributeEnumerationLabel': Label of the value
  -> CreateAttributeEnumeration
mkCreateAttributeEnumeration createAttributeEnumerationValue createAttributeEnumerationLabel =
  CreateAttributeEnumeration
  { createAttributeEnumerationValue
  , createAttributeEnumerationLabel
  }

-- ** CreateChild
-- | CreateChild
data CreateChild = CreateChild
  { createChildEmail :: !(Text) -- ^ /Required/ "email" - Email address to create the child account
  , createChildFirstName :: !(Text) -- ^ /Required/ "firstName" - First name to use to create the child account
  , createChildLastName :: !(Text) -- ^ /Required/ "lastName" - Last name to use to create the child account
  , createChildCompanyName :: !(Text) -- ^ /Required/ "companyName" - Company name to use to create the child account
  , createChildPassword :: !(Text) -- ^ /Required/ "password" - Password for the child account to login
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChild
instance A.FromJSON CreateChild where
  parseJSON = A.withObject "CreateChild" $ \o ->
    CreateChild
      <$> (o .:  "email")
      <*> (o .:  "firstName")
      <*> (o .:  "lastName")
      <*> (o .:  "companyName")
      <*> (o .:  "password")

-- | ToJSON CreateChild
instance A.ToJSON CreateChild where
  toJSON CreateChild {..} =
   _omitNulls
      [ "email" .= createChildEmail
      , "firstName" .= createChildFirstName
      , "lastName" .= createChildLastName
      , "companyName" .= createChildCompanyName
      , "password" .= createChildPassword
      ]


-- | Construct a value of type 'CreateChild' (by applying it's required fields, if any)
mkCreateChild
  :: Text -- ^ 'createChildEmail': Email address to create the child account
  -> Text -- ^ 'createChildFirstName': First name to use to create the child account
  -> Text -- ^ 'createChildLastName': Last name to use to create the child account
  -> Text -- ^ 'createChildCompanyName': Company name to use to create the child account
  -> Text -- ^ 'createChildPassword': Password for the child account to login
  -> CreateChild
mkCreateChild createChildEmail createChildFirstName createChildLastName createChildCompanyName createChildPassword =
  CreateChild
  { createChildEmail
  , createChildFirstName
  , createChildLastName
  , createChildCompanyName
  , createChildPassword
  }

-- ** CreateContact
-- | CreateContact
data CreateContact = CreateContact
  { createContactEmail :: !(Maybe Text) -- ^ "email" - Email address of the user. Mandatory if \&quot;sms\&quot; field is not passed in \&quot;attributes\&quot; parameter&#39;
  , createContactAttributes :: !(Maybe A.Value) -- ^ "attributes" - Pass the set of attributes and their values. These attributes must be present in your SendinBlue account. For eg. {&#39;FNAME&#39;:&#39;Elly&#39;, &#39;LNAME&#39;:&#39;Roger&#39;}
  , createContactEmailBlacklisted :: !(Maybe Bool) -- ^ "emailBlacklisted" - Set this field to blacklist the contact for emails (emailBlacklisted &#x3D; true)
  , createContactSmsBlacklisted :: !(Maybe Bool) -- ^ "smsBlacklisted" - Set this field to blacklist the contact for SMS (smsBlacklisted &#x3D; true)
  , createContactListIds :: !(Maybe [Integer]) -- ^ "listIds" - Ids of the lists to add the contact to
  , createContactUpdateEnabled :: !(Maybe Bool) -- ^ "updateEnabled" - Facilitate to update the existing contact in the same request (updateEnabled &#x3D; true)
  , createContactSmtpBlacklistSender :: !(Maybe [Text]) -- ^ "smtpBlacklistSender" - transactional email forbidden sender for contact. Use only for email Contact ( only available if updateEnabled &#x3D; true )
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateContact
instance A.FromJSON CreateContact where
  parseJSON = A.withObject "CreateContact" $ \o ->
    CreateContact
      <$> (o .:? "email")
      <*> (o .:? "attributes")
      <*> (o .:? "emailBlacklisted")
      <*> (o .:? "smsBlacklisted")
      <*> (o .:? "listIds")
      <*> (o .:? "updateEnabled")
      <*> (o .:? "smtpBlacklistSender")

-- | ToJSON CreateContact
instance A.ToJSON CreateContact where
  toJSON CreateContact {..} =
   _omitNulls
      [ "email" .= createContactEmail
      , "attributes" .= createContactAttributes
      , "emailBlacklisted" .= createContactEmailBlacklisted
      , "smsBlacklisted" .= createContactSmsBlacklisted
      , "listIds" .= createContactListIds
      , "updateEnabled" .= createContactUpdateEnabled
      , "smtpBlacklistSender" .= createContactSmtpBlacklistSender
      ]


-- | Construct a value of type 'CreateContact' (by applying it's required fields, if any)
mkCreateContact
  :: CreateContact
mkCreateContact =
  CreateContact
  { createContactEmail = Nothing
  , createContactAttributes = Nothing
  , createContactEmailBlacklisted = Nothing
  , createContactSmsBlacklisted = Nothing
  , createContactListIds = Nothing
  , createContactUpdateEnabled = Nothing
  , createContactSmtpBlacklistSender = Nothing
  }

-- ** CreateEmailCampaign
-- | CreateEmailCampaign
data CreateEmailCampaign = CreateEmailCampaign
  { createEmailCampaignTag :: !(Maybe Text) -- ^ "tag" - Tag of the campaign
  , createEmailCampaignSender :: !(CreateEmailCampaignSender) -- ^ /Required/ "sender"
  , createEmailCampaignName :: !(Text) -- ^ /Required/ "name" - Name of the campaign
  , createEmailCampaignHtmlContent :: !(Maybe Text) -- ^ "htmlContent" - Mandatory if htmlUrl and templateId are empty. Body of the message (HTML)
  , createEmailCampaignHtmlUrl :: !(Maybe Text) -- ^ "htmlUrl" - Mandatory if htmlContent and templateId are empty. Url to the message (HTML)
  , createEmailCampaignTemplateId :: !(Maybe Integer) -- ^ "templateId" - Mandatory if htmlContent and htmlUrl are empty. Id of the transactional email template with status &#39;active&#39;. Used to copy only its content fetched from htmlContent/htmlUrl to an email campaign for RSS feature.
  , createEmailCampaignScheduledAt :: !(Maybe DateTime) -- ^ "scheduledAt" - Sending UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result. If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part).
  , createEmailCampaignSubject :: !(Maybe Text) -- ^ "subject" - Subject of the campaign. Mandatory if abTesting is false. Ignored if abTesting is true.
  , createEmailCampaignReplyTo :: !(Maybe Text) -- ^ "replyTo" - Email on which the campaign recipients will be able to reply to
  , createEmailCampaignToField :: !(Maybe Text) -- ^ "toField" - To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter &#39;params&#39; used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
  , createEmailCampaignRecipients :: !(Maybe CreateEmailCampaignRecipients) -- ^ "recipients"
  , createEmailCampaignAttachmentUrl :: !(Maybe Text) -- ^ "attachmentUrl" - Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
  , createEmailCampaignInlineImageActivation :: !(Maybe Bool) -- ^ "inlineImageActivation" - Use true to embedded the images in your email. Final size of the email should be less than 4MB. Campaigns with embedded images can not be sent to more than 5000 contacts
  , createEmailCampaignMirrorActive :: !(Maybe Bool) -- ^ "mirrorActive" - Use true to enable the mirror link
  , createEmailCampaignFooter :: !(Maybe Text) -- ^ "footer" - Footer of the email campaign
  , createEmailCampaignHeader :: !(Maybe Text) -- ^ "header" - Header of the email campaign
  , createEmailCampaignUtmCampaign :: !(Maybe Text) -- ^ "utmCampaign" - Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed
  , createEmailCampaignParams :: !(Maybe A.Value) -- ^ "params" - Pass the set of attributes to customize the type classic campaign. For example, {&#39;FNAME&#39;:&#39;Joe&#39;, &#39;LNAME&#39;:&#39;Doe&#39;}. Only available if &#39;type&#39; is &#39;classic&#39;. It&#39;s considered only if campaign is in New Template Language format. The New Template Language is dependent on the values of &#39;subject&#39;, &#39;htmlContent/htmlUrl&#39;, &#39;sender.name&#39; &amp; &#39;toField&#39;
  , createEmailCampaignSendAtBestTime :: !(Maybe Bool) -- ^ "sendAtBestTime" - Set this to true if you want to send your campaign at best time.
  , createEmailCampaignAbTesting :: !(Maybe Bool) -- ^ "abTesting" - Status of A/B Test. abTesting &#x3D; false means it is disabled, &amp; abTesting &#x3D; true means it is enabled. &#39;subjectA&#39;, &#39;subjectB&#39;, &#39;splitRule&#39;, &#39;winnerCriteria&#39; &amp; &#39;winnerDelay&#39; will be considered when abTesting is set to true. &#39;subjectA&#39; &amp; &#39;subjectB&#39; are mandatory together &amp; &#39;subject&#39; if passed is ignored. Can be set to true only if &#39;sendAtBestTime&#39; is &#39;false&#39;. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B
  , createEmailCampaignSubjectA :: !(Maybe Text) -- ^ "subjectA" - Subject A of the campaign. Mandatory if abTesting &#x3D; true. subjectA &amp; subjectB should have unique value
  , createEmailCampaignSubjectB :: !(Maybe Text) -- ^ "subjectB" - Subject B of the campaign. Mandatory if abTesting &#x3D; true. subjectA &amp; subjectB should have unique value
  , createEmailCampaignSplitRule :: !(Maybe Integer) -- ^ "splitRule" - Add the size of your test groups. Mandatory if abTesting &#x3D; true &amp; &#39;recipients&#39; is passed. We&#39;ll send version A and B to a random sample of recipients, and then the winning version to everyone else
  , createEmailCampaignWinnerCriteria :: !(Maybe E'WinnerCriteria) -- ^ "winnerCriteria" - Choose the metrics that will determinate the winning version. Mandatory if &#39;splitRule&#39; &gt;&#x3D; 1 and &lt; 50. If splitRule &#x3D; 50, &#39;winnerCriteria&#39; is ignored if passed
  , createEmailCampaignWinnerDelay :: !(Maybe Integer) -- ^ "winnerDelay" - Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 &#x3D; 168 hours. The winning version will be sent at the end of the test. Mandatory if &#39;splitRule&#39; &gt;&#x3D; 1 and &lt; 50. If splitRule &#x3D; 50, &#39;winnerDelay&#39; is ignored if passed
  , createEmailCampaignIpWarmupEnable :: !(Maybe Bool) -- ^ "ipWarmupEnable" - Available for dedicated ip clients. Set this to true if you wish to warm up your ip.
  , createEmailCampaignInitialQuota :: !(Maybe Integer) -- ^ "initialQuota" - Mandatory if ipWarmupEnable is set to true. Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.
  , createEmailCampaignIncreaseRate :: !(Maybe Integer) -- ^ "increaseRate" - Mandatory if ipWarmupEnable is set to true. Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmailCampaign
instance A.FromJSON CreateEmailCampaign where
  parseJSON = A.withObject "CreateEmailCampaign" $ \o ->
    CreateEmailCampaign
      <$> (o .:? "tag")
      <*> (o .:  "sender")
      <*> (o .:  "name")
      <*> (o .:? "htmlContent")
      <*> (o .:? "htmlUrl")
      <*> (o .:? "templateId")
      <*> (o .:? "scheduledAt")
      <*> (o .:? "subject")
      <*> (o .:? "replyTo")
      <*> (o .:? "toField")
      <*> (o .:? "recipients")
      <*> (o .:? "attachmentUrl")
      <*> (o .:? "inlineImageActivation")
      <*> (o .:? "mirrorActive")
      <*> (o .:? "footer")
      <*> (o .:? "header")
      <*> (o .:? "utmCampaign")
      <*> (o .:? "params")
      <*> (o .:? "sendAtBestTime")
      <*> (o .:? "abTesting")
      <*> (o .:? "subjectA")
      <*> (o .:? "subjectB")
      <*> (o .:? "splitRule")
      <*> (o .:? "winnerCriteria")
      <*> (o .:? "winnerDelay")
      <*> (o .:? "ipWarmupEnable")
      <*> (o .:? "initialQuota")
      <*> (o .:? "increaseRate")

-- | ToJSON CreateEmailCampaign
instance A.ToJSON CreateEmailCampaign where
  toJSON CreateEmailCampaign {..} =
   _omitNulls
      [ "tag" .= createEmailCampaignTag
      , "sender" .= createEmailCampaignSender
      , "name" .= createEmailCampaignName
      , "htmlContent" .= createEmailCampaignHtmlContent
      , "htmlUrl" .= createEmailCampaignHtmlUrl
      , "templateId" .= createEmailCampaignTemplateId
      , "scheduledAt" .= createEmailCampaignScheduledAt
      , "subject" .= createEmailCampaignSubject
      , "replyTo" .= createEmailCampaignReplyTo
      , "toField" .= createEmailCampaignToField
      , "recipients" .= createEmailCampaignRecipients
      , "attachmentUrl" .= createEmailCampaignAttachmentUrl
      , "inlineImageActivation" .= createEmailCampaignInlineImageActivation
      , "mirrorActive" .= createEmailCampaignMirrorActive
      , "footer" .= createEmailCampaignFooter
      , "header" .= createEmailCampaignHeader
      , "utmCampaign" .= createEmailCampaignUtmCampaign
      , "params" .= createEmailCampaignParams
      , "sendAtBestTime" .= createEmailCampaignSendAtBestTime
      , "abTesting" .= createEmailCampaignAbTesting
      , "subjectA" .= createEmailCampaignSubjectA
      , "subjectB" .= createEmailCampaignSubjectB
      , "splitRule" .= createEmailCampaignSplitRule
      , "winnerCriteria" .= createEmailCampaignWinnerCriteria
      , "winnerDelay" .= createEmailCampaignWinnerDelay
      , "ipWarmupEnable" .= createEmailCampaignIpWarmupEnable
      , "initialQuota" .= createEmailCampaignInitialQuota
      , "increaseRate" .= createEmailCampaignIncreaseRate
      ]


-- | Construct a value of type 'CreateEmailCampaign' (by applying it's required fields, if any)
mkCreateEmailCampaign
  :: CreateEmailCampaignSender -- ^ 'createEmailCampaignSender' 
  -> Text -- ^ 'createEmailCampaignName': Name of the campaign
  -> CreateEmailCampaign
mkCreateEmailCampaign createEmailCampaignSender createEmailCampaignName =
  CreateEmailCampaign
  { createEmailCampaignTag = Nothing
  , createEmailCampaignSender
  , createEmailCampaignName
  , createEmailCampaignHtmlContent = Nothing
  , createEmailCampaignHtmlUrl = Nothing
  , createEmailCampaignTemplateId = Nothing
  , createEmailCampaignScheduledAt = Nothing
  , createEmailCampaignSubject = Nothing
  , createEmailCampaignReplyTo = Nothing
  , createEmailCampaignToField = Nothing
  , createEmailCampaignRecipients = Nothing
  , createEmailCampaignAttachmentUrl = Nothing
  , createEmailCampaignInlineImageActivation = Nothing
  , createEmailCampaignMirrorActive = Nothing
  , createEmailCampaignFooter = Nothing
  , createEmailCampaignHeader = Nothing
  , createEmailCampaignUtmCampaign = Nothing
  , createEmailCampaignParams = Nothing
  , createEmailCampaignSendAtBestTime = Nothing
  , createEmailCampaignAbTesting = Nothing
  , createEmailCampaignSubjectA = Nothing
  , createEmailCampaignSubjectB = Nothing
  , createEmailCampaignSplitRule = Nothing
  , createEmailCampaignWinnerCriteria = Nothing
  , createEmailCampaignWinnerDelay = Nothing
  , createEmailCampaignIpWarmupEnable = Nothing
  , createEmailCampaignInitialQuota = Nothing
  , createEmailCampaignIncreaseRate = Nothing
  }

-- ** CreateEmailCampaignRecipients
-- | CreateEmailCampaignRecipients
-- List ids to include/exclude from campaign
data CreateEmailCampaignRecipients = CreateEmailCampaignRecipients
  { createEmailCampaignRecipientsExclusionListIds :: !(Maybe [Integer]) -- ^ "exclusionListIds" - List ids to exclude from the campaign
  , createEmailCampaignRecipientsListIds :: !(Maybe [Integer]) -- ^ "listIds" - Mandatory if scheduledAt is not empty. List Ids to send the campaign to
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmailCampaignRecipients
instance A.FromJSON CreateEmailCampaignRecipients where
  parseJSON = A.withObject "CreateEmailCampaignRecipients" $ \o ->
    CreateEmailCampaignRecipients
      <$> (o .:? "exclusionListIds")
      <*> (o .:? "listIds")

-- | ToJSON CreateEmailCampaignRecipients
instance A.ToJSON CreateEmailCampaignRecipients where
  toJSON CreateEmailCampaignRecipients {..} =
   _omitNulls
      [ "exclusionListIds" .= createEmailCampaignRecipientsExclusionListIds
      , "listIds" .= createEmailCampaignRecipientsListIds
      ]


-- | Construct a value of type 'CreateEmailCampaignRecipients' (by applying it's required fields, if any)
mkCreateEmailCampaignRecipients
  :: CreateEmailCampaignRecipients
mkCreateEmailCampaignRecipients =
  CreateEmailCampaignRecipients
  { createEmailCampaignRecipientsExclusionListIds = Nothing
  , createEmailCampaignRecipientsListIds = Nothing
  }

-- ** CreateEmailCampaignSender
-- | CreateEmailCampaignSender
-- Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
data CreateEmailCampaignSender = CreateEmailCampaignSender
  { createEmailCampaignSenderName :: !(Maybe Text) -- ^ "name" - Sender Name
  , createEmailCampaignSenderEmail :: !(Maybe Text) -- ^ "email" - Sender email
  , createEmailCampaignSenderId :: !(Maybe Integer) -- ^ "id" - Select the sender for the campaign on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmailCampaignSender
instance A.FromJSON CreateEmailCampaignSender where
  parseJSON = A.withObject "CreateEmailCampaignSender" $ \o ->
    CreateEmailCampaignSender
      <$> (o .:? "name")
      <*> (o .:? "email")
      <*> (o .:? "id")

-- | ToJSON CreateEmailCampaignSender
instance A.ToJSON CreateEmailCampaignSender where
  toJSON CreateEmailCampaignSender {..} =
   _omitNulls
      [ "name" .= createEmailCampaignSenderName
      , "email" .= createEmailCampaignSenderEmail
      , "id" .= createEmailCampaignSenderId
      ]


-- | Construct a value of type 'CreateEmailCampaignSender' (by applying it's required fields, if any)
mkCreateEmailCampaignSender
  :: CreateEmailCampaignSender
mkCreateEmailCampaignSender =
  CreateEmailCampaignSender
  { createEmailCampaignSenderName = Nothing
  , createEmailCampaignSenderEmail = Nothing
  , createEmailCampaignSenderId = Nothing
  }

-- ** CreateList
-- | CreateList
data CreateList = CreateList
  { createListName :: !(Text) -- ^ /Required/ "name" - Name of the list
  , createListFolderId :: !(Integer) -- ^ /Required/ "folderId" - Id of the parent folder in which this list is to be created
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateList
instance A.FromJSON CreateList where
  parseJSON = A.withObject "CreateList" $ \o ->
    CreateList
      <$> (o .:  "name")
      <*> (o .:  "folderId")

-- | ToJSON CreateList
instance A.ToJSON CreateList where
  toJSON CreateList {..} =
   _omitNulls
      [ "name" .= createListName
      , "folderId" .= createListFolderId
      ]


-- | Construct a value of type 'CreateList' (by applying it's required fields, if any)
mkCreateList
  :: Text -- ^ 'createListName': Name of the list
  -> Integer -- ^ 'createListFolderId': Id of the parent folder in which this list is to be created
  -> CreateList
mkCreateList createListName createListFolderId =
  CreateList
  { createListName
  , createListFolderId
  }

-- ** CreateModel
-- | CreateModel
data CreateModel = CreateModel
  { createModelId :: !(Integer) -- ^ /Required/ "id" - ID of the object created
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModel
instance A.FromJSON CreateModel where
  parseJSON = A.withObject "CreateModel" $ \o ->
    CreateModel
      <$> (o .:  "id")

-- | ToJSON CreateModel
instance A.ToJSON CreateModel where
  toJSON CreateModel {..} =
   _omitNulls
      [ "id" .= createModelId
      ]


-- | Construct a value of type 'CreateModel' (by applying it's required fields, if any)
mkCreateModel
  :: Integer -- ^ 'createModelId': ID of the object created
  -> CreateModel
mkCreateModel createModelId =
  CreateModel
  { createModelId
  }

-- ** CreateReseller
-- | CreateReseller
data CreateReseller = CreateReseller
  { createResellerAuthKey :: !(Text) -- ^ /Required/ "authKey" - AuthKey of Reseller child created
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateReseller
instance A.FromJSON CreateReseller where
  parseJSON = A.withObject "CreateReseller" $ \o ->
    CreateReseller
      <$> (o .:  "authKey")

-- | ToJSON CreateReseller
instance A.ToJSON CreateReseller where
  toJSON CreateReseller {..} =
   _omitNulls
      [ "authKey" .= createResellerAuthKey
      ]


-- | Construct a value of type 'CreateReseller' (by applying it's required fields, if any)
mkCreateReseller
  :: Text -- ^ 'createResellerAuthKey': AuthKey of Reseller child created
  -> CreateReseller
mkCreateReseller createResellerAuthKey =
  CreateReseller
  { createResellerAuthKey
  }

-- ** CreateSender
-- | CreateSender
data CreateSender = CreateSender
  { createSenderName :: !(Text) -- ^ /Required/ "name" - From Name to use for the sender
  , createSenderEmail :: !(Text) -- ^ /Required/ "email" - From Email to use for the sender
  , createSenderIps :: !(Maybe [CreateSenderIps]) -- ^ "ips" - Mandatory in case of dedicated IP, IPs to associate to the sender
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSender
instance A.FromJSON CreateSender where
  parseJSON = A.withObject "CreateSender" $ \o ->
    CreateSender
      <$> (o .:  "name")
      <*> (o .:  "email")
      <*> (o .:? "ips")

-- | ToJSON CreateSender
instance A.ToJSON CreateSender where
  toJSON CreateSender {..} =
   _omitNulls
      [ "name" .= createSenderName
      , "email" .= createSenderEmail
      , "ips" .= createSenderIps
      ]


-- | Construct a value of type 'CreateSender' (by applying it's required fields, if any)
mkCreateSender
  :: Text -- ^ 'createSenderName': From Name to use for the sender
  -> Text -- ^ 'createSenderEmail': From Email to use for the sender
  -> CreateSender
mkCreateSender createSenderName createSenderEmail =
  CreateSender
  { createSenderName
  , createSenderEmail
  , createSenderIps = Nothing
  }

-- ** CreateSenderIps
-- | CreateSenderIps
data CreateSenderIps = CreateSenderIps
  { createSenderIpsIp :: !(Text) -- ^ /Required/ "ip" - Dedicated IP available in your account
  , createSenderIpsDomain :: !(Text) -- ^ /Required/ "domain" - Domain of the IP
  , createSenderIpsWeight :: !(Maybe Integer) -- ^ "weight" - Weight to apply to the IP. Sum of all IP weights must be 100. Should be passed for either ALL or NONE of the IPs. If it&#39;s not passed, the sending will be equally balanced on all IPs.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSenderIps
instance A.FromJSON CreateSenderIps where
  parseJSON = A.withObject "CreateSenderIps" $ \o ->
    CreateSenderIps
      <$> (o .:  "ip")
      <*> (o .:  "domain")
      <*> (o .:? "weight")

-- | ToJSON CreateSenderIps
instance A.ToJSON CreateSenderIps where
  toJSON CreateSenderIps {..} =
   _omitNulls
      [ "ip" .= createSenderIpsIp
      , "domain" .= createSenderIpsDomain
      , "weight" .= createSenderIpsWeight
      ]


-- | Construct a value of type 'CreateSenderIps' (by applying it's required fields, if any)
mkCreateSenderIps
  :: Text -- ^ 'createSenderIpsIp': Dedicated IP available in your account
  -> Text -- ^ 'createSenderIpsDomain': Domain of the IP
  -> CreateSenderIps
mkCreateSenderIps createSenderIpsIp createSenderIpsDomain =
  CreateSenderIps
  { createSenderIpsIp
  , createSenderIpsDomain
  , createSenderIpsWeight = Nothing
  }

-- ** CreateSenderModel
-- | CreateSenderModel
data CreateSenderModel = CreateSenderModel
  { createSenderModelId :: !(Integer) -- ^ /Required/ "id" - ID of the Sender created
  , createSenderModelSpfError :: !(Maybe Bool) -- ^ "spfError" - Status of SPF configuration for the sender (true &#x3D; SPF not well configured, false &#x3D; SPF well configured)
  , createSenderModelDkimError :: !(Maybe Bool) -- ^ "dkimError" - Status of DKIM configuration for the sender (true &#x3D; DKIM not well configured, false &#x3D; DKIM well configured)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSenderModel
instance A.FromJSON CreateSenderModel where
  parseJSON = A.withObject "CreateSenderModel" $ \o ->
    CreateSenderModel
      <$> (o .:  "id")
      <*> (o .:? "spfError")
      <*> (o .:? "dkimError")

-- | ToJSON CreateSenderModel
instance A.ToJSON CreateSenderModel where
  toJSON CreateSenderModel {..} =
   _omitNulls
      [ "id" .= createSenderModelId
      , "spfError" .= createSenderModelSpfError
      , "dkimError" .= createSenderModelDkimError
      ]


-- | Construct a value of type 'CreateSenderModel' (by applying it's required fields, if any)
mkCreateSenderModel
  :: Integer -- ^ 'createSenderModelId': ID of the Sender created
  -> CreateSenderModel
mkCreateSenderModel createSenderModelId =
  CreateSenderModel
  { createSenderModelId
  , createSenderModelSpfError = Nothing
  , createSenderModelDkimError = Nothing
  }

-- ** CreateSmsCampaign
-- | CreateSmsCampaign
data CreateSmsCampaign = CreateSmsCampaign
  { createSmsCampaignName :: !(Text) -- ^ /Required/ "name" - Name of the campaign
  , createSmsCampaignSender :: !(Text) -- ^ /Required/ "sender" - Name of the sender. The number of characters is limited to 11
  , createSmsCampaignContent :: !(Text) -- ^ /Required/ "content" - Content of the message. The maximum characters used per SMS is 160, if used more than that, it will be counted as more than one SMS
  , createSmsCampaignRecipients :: !(Maybe CreateSmsCampaignRecipients) -- ^ "recipients"
  , createSmsCampaignScheduledAt :: !(Maybe DateTime) -- ^ "scheduledAt" - UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSmsCampaign
instance A.FromJSON CreateSmsCampaign where
  parseJSON = A.withObject "CreateSmsCampaign" $ \o ->
    CreateSmsCampaign
      <$> (o .:  "name")
      <*> (o .:  "sender")
      <*> (o .:  "content")
      <*> (o .:? "recipients")
      <*> (o .:? "scheduledAt")

-- | ToJSON CreateSmsCampaign
instance A.ToJSON CreateSmsCampaign where
  toJSON CreateSmsCampaign {..} =
   _omitNulls
      [ "name" .= createSmsCampaignName
      , "sender" .= createSmsCampaignSender
      , "content" .= createSmsCampaignContent
      , "recipients" .= createSmsCampaignRecipients
      , "scheduledAt" .= createSmsCampaignScheduledAt
      ]


-- | Construct a value of type 'CreateSmsCampaign' (by applying it's required fields, if any)
mkCreateSmsCampaign
  :: Text -- ^ 'createSmsCampaignName': Name of the campaign
  -> Text -- ^ 'createSmsCampaignSender': Name of the sender. The number of characters is limited to 11
  -> Text -- ^ 'createSmsCampaignContent': Content of the message. The maximum characters used per SMS is 160, if used more than that, it will be counted as more than one SMS
  -> CreateSmsCampaign
mkCreateSmsCampaign createSmsCampaignName createSmsCampaignSender createSmsCampaignContent =
  CreateSmsCampaign
  { createSmsCampaignName
  , createSmsCampaignSender
  , createSmsCampaignContent
  , createSmsCampaignRecipients = Nothing
  , createSmsCampaignScheduledAt = Nothing
  }

-- ** CreateSmsCampaignRecipients
-- | CreateSmsCampaignRecipients
data CreateSmsCampaignRecipients = CreateSmsCampaignRecipients
  { createSmsCampaignRecipientsListIds :: !([Integer]) -- ^ /Required/ "listIds" - Lists Ids to send the campaign to. REQUIRED if scheduledAt is not empty
  , createSmsCampaignRecipientsExclusionListIds :: !(Maybe [Integer]) -- ^ "exclusionListIds" - List ids which have to be excluded from a campaign
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSmsCampaignRecipients
instance A.FromJSON CreateSmsCampaignRecipients where
  parseJSON = A.withObject "CreateSmsCampaignRecipients" $ \o ->
    CreateSmsCampaignRecipients
      <$> (o .:  "listIds")
      <*> (o .:? "exclusionListIds")

-- | ToJSON CreateSmsCampaignRecipients
instance A.ToJSON CreateSmsCampaignRecipients where
  toJSON CreateSmsCampaignRecipients {..} =
   _omitNulls
      [ "listIds" .= createSmsCampaignRecipientsListIds
      , "exclusionListIds" .= createSmsCampaignRecipientsExclusionListIds
      ]


-- | Construct a value of type 'CreateSmsCampaignRecipients' (by applying it's required fields, if any)
mkCreateSmsCampaignRecipients
  :: [Integer] -- ^ 'createSmsCampaignRecipientsListIds': Lists Ids to send the campaign to. REQUIRED if scheduledAt is not empty
  -> CreateSmsCampaignRecipients
mkCreateSmsCampaignRecipients createSmsCampaignRecipientsListIds =
  CreateSmsCampaignRecipients
  { createSmsCampaignRecipientsListIds
  , createSmsCampaignRecipientsExclusionListIds = Nothing
  }

-- ** CreateSmtpEmail
-- | CreateSmtpEmail
data CreateSmtpEmail = CreateSmtpEmail
  { createSmtpEmailMessageId :: !(Text) -- ^ /Required/ "messageId" - Message ID of the transactional email sent
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSmtpEmail
instance A.FromJSON CreateSmtpEmail where
  parseJSON = A.withObject "CreateSmtpEmail" $ \o ->
    CreateSmtpEmail
      <$> (o .:  "messageId")

-- | ToJSON CreateSmtpEmail
instance A.ToJSON CreateSmtpEmail where
  toJSON CreateSmtpEmail {..} =
   _omitNulls
      [ "messageId" .= createSmtpEmailMessageId
      ]


-- | Construct a value of type 'CreateSmtpEmail' (by applying it's required fields, if any)
mkCreateSmtpEmail
  :: Text -- ^ 'createSmtpEmailMessageId': Message ID of the transactional email sent
  -> CreateSmtpEmail
mkCreateSmtpEmail createSmtpEmailMessageId =
  CreateSmtpEmail
  { createSmtpEmailMessageId
  }

-- ** CreateSmtpTemplate
-- | CreateSmtpTemplate
data CreateSmtpTemplate = CreateSmtpTemplate
  { createSmtpTemplateTag :: !(Maybe Text) -- ^ "tag" - Tag of the template
  , createSmtpTemplateSender :: !(CreateSmtpTemplateSender) -- ^ /Required/ "sender"
  , createSmtpTemplateTemplateName :: !(Text) -- ^ /Required/ "templateName" - Name of the template
  , createSmtpTemplateHtmlContent :: !(Maybe Text) -- ^ "htmlContent" - Body of the message (HTML version). The field must have more than 10 characters. REQUIRED if htmlUrl is empty
  , createSmtpTemplateHtmlUrl :: !(Maybe Text) -- ^ "htmlUrl" - Url which contents the body of the email message. REQUIRED if htmlContent is empty
  , createSmtpTemplateSubject :: !(Text) -- ^ /Required/ "subject" - Subject of the template
  , createSmtpTemplateReplyTo :: !(Maybe Text) -- ^ "replyTo" - Email on which campaign recipients will be able to reply to
  , createSmtpTemplateToField :: !(Maybe Text) -- ^ "toField" - To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter &#39;params&#39; used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
  , createSmtpTemplateAttachmentUrl :: !(Maybe Text) -- ^ "attachmentUrl" - Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
  , createSmtpTemplateIsActive :: !(Maybe Bool) -- ^ "isActive" - Status of template. isActive &#x3D; true means template is active and isActive &#x3D; false means template is inactive
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSmtpTemplate
instance A.FromJSON CreateSmtpTemplate where
  parseJSON = A.withObject "CreateSmtpTemplate" $ \o ->
    CreateSmtpTemplate
      <$> (o .:? "tag")
      <*> (o .:  "sender")
      <*> (o .:  "templateName")
      <*> (o .:? "htmlContent")
      <*> (o .:? "htmlUrl")
      <*> (o .:  "subject")
      <*> (o .:? "replyTo")
      <*> (o .:? "toField")
      <*> (o .:? "attachmentUrl")
      <*> (o .:? "isActive")

-- | ToJSON CreateSmtpTemplate
instance A.ToJSON CreateSmtpTemplate where
  toJSON CreateSmtpTemplate {..} =
   _omitNulls
      [ "tag" .= createSmtpTemplateTag
      , "sender" .= createSmtpTemplateSender
      , "templateName" .= createSmtpTemplateTemplateName
      , "htmlContent" .= createSmtpTemplateHtmlContent
      , "htmlUrl" .= createSmtpTemplateHtmlUrl
      , "subject" .= createSmtpTemplateSubject
      , "replyTo" .= createSmtpTemplateReplyTo
      , "toField" .= createSmtpTemplateToField
      , "attachmentUrl" .= createSmtpTemplateAttachmentUrl
      , "isActive" .= createSmtpTemplateIsActive
      ]


-- | Construct a value of type 'CreateSmtpTemplate' (by applying it's required fields, if any)
mkCreateSmtpTemplate
  :: CreateSmtpTemplateSender -- ^ 'createSmtpTemplateSender' 
  -> Text -- ^ 'createSmtpTemplateTemplateName': Name of the template
  -> Text -- ^ 'createSmtpTemplateSubject': Subject of the template
  -> CreateSmtpTemplate
mkCreateSmtpTemplate createSmtpTemplateSender createSmtpTemplateTemplateName createSmtpTemplateSubject =
  CreateSmtpTemplate
  { createSmtpTemplateTag = Nothing
  , createSmtpTemplateSender
  , createSmtpTemplateTemplateName
  , createSmtpTemplateHtmlContent = Nothing
  , createSmtpTemplateHtmlUrl = Nothing
  , createSmtpTemplateSubject
  , createSmtpTemplateReplyTo = Nothing
  , createSmtpTemplateToField = Nothing
  , createSmtpTemplateAttachmentUrl = Nothing
  , createSmtpTemplateIsActive = Nothing
  }

-- ** CreateSmtpTemplateSender
-- | CreateSmtpTemplateSender
-- Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
data CreateSmtpTemplateSender = CreateSmtpTemplateSender
  { createSmtpTemplateSenderName :: !(Maybe Text) -- ^ "name" - Name of the sender. If not passed, will be set to default
  , createSmtpTemplateSenderEmail :: !(Maybe Text) -- ^ "email" - Email of the sender
  , createSmtpTemplateSenderId :: !(Maybe Integer) -- ^ "id" - Select the sender for the template on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSmtpTemplateSender
instance A.FromJSON CreateSmtpTemplateSender where
  parseJSON = A.withObject "CreateSmtpTemplateSender" $ \o ->
    CreateSmtpTemplateSender
      <$> (o .:? "name")
      <*> (o .:? "email")
      <*> (o .:? "id")

-- | ToJSON CreateSmtpTemplateSender
instance A.ToJSON CreateSmtpTemplateSender where
  toJSON CreateSmtpTemplateSender {..} =
   _omitNulls
      [ "name" .= createSmtpTemplateSenderName
      , "email" .= createSmtpTemplateSenderEmail
      , "id" .= createSmtpTemplateSenderId
      ]


-- | Construct a value of type 'CreateSmtpTemplateSender' (by applying it's required fields, if any)
mkCreateSmtpTemplateSender
  :: CreateSmtpTemplateSender
mkCreateSmtpTemplateSender =
  CreateSmtpTemplateSender
  { createSmtpTemplateSenderName = Nothing
  , createSmtpTemplateSenderEmail = Nothing
  , createSmtpTemplateSenderId = Nothing
  }

-- ** CreateUpdateContactModel
-- | CreateUpdateContactModel
data CreateUpdateContactModel = CreateUpdateContactModel
  { createUpdateContactModelId :: !(Maybe Integer) -- ^ "id" - ID of the contact when a new contact is created
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateUpdateContactModel
instance A.FromJSON CreateUpdateContactModel where
  parseJSON = A.withObject "CreateUpdateContactModel" $ \o ->
    CreateUpdateContactModel
      <$> (o .:? "id")

-- | ToJSON CreateUpdateContactModel
instance A.ToJSON CreateUpdateContactModel where
  toJSON CreateUpdateContactModel {..} =
   _omitNulls
      [ "id" .= createUpdateContactModelId
      ]


-- | Construct a value of type 'CreateUpdateContactModel' (by applying it's required fields, if any)
mkCreateUpdateContactModel
  :: CreateUpdateContactModel
mkCreateUpdateContactModel =
  CreateUpdateContactModel
  { createUpdateContactModelId = Nothing
  }

-- ** CreateUpdateFolder
-- | CreateUpdateFolder
data CreateUpdateFolder = CreateUpdateFolder
  { createUpdateFolderName :: !(Maybe Text) -- ^ "name" - Name of the folder
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateUpdateFolder
instance A.FromJSON CreateUpdateFolder where
  parseJSON = A.withObject "CreateUpdateFolder" $ \o ->
    CreateUpdateFolder
      <$> (o .:? "name")

-- | ToJSON CreateUpdateFolder
instance A.ToJSON CreateUpdateFolder where
  toJSON CreateUpdateFolder {..} =
   _omitNulls
      [ "name" .= createUpdateFolderName
      ]


-- | Construct a value of type 'CreateUpdateFolder' (by applying it's required fields, if any)
mkCreateUpdateFolder
  :: CreateUpdateFolder
mkCreateUpdateFolder =
  CreateUpdateFolder
  { createUpdateFolderName = Nothing
  }

-- ** CreateWebhook
-- | CreateWebhook
data CreateWebhook = CreateWebhook
  { createWebhookUrl :: !(Text) -- ^ /Required/ "url" - URL of the webhook
  , createWebhookDescription :: !(Maybe Text) -- ^ "description" - Description of the webhook
  , createWebhookEvents :: !([E'Events]) -- ^ /Required/ "events" - Events triggering the webhook. Possible values for Transactional type webhook – request, delivered, hardBounce, softBounce, blocked, spam, invalid, deferred, click, opened, uniqueOpened and unsubscribed and possible values for Marketing type webhook – spam, opened, click, hardBounce, softBounce, unsubscribed, listAddition &amp; delivered
  , createWebhookType :: !(Maybe E'Type3) -- ^ "type" - Type of the webhook
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateWebhook
instance A.FromJSON CreateWebhook where
  parseJSON = A.withObject "CreateWebhook" $ \o ->
    CreateWebhook
      <$> (o .:  "url")
      <*> (o .:? "description")
      <*> (o .:  "events")
      <*> (o .:? "type")

-- | ToJSON CreateWebhook
instance A.ToJSON CreateWebhook where
  toJSON CreateWebhook {..} =
   _omitNulls
      [ "url" .= createWebhookUrl
      , "description" .= createWebhookDescription
      , "events" .= createWebhookEvents
      , "type" .= createWebhookType
      ]


-- | Construct a value of type 'CreateWebhook' (by applying it's required fields, if any)
mkCreateWebhook
  :: Text -- ^ 'createWebhookUrl': URL of the webhook
  -> [E'Events] -- ^ 'createWebhookEvents': Events triggering the webhook. Possible values for Transactional type webhook – request, delivered, hardBounce, softBounce, blocked, spam, invalid, deferred, click, opened, uniqueOpened and unsubscribed and possible values for Marketing type webhook – spam, opened, click, hardBounce, softBounce, unsubscribed, listAddition & delivered
  -> CreateWebhook
mkCreateWebhook createWebhookUrl createWebhookEvents =
  CreateWebhook
  { createWebhookUrl
  , createWebhookDescription = Nothing
  , createWebhookEvents
  , createWebhookType = Nothing
  }

-- ** CreatedProcessId
-- | CreatedProcessId
data CreatedProcessId = CreatedProcessId
  { createdProcessIdProcessId :: !(Integer) -- ^ /Required/ "processId" - Id of the process created
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreatedProcessId
instance A.FromJSON CreatedProcessId where
  parseJSON = A.withObject "CreatedProcessId" $ \o ->
    CreatedProcessId
      <$> (o .:  "processId")

-- | ToJSON CreatedProcessId
instance A.ToJSON CreatedProcessId where
  toJSON CreatedProcessId {..} =
   _omitNulls
      [ "processId" .= createdProcessIdProcessId
      ]


-- | Construct a value of type 'CreatedProcessId' (by applying it's required fields, if any)
mkCreatedProcessId
  :: Integer -- ^ 'createdProcessIdProcessId': Id of the process created
  -> CreatedProcessId
mkCreatedProcessId createdProcessIdProcessId =
  CreatedProcessId
  { createdProcessIdProcessId
  }

-- ** DeleteHardbounces
-- | DeleteHardbounces
data DeleteHardbounces = DeleteHardbounces
  { deleteHardbouncesStartDate :: !(Maybe Text) -- ^ "startDate" - Starting date (YYYY-MM-DD) of the time period for deletion. The hardbounces occurred after this date will be deleted. Must be less than or equal to the endDate
  , deleteHardbouncesEndDate :: !(Maybe Text) -- ^ "endDate" - Ending date (YYYY-MM-DD) of the time period for deletion. The hardbounces until this date will be deleted. Must be greater than or equal to the startDate
  , deleteHardbouncesContactEmail :: !(Maybe Text) -- ^ "contactEmail" - Target a specific email address
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteHardbounces
instance A.FromJSON DeleteHardbounces where
  parseJSON = A.withObject "DeleteHardbounces" $ \o ->
    DeleteHardbounces
      <$> (o .:? "startDate")
      <*> (o .:? "endDate")
      <*> (o .:? "contactEmail")

-- | ToJSON DeleteHardbounces
instance A.ToJSON DeleteHardbounces where
  toJSON DeleteHardbounces {..} =
   _omitNulls
      [ "startDate" .= deleteHardbouncesStartDate
      , "endDate" .= deleteHardbouncesEndDate
      , "contactEmail" .= deleteHardbouncesContactEmail
      ]


-- | Construct a value of type 'DeleteHardbounces' (by applying it's required fields, if any)
mkDeleteHardbounces
  :: DeleteHardbounces
mkDeleteHardbounces =
  DeleteHardbounces
  { deleteHardbouncesStartDate = Nothing
  , deleteHardbouncesEndDate = Nothing
  , deleteHardbouncesContactEmail = Nothing
  }

-- ** EmailExportRecipients
-- | EmailExportRecipients
data EmailExportRecipients = EmailExportRecipients
  { emailExportRecipientsNotifyUrl :: !(Maybe Text) -- ^ "notifyURL" - Webhook called once the export process is finished
  , emailExportRecipientsRecipientsType :: !(E'RecipientsType) -- ^ /Required/ "recipientsType" - Type of recipients to export for a campaign
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmailExportRecipients
instance A.FromJSON EmailExportRecipients where
  parseJSON = A.withObject "EmailExportRecipients" $ \o ->
    EmailExportRecipients
      <$> (o .:? "notifyURL")
      <*> (o .:  "recipientsType")

-- | ToJSON EmailExportRecipients
instance A.ToJSON EmailExportRecipients where
  toJSON EmailExportRecipients {..} =
   _omitNulls
      [ "notifyURL" .= emailExportRecipientsNotifyUrl
      , "recipientsType" .= emailExportRecipientsRecipientsType
      ]


-- | Construct a value of type 'EmailExportRecipients' (by applying it's required fields, if any)
mkEmailExportRecipients
  :: E'RecipientsType -- ^ 'emailExportRecipientsRecipientsType': Type of recipients to export for a campaign
  -> EmailExportRecipients
mkEmailExportRecipients emailExportRecipientsRecipientsType =
  EmailExportRecipients
  { emailExportRecipientsNotifyUrl = Nothing
  , emailExportRecipientsRecipientsType
  }

-- ** ErrorModel
-- | ErrorModel
data ErrorModel = ErrorModel
  { errorModelCode :: !(E'Code) -- ^ /Required/ "code" - Error code displayed in case of a failure
  , errorModelMessage :: !(Text) -- ^ /Required/ "message" - Readable message associated to the failure
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorModel
instance A.FromJSON ErrorModel where
  parseJSON = A.withObject "ErrorModel" $ \o ->
    ErrorModel
      <$> (o .:  "code")
      <*> (o .:  "message")

-- | ToJSON ErrorModel
instance A.ToJSON ErrorModel where
  toJSON ErrorModel {..} =
   _omitNulls
      [ "code" .= errorModelCode
      , "message" .= errorModelMessage
      ]


-- | Construct a value of type 'ErrorModel' (by applying it's required fields, if any)
mkErrorModel
  :: E'Code -- ^ 'errorModelCode': Error code displayed in case of a failure
  -> Text -- ^ 'errorModelMessage': Readable message associated to the failure
  -> ErrorModel
mkErrorModel errorModelCode errorModelMessage =
  ErrorModel
  { errorModelCode
  , errorModelMessage
  }

-- ** GetAccountMarketingAutomation
-- | GetAccountMarketingAutomation
data GetAccountMarketingAutomation = GetAccountMarketingAutomation
  { getAccountMarketingAutomationKey :: !(Maybe Text) -- ^ "key" - Marketing Automation Tracker ID
  , getAccountMarketingAutomationEnabled :: !(Bool) -- ^ /Required/ "enabled" - Status of Marketing Automation Plateform activation for your account (true&#x3D;enabled, false&#x3D;disabled)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAccountMarketingAutomation
instance A.FromJSON GetAccountMarketingAutomation where
  parseJSON = A.withObject "GetAccountMarketingAutomation" $ \o ->
    GetAccountMarketingAutomation
      <$> (o .:? "key")
      <*> (o .:  "enabled")

-- | ToJSON GetAccountMarketingAutomation
instance A.ToJSON GetAccountMarketingAutomation where
  toJSON GetAccountMarketingAutomation {..} =
   _omitNulls
      [ "key" .= getAccountMarketingAutomationKey
      , "enabled" .= getAccountMarketingAutomationEnabled
      ]


-- | Construct a value of type 'GetAccountMarketingAutomation' (by applying it's required fields, if any)
mkGetAccountMarketingAutomation
  :: Bool -- ^ 'getAccountMarketingAutomationEnabled': Status of Marketing Automation Plateform activation for your account (true=enabled, false=disabled)
  -> GetAccountMarketingAutomation
mkGetAccountMarketingAutomation getAccountMarketingAutomationEnabled =
  GetAccountMarketingAutomation
  { getAccountMarketingAutomationKey = Nothing
  , getAccountMarketingAutomationEnabled
  }

-- ** GetAccountPlan
-- | GetAccountPlan
data GetAccountPlan = GetAccountPlan
  { getAccountPlanType :: !(E'Type5) -- ^ /Required/ "type" - Displays the plan type of the user
  , getAccountPlanCreditsType :: !(E'CreditsType) -- ^ /Required/ "creditsType" - This is the type of the credit, \&quot;Send Limit\&quot; is one of the possible types of credit of a user. \&quot;Send Limit\&quot; implies the total number of emails you can send to the subscribers in your account.
  , getAccountPlanCredits :: !(Float) -- ^ /Required/ "credits" - Remaining credits of the user
  , getAccountPlanStartDate :: !(Maybe Date) -- ^ "startDate" - Date of the period from which the plan will start (only available for \&quot;subscription\&quot; and \&quot;reseller\&quot; plan type)
  , getAccountPlanEndDate :: !(Maybe Date) -- ^ "endDate" - Date of the period from which the plan will end (only available for \&quot;subscription\&quot; and \&quot;reseller\&quot; plan type)
  , getAccountPlanUserLimit :: !(Maybe Int) -- ^ "userLimit" - Only in case of reseller account. It implies the total number of child accounts you can add to your account.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAccountPlan
instance A.FromJSON GetAccountPlan where
  parseJSON = A.withObject "GetAccountPlan" $ \o ->
    GetAccountPlan
      <$> (o .:  "type")
      <*> (o .:  "creditsType")
      <*> (o .:  "credits")
      <*> (o .:? "startDate")
      <*> (o .:? "endDate")
      <*> (o .:? "userLimit")

-- | ToJSON GetAccountPlan
instance A.ToJSON GetAccountPlan where
  toJSON GetAccountPlan {..} =
   _omitNulls
      [ "type" .= getAccountPlanType
      , "creditsType" .= getAccountPlanCreditsType
      , "credits" .= getAccountPlanCredits
      , "startDate" .= getAccountPlanStartDate
      , "endDate" .= getAccountPlanEndDate
      , "userLimit" .= getAccountPlanUserLimit
      ]


-- | Construct a value of type 'GetAccountPlan' (by applying it's required fields, if any)
mkGetAccountPlan
  :: E'Type5 -- ^ 'getAccountPlanType': Displays the plan type of the user
  -> E'CreditsType -- ^ 'getAccountPlanCreditsType': This is the type of the credit, \"Send Limit\" is one of the possible types of credit of a user. \"Send Limit\" implies the total number of emails you can send to the subscribers in your account.
  -> Float -- ^ 'getAccountPlanCredits': Remaining credits of the user
  -> GetAccountPlan
mkGetAccountPlan getAccountPlanType getAccountPlanCreditsType getAccountPlanCredits =
  GetAccountPlan
  { getAccountPlanType
  , getAccountPlanCreditsType
  , getAccountPlanCredits
  , getAccountPlanStartDate = Nothing
  , getAccountPlanEndDate = Nothing
  , getAccountPlanUserLimit = Nothing
  }

-- ** GetAccountRelay
-- | GetAccountRelay
-- Information about your transactional email account
data GetAccountRelay = GetAccountRelay
  { getAccountRelayEnabled :: !(Bool) -- ^ /Required/ "enabled" - Status of your transactional email Account (true&#x3D;Enabled, false&#x3D;Disabled)
  , getAccountRelayData :: !(GetAccountRelayData) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAccountRelay
instance A.FromJSON GetAccountRelay where
  parseJSON = A.withObject "GetAccountRelay" $ \o ->
    GetAccountRelay
      <$> (o .:  "enabled")
      <*> (o .:  "data")

-- | ToJSON GetAccountRelay
instance A.ToJSON GetAccountRelay where
  toJSON GetAccountRelay {..} =
   _omitNulls
      [ "enabled" .= getAccountRelayEnabled
      , "data" .= getAccountRelayData
      ]


-- | Construct a value of type 'GetAccountRelay' (by applying it's required fields, if any)
mkGetAccountRelay
  :: Bool -- ^ 'getAccountRelayEnabled': Status of your transactional email Account (true=Enabled, false=Disabled)
  -> GetAccountRelayData -- ^ 'getAccountRelayData' 
  -> GetAccountRelay
mkGetAccountRelay getAccountRelayEnabled getAccountRelayData =
  GetAccountRelay
  { getAccountRelayEnabled
  , getAccountRelayData
  }

-- ** GetAccountRelayData
-- | GetAccountRelayData
-- Data regarding the transactional email account
data GetAccountRelayData = GetAccountRelayData
  { getAccountRelayDataUserName :: !(Text) -- ^ /Required/ "userName" - Email to use as login on transactional platform
  , getAccountRelayDataRelay :: !(Text) -- ^ /Required/ "relay" - URL of the SMTP Relay
  , getAccountRelayDataPort :: !(Int) -- ^ /Required/ "port" - Port used for SMTP Relay
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAccountRelayData
instance A.FromJSON GetAccountRelayData where
  parseJSON = A.withObject "GetAccountRelayData" $ \o ->
    GetAccountRelayData
      <$> (o .:  "userName")
      <*> (o .:  "relay")
      <*> (o .:  "port")

-- | ToJSON GetAccountRelayData
instance A.ToJSON GetAccountRelayData where
  toJSON GetAccountRelayData {..} =
   _omitNulls
      [ "userName" .= getAccountRelayDataUserName
      , "relay" .= getAccountRelayDataRelay
      , "port" .= getAccountRelayDataPort
      ]


-- | Construct a value of type 'GetAccountRelayData' (by applying it's required fields, if any)
mkGetAccountRelayData
  :: Text -- ^ 'getAccountRelayDataUserName': Email to use as login on transactional platform
  -> Text -- ^ 'getAccountRelayDataRelay': URL of the SMTP Relay
  -> Int -- ^ 'getAccountRelayDataPort': Port used for SMTP Relay
  -> GetAccountRelayData
mkGetAccountRelayData getAccountRelayDataUserName getAccountRelayDataRelay getAccountRelayDataPort =
  GetAccountRelayData
  { getAccountRelayDataUserName
  , getAccountRelayDataRelay
  , getAccountRelayDataPort
  }

-- ** GetAggregatedReport
-- | GetAggregatedReport
data GetAggregatedReport = GetAggregatedReport
  { getAggregatedReportRange :: !(Text) -- ^ /Required/ "range" - Time frame of the report
  , getAggregatedReportRequests :: !(Integer) -- ^ /Required/ "requests" - Number of requests for the timeframe
  , getAggregatedReportDelivered :: !(Integer) -- ^ /Required/ "delivered" - Number of delivered emails for the timeframe
  , getAggregatedReportHardBounces :: !(Integer) -- ^ /Required/ "hardBounces" - Number of hardbounces for the timeframe
  , getAggregatedReportSoftBounces :: !(Integer) -- ^ /Required/ "softBounces" - Number of softbounces for the timeframe
  , getAggregatedReportClicks :: !(Integer) -- ^ /Required/ "clicks" - Number of clicks for the timeframe
  , getAggregatedReportUniqueClicks :: !(Integer) -- ^ /Required/ "uniqueClicks" - Number of unique clicks for the timeframe
  , getAggregatedReportOpens :: !(Integer) -- ^ /Required/ "opens" - Number of openings for the timeframe
  , getAggregatedReportUniqueOpens :: !(Integer) -- ^ /Required/ "uniqueOpens" - Number of unique openings for the timeframe
  , getAggregatedReportSpamReports :: !(Integer) -- ^ /Required/ "spamReports" - Number of complaint (spam report) for the timeframe
  , getAggregatedReportBlocked :: !(Integer) -- ^ /Required/ "blocked" - Number of blocked contact emails for the timeframe
  , getAggregatedReportInvalid :: !(Integer) -- ^ /Required/ "invalid" - Number of invalid emails for the timeframe
  , getAggregatedReportUnsubscribed :: !(Integer) -- ^ /Required/ "unsubscribed" - Number of unsubscribed emails for the timeframe
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAggregatedReport
instance A.FromJSON GetAggregatedReport where
  parseJSON = A.withObject "GetAggregatedReport" $ \o ->
    GetAggregatedReport
      <$> (o .:  "range")
      <*> (o .:  "requests")
      <*> (o .:  "delivered")
      <*> (o .:  "hardBounces")
      <*> (o .:  "softBounces")
      <*> (o .:  "clicks")
      <*> (o .:  "uniqueClicks")
      <*> (o .:  "opens")
      <*> (o .:  "uniqueOpens")
      <*> (o .:  "spamReports")
      <*> (o .:  "blocked")
      <*> (o .:  "invalid")
      <*> (o .:  "unsubscribed")

-- | ToJSON GetAggregatedReport
instance A.ToJSON GetAggregatedReport where
  toJSON GetAggregatedReport {..} =
   _omitNulls
      [ "range" .= getAggregatedReportRange
      , "requests" .= getAggregatedReportRequests
      , "delivered" .= getAggregatedReportDelivered
      , "hardBounces" .= getAggregatedReportHardBounces
      , "softBounces" .= getAggregatedReportSoftBounces
      , "clicks" .= getAggregatedReportClicks
      , "uniqueClicks" .= getAggregatedReportUniqueClicks
      , "opens" .= getAggregatedReportOpens
      , "uniqueOpens" .= getAggregatedReportUniqueOpens
      , "spamReports" .= getAggregatedReportSpamReports
      , "blocked" .= getAggregatedReportBlocked
      , "invalid" .= getAggregatedReportInvalid
      , "unsubscribed" .= getAggregatedReportUnsubscribed
      ]


-- | Construct a value of type 'GetAggregatedReport' (by applying it's required fields, if any)
mkGetAggregatedReport
  :: Text -- ^ 'getAggregatedReportRange': Time frame of the report
  -> Integer -- ^ 'getAggregatedReportRequests': Number of requests for the timeframe
  -> Integer -- ^ 'getAggregatedReportDelivered': Number of delivered emails for the timeframe
  -> Integer -- ^ 'getAggregatedReportHardBounces': Number of hardbounces for the timeframe
  -> Integer -- ^ 'getAggregatedReportSoftBounces': Number of softbounces for the timeframe
  -> Integer -- ^ 'getAggregatedReportClicks': Number of clicks for the timeframe
  -> Integer -- ^ 'getAggregatedReportUniqueClicks': Number of unique clicks for the timeframe
  -> Integer -- ^ 'getAggregatedReportOpens': Number of openings for the timeframe
  -> Integer -- ^ 'getAggregatedReportUniqueOpens': Number of unique openings for the timeframe
  -> Integer -- ^ 'getAggregatedReportSpamReports': Number of complaint (spam report) for the timeframe
  -> Integer -- ^ 'getAggregatedReportBlocked': Number of blocked contact emails for the timeframe
  -> Integer -- ^ 'getAggregatedReportInvalid': Number of invalid emails for the timeframe
  -> Integer -- ^ 'getAggregatedReportUnsubscribed': Number of unsubscribed emails for the timeframe
  -> GetAggregatedReport
mkGetAggregatedReport getAggregatedReportRange getAggregatedReportRequests getAggregatedReportDelivered getAggregatedReportHardBounces getAggregatedReportSoftBounces getAggregatedReportClicks getAggregatedReportUniqueClicks getAggregatedReportOpens getAggregatedReportUniqueOpens getAggregatedReportSpamReports getAggregatedReportBlocked getAggregatedReportInvalid getAggregatedReportUnsubscribed =
  GetAggregatedReport
  { getAggregatedReportRange
  , getAggregatedReportRequests
  , getAggregatedReportDelivered
  , getAggregatedReportHardBounces
  , getAggregatedReportSoftBounces
  , getAggregatedReportClicks
  , getAggregatedReportUniqueClicks
  , getAggregatedReportOpens
  , getAggregatedReportUniqueOpens
  , getAggregatedReportSpamReports
  , getAggregatedReportBlocked
  , getAggregatedReportInvalid
  , getAggregatedReportUnsubscribed
  }

-- ** GetAttributes
-- | GetAttributes
data GetAttributes = GetAttributes
  { getAttributesAttributes :: !([GetAttributesAttributes]) -- ^ /Required/ "attributes" - Listing of available contact attributes in your account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAttributes
instance A.FromJSON GetAttributes where
  parseJSON = A.withObject "GetAttributes" $ \o ->
    GetAttributes
      <$> (o .:  "attributes")

-- | ToJSON GetAttributes
instance A.ToJSON GetAttributes where
  toJSON GetAttributes {..} =
   _omitNulls
      [ "attributes" .= getAttributesAttributes
      ]


-- | Construct a value of type 'GetAttributes' (by applying it's required fields, if any)
mkGetAttributes
  :: [GetAttributesAttributes] -- ^ 'getAttributesAttributes': Listing of available contact attributes in your account
  -> GetAttributes
mkGetAttributes getAttributesAttributes =
  GetAttributes
  { getAttributesAttributes
  }

-- ** GetAttributesAttributes
-- | GetAttributesAttributes
data GetAttributesAttributes = GetAttributesAttributes
  { getAttributesAttributesName :: !(Text) -- ^ /Required/ "name" - Name of the attribute
  , getAttributesAttributesCategory :: !(E'Category) -- ^ /Required/ "category" - Category of the attribute
  , getAttributesAttributesType :: !(Maybe E'Type6) -- ^ "type" - Type of the attribute
  , getAttributesAttributesEnumeration :: !(Maybe [GetAttributesEnumeration]) -- ^ "enumeration" - Parameter only available for \&quot;category\&quot; type attributes.
  , getAttributesAttributesCalculatedValue :: !(Maybe Text) -- ^ "calculatedValue" - Calculated value formula
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAttributesAttributes
instance A.FromJSON GetAttributesAttributes where
  parseJSON = A.withObject "GetAttributesAttributes" $ \o ->
    GetAttributesAttributes
      <$> (o .:  "name")
      <*> (o .:  "category")
      <*> (o .:? "type")
      <*> (o .:? "enumeration")
      <*> (o .:? "calculatedValue")

-- | ToJSON GetAttributesAttributes
instance A.ToJSON GetAttributesAttributes where
  toJSON GetAttributesAttributes {..} =
   _omitNulls
      [ "name" .= getAttributesAttributesName
      , "category" .= getAttributesAttributesCategory
      , "type" .= getAttributesAttributesType
      , "enumeration" .= getAttributesAttributesEnumeration
      , "calculatedValue" .= getAttributesAttributesCalculatedValue
      ]


-- | Construct a value of type 'GetAttributesAttributes' (by applying it's required fields, if any)
mkGetAttributesAttributes
  :: Text -- ^ 'getAttributesAttributesName': Name of the attribute
  -> E'Category -- ^ 'getAttributesAttributesCategory': Category of the attribute
  -> GetAttributesAttributes
mkGetAttributesAttributes getAttributesAttributesName getAttributesAttributesCategory =
  GetAttributesAttributes
  { getAttributesAttributesName
  , getAttributesAttributesCategory
  , getAttributesAttributesType = Nothing
  , getAttributesAttributesEnumeration = Nothing
  , getAttributesAttributesCalculatedValue = Nothing
  }

-- ** GetAttributesEnumeration
-- | GetAttributesEnumeration
data GetAttributesEnumeration = GetAttributesEnumeration
  { getAttributesEnumerationValue :: !(Integer) -- ^ /Required/ "value" - ID of Value of the \&quot;category\&quot; type attribute
  , getAttributesEnumerationLabel :: !(Text) -- ^ /Required/ "label" - Label of the \&quot;category\&quot; type attribute
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAttributesEnumeration
instance A.FromJSON GetAttributesEnumeration where
  parseJSON = A.withObject "GetAttributesEnumeration" $ \o ->
    GetAttributesEnumeration
      <$> (o .:  "value")
      <*> (o .:  "label")

-- | ToJSON GetAttributesEnumeration
instance A.ToJSON GetAttributesEnumeration where
  toJSON GetAttributesEnumeration {..} =
   _omitNulls
      [ "value" .= getAttributesEnumerationValue
      , "label" .= getAttributesEnumerationLabel
      ]


-- | Construct a value of type 'GetAttributesEnumeration' (by applying it's required fields, if any)
mkGetAttributesEnumeration
  :: Integer -- ^ 'getAttributesEnumerationValue': ID of Value of the \"category\" type attribute
  -> Text -- ^ 'getAttributesEnumerationLabel': Label of the \"category\" type attribute
  -> GetAttributesEnumeration
mkGetAttributesEnumeration getAttributesEnumerationValue getAttributesEnumerationLabel =
  GetAttributesEnumeration
  { getAttributesEnumerationValue
  , getAttributesEnumerationLabel
  }

-- ** GetCampaignOverview
-- | GetCampaignOverview
data GetCampaignOverview = GetCampaignOverview
  { getCampaignOverviewId :: !(Integer) -- ^ /Required/ "id" - ID of the campaign
  , getCampaignOverviewName :: !(Text) -- ^ /Required/ "name" - Name of the campaign
  , getCampaignOverviewSubject :: !(Maybe Text) -- ^ "subject" - Subject of the campaign. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;false&#x60;
  , getCampaignOverviewType :: !(E'Type) -- ^ /Required/ "type" - Type of campaign
  , getCampaignOverviewStatus :: !(E'Status3) -- ^ /Required/ "status" - Status of the campaign
  , getCampaignOverviewScheduledAt :: !(Maybe DateTime) -- ^ "scheduledAt" - UTC date-time on which campaign is scheduled (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getCampaignOverviewAbTesting :: !(Maybe Bool) -- ^ "abTesting" - Status of A/B Test for the campaign. abTesting &#x3D; false means it is disabled, &amp; abTesting &#x3D; true means it is enabled.
  , getCampaignOverviewSubjectA :: !(Maybe Text) -- ^ "subjectA" - Subject A of the ab-test campaign. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getCampaignOverviewSubjectB :: !(Maybe Text) -- ^ "subjectB" - Subject B of the ab-test campaign. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getCampaignOverviewSplitRule :: !(Maybe Int) -- ^ "splitRule" - The size of your ab-test groups. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getCampaignOverviewWinnerCriteria :: !(Maybe Text) -- ^ "winnerCriteria" - Criteria for the winning version. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getCampaignOverviewWinnerDelay :: !(Maybe Int) -- ^ "winnerDelay" - The duration of the test in hours at the end of which the winning version will be sent. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getCampaignOverviewSendAtBestTime :: !(Maybe Bool) -- ^ "sendAtBestTime" - It is true if you have chosen to send your campaign at best time, otherwise it is false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignOverview
instance A.FromJSON GetCampaignOverview where
  parseJSON = A.withObject "GetCampaignOverview" $ \o ->
    GetCampaignOverview
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:? "subject")
      <*> (o .:  "type")
      <*> (o .:  "status")
      <*> (o .:? "scheduledAt")
      <*> (o .:? "abTesting")
      <*> (o .:? "subjectA")
      <*> (o .:? "subjectB")
      <*> (o .:? "splitRule")
      <*> (o .:? "winnerCriteria")
      <*> (o .:? "winnerDelay")
      <*> (o .:? "sendAtBestTime")

-- | ToJSON GetCampaignOverview
instance A.ToJSON GetCampaignOverview where
  toJSON GetCampaignOverview {..} =
   _omitNulls
      [ "id" .= getCampaignOverviewId
      , "name" .= getCampaignOverviewName
      , "subject" .= getCampaignOverviewSubject
      , "type" .= getCampaignOverviewType
      , "status" .= getCampaignOverviewStatus
      , "scheduledAt" .= getCampaignOverviewScheduledAt
      , "abTesting" .= getCampaignOverviewAbTesting
      , "subjectA" .= getCampaignOverviewSubjectA
      , "subjectB" .= getCampaignOverviewSubjectB
      , "splitRule" .= getCampaignOverviewSplitRule
      , "winnerCriteria" .= getCampaignOverviewWinnerCriteria
      , "winnerDelay" .= getCampaignOverviewWinnerDelay
      , "sendAtBestTime" .= getCampaignOverviewSendAtBestTime
      ]


-- | Construct a value of type 'GetCampaignOverview' (by applying it's required fields, if any)
mkGetCampaignOverview
  :: Integer -- ^ 'getCampaignOverviewId': ID of the campaign
  -> Text -- ^ 'getCampaignOverviewName': Name of the campaign
  -> E'Type -- ^ 'getCampaignOverviewType': Type of campaign
  -> E'Status3 -- ^ 'getCampaignOverviewStatus': Status of the campaign
  -> GetCampaignOverview
mkGetCampaignOverview getCampaignOverviewId getCampaignOverviewName getCampaignOverviewType getCampaignOverviewStatus =
  GetCampaignOverview
  { getCampaignOverviewId
  , getCampaignOverviewName
  , getCampaignOverviewSubject = Nothing
  , getCampaignOverviewType
  , getCampaignOverviewStatus
  , getCampaignOverviewScheduledAt = Nothing
  , getCampaignOverviewAbTesting = Nothing
  , getCampaignOverviewSubjectA = Nothing
  , getCampaignOverviewSubjectB = Nothing
  , getCampaignOverviewSplitRule = Nothing
  , getCampaignOverviewWinnerCriteria = Nothing
  , getCampaignOverviewWinnerDelay = Nothing
  , getCampaignOverviewSendAtBestTime = Nothing
  }

-- ** GetCampaignRecipients
-- | GetCampaignRecipients
data GetCampaignRecipients = GetCampaignRecipients
  { getCampaignRecipientsLists :: !([Integer]) -- ^ /Required/ "lists"
  , getCampaignRecipientsExclusionLists :: !([Integer]) -- ^ /Required/ "exclusionLists"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignRecipients
instance A.FromJSON GetCampaignRecipients where
  parseJSON = A.withObject "GetCampaignRecipients" $ \o ->
    GetCampaignRecipients
      <$> (o .:  "lists")
      <*> (o .:  "exclusionLists")

-- | ToJSON GetCampaignRecipients
instance A.ToJSON GetCampaignRecipients where
  toJSON GetCampaignRecipients {..} =
   _omitNulls
      [ "lists" .= getCampaignRecipientsLists
      , "exclusionLists" .= getCampaignRecipientsExclusionLists
      ]


-- | Construct a value of type 'GetCampaignRecipients' (by applying it's required fields, if any)
mkGetCampaignRecipients
  :: [Integer] -- ^ 'getCampaignRecipientsLists' 
  -> [Integer] -- ^ 'getCampaignRecipientsExclusionLists' 
  -> GetCampaignRecipients
mkGetCampaignRecipients getCampaignRecipientsLists getCampaignRecipientsExclusionLists =
  GetCampaignRecipients
  { getCampaignRecipientsLists
  , getCampaignRecipientsExclusionLists
  }

-- ** GetCampaignStats
-- | GetCampaignStats
data GetCampaignStats = GetCampaignStats
  { getCampaignStatsListId :: !(Maybe Integer) -- ^ "listId" - List Id of email campaign (only in case of get email campaign(s)(not for global stats))
  , getCampaignStatsUniqueClicks :: !(Integer) -- ^ /Required/ "uniqueClicks" - Number of unique clicks for the campaign
  , getCampaignStatsClickers :: !(Integer) -- ^ /Required/ "clickers" - Number of total clicks for the campaign
  , getCampaignStatsComplaints :: !(Integer) -- ^ /Required/ "complaints" - Number of complaints (Spam reports) for the campaign
  , getCampaignStatsDelivered :: !(Integer) -- ^ /Required/ "delivered" - Number of delivered emails for the campaign
  , getCampaignStatsSent :: !(Integer) -- ^ /Required/ "sent" - Number of sent emails for the campaign
  , getCampaignStatsSoftBounces :: !(Integer) -- ^ /Required/ "softBounces" - Number of softbounce for the campaign
  , getCampaignStatsHardBounces :: !(Integer) -- ^ /Required/ "hardBounces" - Number of harbounce for the campaign
  , getCampaignStatsUniqueViews :: !(Integer) -- ^ /Required/ "uniqueViews" - Number of unique openings for the campaign
  , getCampaignStatsUnsubscriptions :: !(Integer) -- ^ /Required/ "unsubscriptions" - Number of unsubscription for the campaign
  , getCampaignStatsViewed :: !(Integer) -- ^ /Required/ "viewed" - Number of openings for the campaign
  , getCampaignStatsDeferred :: !(Maybe Integer) -- ^ "deferred" - Number of deferred emails for the campaign
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignStats
instance A.FromJSON GetCampaignStats where
  parseJSON = A.withObject "GetCampaignStats" $ \o ->
    GetCampaignStats
      <$> (o .:? "listId")
      <*> (o .:  "uniqueClicks")
      <*> (o .:  "clickers")
      <*> (o .:  "complaints")
      <*> (o .:  "delivered")
      <*> (o .:  "sent")
      <*> (o .:  "softBounces")
      <*> (o .:  "hardBounces")
      <*> (o .:  "uniqueViews")
      <*> (o .:  "unsubscriptions")
      <*> (o .:  "viewed")
      <*> (o .:? "deferred")

-- | ToJSON GetCampaignStats
instance A.ToJSON GetCampaignStats where
  toJSON GetCampaignStats {..} =
   _omitNulls
      [ "listId" .= getCampaignStatsListId
      , "uniqueClicks" .= getCampaignStatsUniqueClicks
      , "clickers" .= getCampaignStatsClickers
      , "complaints" .= getCampaignStatsComplaints
      , "delivered" .= getCampaignStatsDelivered
      , "sent" .= getCampaignStatsSent
      , "softBounces" .= getCampaignStatsSoftBounces
      , "hardBounces" .= getCampaignStatsHardBounces
      , "uniqueViews" .= getCampaignStatsUniqueViews
      , "unsubscriptions" .= getCampaignStatsUnsubscriptions
      , "viewed" .= getCampaignStatsViewed
      , "deferred" .= getCampaignStatsDeferred
      ]


-- | Construct a value of type 'GetCampaignStats' (by applying it's required fields, if any)
mkGetCampaignStats
  :: Integer -- ^ 'getCampaignStatsUniqueClicks': Number of unique clicks for the campaign
  -> Integer -- ^ 'getCampaignStatsClickers': Number of total clicks for the campaign
  -> Integer -- ^ 'getCampaignStatsComplaints': Number of complaints (Spam reports) for the campaign
  -> Integer -- ^ 'getCampaignStatsDelivered': Number of delivered emails for the campaign
  -> Integer -- ^ 'getCampaignStatsSent': Number of sent emails for the campaign
  -> Integer -- ^ 'getCampaignStatsSoftBounces': Number of softbounce for the campaign
  -> Integer -- ^ 'getCampaignStatsHardBounces': Number of harbounce for the campaign
  -> Integer -- ^ 'getCampaignStatsUniqueViews': Number of unique openings for the campaign
  -> Integer -- ^ 'getCampaignStatsUnsubscriptions': Number of unsubscription for the campaign
  -> Integer -- ^ 'getCampaignStatsViewed': Number of openings for the campaign
  -> GetCampaignStats
mkGetCampaignStats getCampaignStatsUniqueClicks getCampaignStatsClickers getCampaignStatsComplaints getCampaignStatsDelivered getCampaignStatsSent getCampaignStatsSoftBounces getCampaignStatsHardBounces getCampaignStatsUniqueViews getCampaignStatsUnsubscriptions getCampaignStatsViewed =
  GetCampaignStats
  { getCampaignStatsListId = Nothing
  , getCampaignStatsUniqueClicks
  , getCampaignStatsClickers
  , getCampaignStatsComplaints
  , getCampaignStatsDelivered
  , getCampaignStatsSent
  , getCampaignStatsSoftBounces
  , getCampaignStatsHardBounces
  , getCampaignStatsUniqueViews
  , getCampaignStatsUnsubscriptions
  , getCampaignStatsViewed
  , getCampaignStatsDeferred = Nothing
  }

-- ** GetChildAccountCreationStatus
-- | GetChildAccountCreationStatus
data GetChildAccountCreationStatus = GetChildAccountCreationStatus
  { getChildAccountCreationStatusChildAccountCreated :: !(Bool) -- ^ /Required/ "childAccountCreated" - Status of child account creation whether it is successfully created (exists) or not.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChildAccountCreationStatus
instance A.FromJSON GetChildAccountCreationStatus where
  parseJSON = A.withObject "GetChildAccountCreationStatus" $ \o ->
    GetChildAccountCreationStatus
      <$> (o .:  "childAccountCreated")

-- | ToJSON GetChildAccountCreationStatus
instance A.ToJSON GetChildAccountCreationStatus where
  toJSON GetChildAccountCreationStatus {..} =
   _omitNulls
      [ "childAccountCreated" .= getChildAccountCreationStatusChildAccountCreated
      ]


-- | Construct a value of type 'GetChildAccountCreationStatus' (by applying it's required fields, if any)
mkGetChildAccountCreationStatus
  :: Bool -- ^ 'getChildAccountCreationStatusChildAccountCreated': Status of child account creation whether it is successfully created (exists) or not.
  -> GetChildAccountCreationStatus
mkGetChildAccountCreationStatus getChildAccountCreationStatusChildAccountCreated =
  GetChildAccountCreationStatus
  { getChildAccountCreationStatusChildAccountCreated
  }

-- ** GetChildDomain
-- | GetChildDomain
data GetChildDomain = GetChildDomain
  { getChildDomainDomain :: !(Text) -- ^ /Required/ "domain" - Sender domain
  , getChildDomainActive :: !(Bool) -- ^ /Required/ "active" - indicates whether a domain is verified or not
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChildDomain
instance A.FromJSON GetChildDomain where
  parseJSON = A.withObject "GetChildDomain" $ \o ->
    GetChildDomain
      <$> (o .:  "domain")
      <*> (o .:  "active")

-- | ToJSON GetChildDomain
instance A.ToJSON GetChildDomain where
  toJSON GetChildDomain {..} =
   _omitNulls
      [ "domain" .= getChildDomainDomain
      , "active" .= getChildDomainActive
      ]


-- | Construct a value of type 'GetChildDomain' (by applying it's required fields, if any)
mkGetChildDomain
  :: Text -- ^ 'getChildDomainDomain': Sender domain
  -> Bool -- ^ 'getChildDomainActive': indicates whether a domain is verified or not
  -> GetChildDomain
mkGetChildDomain getChildDomainDomain getChildDomainActive =
  GetChildDomain
  { getChildDomainDomain
  , getChildDomainActive
  }

-- ** GetChildDomains
-- | GetChildDomains
data GetChildDomains = GetChildDomains
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChildDomains
instance A.FromJSON GetChildDomains where
  parseJSON = A.withObject "GetChildDomains" $ \o ->
    pure GetChildDomains
      

-- | ToJSON GetChildDomains
instance A.ToJSON GetChildDomains where
  toJSON GetChildDomains  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'GetChildDomains' (by applying it's required fields, if any)
mkGetChildDomains
  :: GetChildDomains
mkGetChildDomains =
  GetChildDomains
  { 
  }

-- ** GetChildInfoApiKeys
-- | GetChildInfoApiKeys
-- API Keys associated to child account
data GetChildInfoApiKeys = GetChildInfoApiKeys
  { getChildInfoApiKeysV2 :: !([GetChildInfoApiKeysV2]) -- ^ /Required/ "v2"
  , getChildInfoApiKeysV3 :: !(Maybe [GetChildInfoApiKeysV3]) -- ^ "v3"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChildInfoApiKeys
instance A.FromJSON GetChildInfoApiKeys where
  parseJSON = A.withObject "GetChildInfoApiKeys" $ \o ->
    GetChildInfoApiKeys
      <$> (o .:  "v2")
      <*> (o .:? "v3")

-- | ToJSON GetChildInfoApiKeys
instance A.ToJSON GetChildInfoApiKeys where
  toJSON GetChildInfoApiKeys {..} =
   _omitNulls
      [ "v2" .= getChildInfoApiKeysV2
      , "v3" .= getChildInfoApiKeysV3
      ]


-- | Construct a value of type 'GetChildInfoApiKeys' (by applying it's required fields, if any)
mkGetChildInfoApiKeys
  :: [GetChildInfoApiKeysV2] -- ^ 'getChildInfoApiKeysV2' 
  -> GetChildInfoApiKeys
mkGetChildInfoApiKeys getChildInfoApiKeysV2 =
  GetChildInfoApiKeys
  { getChildInfoApiKeysV2
  , getChildInfoApiKeysV3 = Nothing
  }

-- ** GetChildInfoApiKeysV2
-- | GetChildInfoApiKeysV2
data GetChildInfoApiKeysV2 = GetChildInfoApiKeysV2
  { getChildInfoApiKeysV2Name :: !(Text) -- ^ /Required/ "name" - Name of the key for version 2
  , getChildInfoApiKeysV2Key :: !(Text) -- ^ /Required/ "key" - API Key for version 2
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChildInfoApiKeysV2
instance A.FromJSON GetChildInfoApiKeysV2 where
  parseJSON = A.withObject "GetChildInfoApiKeysV2" $ \o ->
    GetChildInfoApiKeysV2
      <$> (o .:  "name")
      <*> (o .:  "key")

-- | ToJSON GetChildInfoApiKeysV2
instance A.ToJSON GetChildInfoApiKeysV2 where
  toJSON GetChildInfoApiKeysV2 {..} =
   _omitNulls
      [ "name" .= getChildInfoApiKeysV2Name
      , "key" .= getChildInfoApiKeysV2Key
      ]


-- | Construct a value of type 'GetChildInfoApiKeysV2' (by applying it's required fields, if any)
mkGetChildInfoApiKeysV2
  :: Text -- ^ 'getChildInfoApiKeysV2Name': Name of the key for version 2
  -> Text -- ^ 'getChildInfoApiKeysV2Key': API Key for version 2
  -> GetChildInfoApiKeysV2
mkGetChildInfoApiKeysV2 getChildInfoApiKeysV2Name getChildInfoApiKeysV2Key =
  GetChildInfoApiKeysV2
  { getChildInfoApiKeysV2Name
  , getChildInfoApiKeysV2Key
  }

-- ** GetChildInfoApiKeysV3
-- | GetChildInfoApiKeysV3
data GetChildInfoApiKeysV3 = GetChildInfoApiKeysV3
  { getChildInfoApiKeysV3Name :: !(Text) -- ^ /Required/ "name" - Name of the key for version 3
  , getChildInfoApiKeysV3Key :: !(Text) -- ^ /Required/ "key" - API Key for version 3
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChildInfoApiKeysV3
instance A.FromJSON GetChildInfoApiKeysV3 where
  parseJSON = A.withObject "GetChildInfoApiKeysV3" $ \o ->
    GetChildInfoApiKeysV3
      <$> (o .:  "name")
      <*> (o .:  "key")

-- | ToJSON GetChildInfoApiKeysV3
instance A.ToJSON GetChildInfoApiKeysV3 where
  toJSON GetChildInfoApiKeysV3 {..} =
   _omitNulls
      [ "name" .= getChildInfoApiKeysV3Name
      , "key" .= getChildInfoApiKeysV3Key
      ]


-- | Construct a value of type 'GetChildInfoApiKeysV3' (by applying it's required fields, if any)
mkGetChildInfoApiKeysV3
  :: Text -- ^ 'getChildInfoApiKeysV3Name': Name of the key for version 3
  -> Text -- ^ 'getChildInfoApiKeysV3Key': API Key for version 3
  -> GetChildInfoApiKeysV3
mkGetChildInfoApiKeysV3 getChildInfoApiKeysV3Name getChildInfoApiKeysV3Key =
  GetChildInfoApiKeysV3
  { getChildInfoApiKeysV3Name
  , getChildInfoApiKeysV3Key
  }

-- ** GetChildInfoCredits
-- | GetChildInfoCredits
-- Credits available for your child
data GetChildInfoCredits = GetChildInfoCredits
  { getChildInfoCreditsEmailCredits :: !(Maybe Integer) -- ^ "emailCredits" - Email credits available for your child
  , getChildInfoCreditsSmsCredits :: !(Maybe Integer) -- ^ "smsCredits" - SMS credits available for your child
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChildInfoCredits
instance A.FromJSON GetChildInfoCredits where
  parseJSON = A.withObject "GetChildInfoCredits" $ \o ->
    GetChildInfoCredits
      <$> (o .:? "emailCredits")
      <*> (o .:? "smsCredits")

-- | ToJSON GetChildInfoCredits
instance A.ToJSON GetChildInfoCredits where
  toJSON GetChildInfoCredits {..} =
   _omitNulls
      [ "emailCredits" .= getChildInfoCreditsEmailCredits
      , "smsCredits" .= getChildInfoCreditsSmsCredits
      ]


-- | Construct a value of type 'GetChildInfoCredits' (by applying it's required fields, if any)
mkGetChildInfoCredits
  :: GetChildInfoCredits
mkGetChildInfoCredits =
  GetChildInfoCredits
  { getChildInfoCreditsEmailCredits = Nothing
  , getChildInfoCreditsSmsCredits = Nothing
  }

-- ** GetChildInfoStatistics
-- | GetChildInfoStatistics
-- Statistics about your child account activity
data GetChildInfoStatistics = GetChildInfoStatistics
  { getChildInfoStatisticsPreviousMonthTotalSent :: !(Maybe Integer) -- ^ "previousMonthTotalSent" - Overall emails sent for the previous month
  , getChildInfoStatisticsCurrentMonthTotalSent :: !(Maybe Integer) -- ^ "currentMonthTotalSent" - Overall emails sent for current month
  , getChildInfoStatisticsTotalSent :: !(Maybe Integer) -- ^ "totalSent" - Overall emails sent for since the account exists
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChildInfoStatistics
instance A.FromJSON GetChildInfoStatistics where
  parseJSON = A.withObject "GetChildInfoStatistics" $ \o ->
    GetChildInfoStatistics
      <$> (o .:? "previousMonthTotalSent")
      <*> (o .:? "currentMonthTotalSent")
      <*> (o .:? "totalSent")

-- | ToJSON GetChildInfoStatistics
instance A.ToJSON GetChildInfoStatistics where
  toJSON GetChildInfoStatistics {..} =
   _omitNulls
      [ "previousMonthTotalSent" .= getChildInfoStatisticsPreviousMonthTotalSent
      , "currentMonthTotalSent" .= getChildInfoStatisticsCurrentMonthTotalSent
      , "totalSent" .= getChildInfoStatisticsTotalSent
      ]


-- | Construct a value of type 'GetChildInfoStatistics' (by applying it's required fields, if any)
mkGetChildInfoStatistics
  :: GetChildInfoStatistics
mkGetChildInfoStatistics =
  GetChildInfoStatistics
  { getChildInfoStatisticsPreviousMonthTotalSent = Nothing
  , getChildInfoStatisticsCurrentMonthTotalSent = Nothing
  , getChildInfoStatisticsTotalSent = Nothing
  }

-- ** GetChildrenList
-- | GetChildrenList
data GetChildrenList = GetChildrenList
  { getChildrenListChildren :: !(Maybe [A.Value]) -- ^ "children" - Your children&#39;s account information
  , getChildrenListCount :: !(Integer) -- ^ /Required/ "count" - Number of child accounts
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChildrenList
instance A.FromJSON GetChildrenList where
  parseJSON = A.withObject "GetChildrenList" $ \o ->
    GetChildrenList
      <$> (o .:? "children")
      <*> (o .:  "count")

-- | ToJSON GetChildrenList
instance A.ToJSON GetChildrenList where
  toJSON GetChildrenList {..} =
   _omitNulls
      [ "children" .= getChildrenListChildren
      , "count" .= getChildrenListCount
      ]


-- | Construct a value of type 'GetChildrenList' (by applying it's required fields, if any)
mkGetChildrenList
  :: Integer -- ^ 'getChildrenListCount': Number of child accounts
  -> GetChildrenList
mkGetChildrenList getChildrenListCount =
  GetChildrenList
  { getChildrenListChildren = Nothing
  , getChildrenListCount
  }

-- ** GetClient
-- | GetClient
data GetClient = GetClient
  { getClientEmail :: !(Text) -- ^ /Required/ "email" - Login Email
  , getClientFirstName :: !(Text) -- ^ /Required/ "firstName" - First Name
  , getClientLastName :: !(Text) -- ^ /Required/ "lastName" - Last Name
  , getClientCompanyName :: !(Text) -- ^ /Required/ "companyName" - Name of the company
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetClient
instance A.FromJSON GetClient where
  parseJSON = A.withObject "GetClient" $ \o ->
    GetClient
      <$> (o .:  "email")
      <*> (o .:  "firstName")
      <*> (o .:  "lastName")
      <*> (o .:  "companyName")

-- | ToJSON GetClient
instance A.ToJSON GetClient where
  toJSON GetClient {..} =
   _omitNulls
      [ "email" .= getClientEmail
      , "firstName" .= getClientFirstName
      , "lastName" .= getClientLastName
      , "companyName" .= getClientCompanyName
      ]


-- | Construct a value of type 'GetClient' (by applying it's required fields, if any)
mkGetClient
  :: Text -- ^ 'getClientEmail': Login Email
  -> Text -- ^ 'getClientFirstName': First Name
  -> Text -- ^ 'getClientLastName': Last Name
  -> Text -- ^ 'getClientCompanyName': Name of the company
  -> GetClient
mkGetClient getClientEmail getClientFirstName getClientLastName getClientCompanyName =
  GetClient
  { getClientEmail
  , getClientFirstName
  , getClientLastName
  , getClientCompanyName
  }

-- ** GetContactCampaignStats
-- | GetContactCampaignStats
-- Campaign Statistics for the contact
data GetContactCampaignStats = GetContactCampaignStats
  { getContactCampaignStatsMessagesSent :: !(Maybe [GetExtendedContactDetailsStatisticsMessagesSent]) -- ^ "messagesSent"
  , getContactCampaignStatsHardBounces :: !(Maybe [GetExtendedContactDetailsStatisticsMessagesSent]) -- ^ "hardBounces"
  , getContactCampaignStatsSoftBounces :: !(Maybe [GetExtendedContactDetailsStatisticsMessagesSent]) -- ^ "softBounces"
  , getContactCampaignStatsComplaints :: !(Maybe [GetExtendedContactDetailsStatisticsMessagesSent]) -- ^ "complaints"
  , getContactCampaignStatsUnsubscriptions :: !(Maybe GetContactCampaignStatsUnsubscriptions) -- ^ "unsubscriptions"
  , getContactCampaignStatsOpened :: !(Maybe [GetContactCampaignStatsOpened]) -- ^ "opened"
  , getContactCampaignStatsClicked :: !(Maybe [GetContactCampaignStatsClicked]) -- ^ "clicked"
  , getContactCampaignStatsTransacAttributes :: !(Maybe [GetContactCampaignStatsTransacAttributes]) -- ^ "transacAttributes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetContactCampaignStats
instance A.FromJSON GetContactCampaignStats where
  parseJSON = A.withObject "GetContactCampaignStats" $ \o ->
    GetContactCampaignStats
      <$> (o .:? "messagesSent")
      <*> (o .:? "hardBounces")
      <*> (o .:? "softBounces")
      <*> (o .:? "complaints")
      <*> (o .:? "unsubscriptions")
      <*> (o .:? "opened")
      <*> (o .:? "clicked")
      <*> (o .:? "transacAttributes")

-- | ToJSON GetContactCampaignStats
instance A.ToJSON GetContactCampaignStats where
  toJSON GetContactCampaignStats {..} =
   _omitNulls
      [ "messagesSent" .= getContactCampaignStatsMessagesSent
      , "hardBounces" .= getContactCampaignStatsHardBounces
      , "softBounces" .= getContactCampaignStatsSoftBounces
      , "complaints" .= getContactCampaignStatsComplaints
      , "unsubscriptions" .= getContactCampaignStatsUnsubscriptions
      , "opened" .= getContactCampaignStatsOpened
      , "clicked" .= getContactCampaignStatsClicked
      , "transacAttributes" .= getContactCampaignStatsTransacAttributes
      ]


-- | Construct a value of type 'GetContactCampaignStats' (by applying it's required fields, if any)
mkGetContactCampaignStats
  :: GetContactCampaignStats
mkGetContactCampaignStats =
  GetContactCampaignStats
  { getContactCampaignStatsMessagesSent = Nothing
  , getContactCampaignStatsHardBounces = Nothing
  , getContactCampaignStatsSoftBounces = Nothing
  , getContactCampaignStatsComplaints = Nothing
  , getContactCampaignStatsUnsubscriptions = Nothing
  , getContactCampaignStatsOpened = Nothing
  , getContactCampaignStatsClicked = Nothing
  , getContactCampaignStatsTransacAttributes = Nothing
  }

-- ** GetContactCampaignStatsClicked
-- | GetContactCampaignStatsClicked
data GetContactCampaignStatsClicked = GetContactCampaignStatsClicked
  { getContactCampaignStatsClickedCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - ID of the campaign which generated the event
  , getContactCampaignStatsClickedLinks :: !([GetExtendedContactDetailsStatisticsLinks]) -- ^ /Required/ "links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetContactCampaignStatsClicked
instance A.FromJSON GetContactCampaignStatsClicked where
  parseJSON = A.withObject "GetContactCampaignStatsClicked" $ \o ->
    GetContactCampaignStatsClicked
      <$> (o .:  "campaignId")
      <*> (o .:  "links")

-- | ToJSON GetContactCampaignStatsClicked
instance A.ToJSON GetContactCampaignStatsClicked where
  toJSON GetContactCampaignStatsClicked {..} =
   _omitNulls
      [ "campaignId" .= getContactCampaignStatsClickedCampaignId
      , "links" .= getContactCampaignStatsClickedLinks
      ]


-- | Construct a value of type 'GetContactCampaignStatsClicked' (by applying it's required fields, if any)
mkGetContactCampaignStatsClicked
  :: Integer -- ^ 'getContactCampaignStatsClickedCampaignId': ID of the campaign which generated the event
  -> [GetExtendedContactDetailsStatisticsLinks] -- ^ 'getContactCampaignStatsClickedLinks' 
  -> GetContactCampaignStatsClicked
mkGetContactCampaignStatsClicked getContactCampaignStatsClickedCampaignId getContactCampaignStatsClickedLinks =
  GetContactCampaignStatsClicked
  { getContactCampaignStatsClickedCampaignId
  , getContactCampaignStatsClickedLinks
  }

-- ** GetContactCampaignStatsOpened
-- | GetContactCampaignStatsOpened
data GetContactCampaignStatsOpened = GetContactCampaignStatsOpened
  { getContactCampaignStatsOpenedCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - ID of the campaign which generated the event
  , getContactCampaignStatsOpenedCount :: !(Integer) -- ^ /Required/ "count" - Number of openings of the campaign
  , getContactCampaignStatsOpenedEventTime :: !(DateTime) -- ^ /Required/ "eventTime" - UTC date-time of the event
  , getContactCampaignStatsOpenedIp :: !(Text) -- ^ /Required/ "ip" - IP from which the user has opened the campaign
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetContactCampaignStatsOpened
instance A.FromJSON GetContactCampaignStatsOpened where
  parseJSON = A.withObject "GetContactCampaignStatsOpened" $ \o ->
    GetContactCampaignStatsOpened
      <$> (o .:  "campaignId")
      <*> (o .:  "count")
      <*> (o .:  "eventTime")
      <*> (o .:  "ip")

-- | ToJSON GetContactCampaignStatsOpened
instance A.ToJSON GetContactCampaignStatsOpened where
  toJSON GetContactCampaignStatsOpened {..} =
   _omitNulls
      [ "campaignId" .= getContactCampaignStatsOpenedCampaignId
      , "count" .= getContactCampaignStatsOpenedCount
      , "eventTime" .= getContactCampaignStatsOpenedEventTime
      , "ip" .= getContactCampaignStatsOpenedIp
      ]


-- | Construct a value of type 'GetContactCampaignStatsOpened' (by applying it's required fields, if any)
mkGetContactCampaignStatsOpened
  :: Integer -- ^ 'getContactCampaignStatsOpenedCampaignId': ID of the campaign which generated the event
  -> Integer -- ^ 'getContactCampaignStatsOpenedCount': Number of openings of the campaign
  -> DateTime -- ^ 'getContactCampaignStatsOpenedEventTime': UTC date-time of the event
  -> Text -- ^ 'getContactCampaignStatsOpenedIp': IP from which the user has opened the campaign
  -> GetContactCampaignStatsOpened
mkGetContactCampaignStatsOpened getContactCampaignStatsOpenedCampaignId getContactCampaignStatsOpenedCount getContactCampaignStatsOpenedEventTime getContactCampaignStatsOpenedIp =
  GetContactCampaignStatsOpened
  { getContactCampaignStatsOpenedCampaignId
  , getContactCampaignStatsOpenedCount
  , getContactCampaignStatsOpenedEventTime
  , getContactCampaignStatsOpenedIp
  }

-- ** GetContactCampaignStatsTransacAttributes
-- | GetContactCampaignStatsTransacAttributes
data GetContactCampaignStatsTransacAttributes = GetContactCampaignStatsTransacAttributes
  { getContactCampaignStatsTransacAttributesOrderDate :: !(Date) -- ^ /Required/ "orderDate" - Date of the order
  , getContactCampaignStatsTransacAttributesOrderPrice :: !(Float) -- ^ /Required/ "orderPrice" - Price of the order
  , getContactCampaignStatsTransacAttributesOrderId :: !(Integer) -- ^ /Required/ "orderId" - ID of the order
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetContactCampaignStatsTransacAttributes
instance A.FromJSON GetContactCampaignStatsTransacAttributes where
  parseJSON = A.withObject "GetContactCampaignStatsTransacAttributes" $ \o ->
    GetContactCampaignStatsTransacAttributes
      <$> (o .:  "orderDate")
      <*> (o .:  "orderPrice")
      <*> (o .:  "orderId")

-- | ToJSON GetContactCampaignStatsTransacAttributes
instance A.ToJSON GetContactCampaignStatsTransacAttributes where
  toJSON GetContactCampaignStatsTransacAttributes {..} =
   _omitNulls
      [ "orderDate" .= getContactCampaignStatsTransacAttributesOrderDate
      , "orderPrice" .= getContactCampaignStatsTransacAttributesOrderPrice
      , "orderId" .= getContactCampaignStatsTransacAttributesOrderId
      ]


-- | Construct a value of type 'GetContactCampaignStatsTransacAttributes' (by applying it's required fields, if any)
mkGetContactCampaignStatsTransacAttributes
  :: Date -- ^ 'getContactCampaignStatsTransacAttributesOrderDate': Date of the order
  -> Float -- ^ 'getContactCampaignStatsTransacAttributesOrderPrice': Price of the order
  -> Integer -- ^ 'getContactCampaignStatsTransacAttributesOrderId': ID of the order
  -> GetContactCampaignStatsTransacAttributes
mkGetContactCampaignStatsTransacAttributes getContactCampaignStatsTransacAttributesOrderDate getContactCampaignStatsTransacAttributesOrderPrice getContactCampaignStatsTransacAttributesOrderId =
  GetContactCampaignStatsTransacAttributes
  { getContactCampaignStatsTransacAttributesOrderDate
  , getContactCampaignStatsTransacAttributesOrderPrice
  , getContactCampaignStatsTransacAttributesOrderId
  }

-- ** GetContactCampaignStatsUnsubscriptions
-- | GetContactCampaignStatsUnsubscriptions
data GetContactCampaignStatsUnsubscriptions = GetContactCampaignStatsUnsubscriptions
  { getContactCampaignStatsUnsubscriptionsUserUnsubscription :: !([GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription]) -- ^ /Required/ "userUnsubscription" - Contact has unsubscribed via the unsubscription link in the email
  , getContactCampaignStatsUnsubscriptionsAdminUnsubscription :: !([GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription]) -- ^ /Required/ "adminUnsubscription" - Contact has been unsubscribed from the administrator
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetContactCampaignStatsUnsubscriptions
instance A.FromJSON GetContactCampaignStatsUnsubscriptions where
  parseJSON = A.withObject "GetContactCampaignStatsUnsubscriptions" $ \o ->
    GetContactCampaignStatsUnsubscriptions
      <$> (o .:  "userUnsubscription")
      <*> (o .:  "adminUnsubscription")

-- | ToJSON GetContactCampaignStatsUnsubscriptions
instance A.ToJSON GetContactCampaignStatsUnsubscriptions where
  toJSON GetContactCampaignStatsUnsubscriptions {..} =
   _omitNulls
      [ "userUnsubscription" .= getContactCampaignStatsUnsubscriptionsUserUnsubscription
      , "adminUnsubscription" .= getContactCampaignStatsUnsubscriptionsAdminUnsubscription
      ]


-- | Construct a value of type 'GetContactCampaignStatsUnsubscriptions' (by applying it's required fields, if any)
mkGetContactCampaignStatsUnsubscriptions
  :: [GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription] -- ^ 'getContactCampaignStatsUnsubscriptionsUserUnsubscription': Contact has unsubscribed via the unsubscription link in the email
  -> [GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription] -- ^ 'getContactCampaignStatsUnsubscriptionsAdminUnsubscription': Contact has been unsubscribed from the administrator
  -> GetContactCampaignStatsUnsubscriptions
mkGetContactCampaignStatsUnsubscriptions getContactCampaignStatsUnsubscriptionsUserUnsubscription getContactCampaignStatsUnsubscriptionsAdminUnsubscription =
  GetContactCampaignStatsUnsubscriptions
  { getContactCampaignStatsUnsubscriptionsUserUnsubscription
  , getContactCampaignStatsUnsubscriptionsAdminUnsubscription
  }

-- ** GetContactDetails
-- | GetContactDetails
data GetContactDetails = GetContactDetails
  { getContactDetailsEmail :: !(Text) -- ^ /Required/ "email" - Email address of the contact for which you requested the details
  , getContactDetailsId :: !(Integer) -- ^ /Required/ "id" - ID of the contact for which you requested the details
  , getContactDetailsEmailBlacklisted :: !(Bool) -- ^ /Required/ "emailBlacklisted" - Blacklist status for email campaigns (true&#x3D;blacklisted, false&#x3D;not blacklisted)
  , getContactDetailsSmsBlacklisted :: !(Bool) -- ^ /Required/ "smsBlacklisted" - Blacklist status for SMS campaigns (true&#x3D;blacklisted, false&#x3D;not blacklisted)
  , getContactDetailsCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Creation UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getContactDetailsModifiedAt :: !(DateTime) -- ^ /Required/ "modifiedAt" - Last modification UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getContactDetailsListIds :: !([Integer]) -- ^ /Required/ "listIds"
  , getContactDetailsListUnsubscribed :: !(Maybe [Integer]) -- ^ "listUnsubscribed"
  , getContactDetailsAttributes :: !(A.Value) -- ^ /Required/ "attributes" - Set of attributes of the contact
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetContactDetails
instance A.FromJSON GetContactDetails where
  parseJSON = A.withObject "GetContactDetails" $ \o ->
    GetContactDetails
      <$> (o .:  "email")
      <*> (o .:  "id")
      <*> (o .:  "emailBlacklisted")
      <*> (o .:  "smsBlacklisted")
      <*> (o .:  "createdAt")
      <*> (o .:  "modifiedAt")
      <*> (o .:  "listIds")
      <*> (o .:? "listUnsubscribed")
      <*> (o .:  "attributes")

-- | ToJSON GetContactDetails
instance A.ToJSON GetContactDetails where
  toJSON GetContactDetails {..} =
   _omitNulls
      [ "email" .= getContactDetailsEmail
      , "id" .= getContactDetailsId
      , "emailBlacklisted" .= getContactDetailsEmailBlacklisted
      , "smsBlacklisted" .= getContactDetailsSmsBlacklisted
      , "createdAt" .= getContactDetailsCreatedAt
      , "modifiedAt" .= getContactDetailsModifiedAt
      , "listIds" .= getContactDetailsListIds
      , "listUnsubscribed" .= getContactDetailsListUnsubscribed
      , "attributes" .= getContactDetailsAttributes
      ]


-- | Construct a value of type 'GetContactDetails' (by applying it's required fields, if any)
mkGetContactDetails
  :: Text -- ^ 'getContactDetailsEmail': Email address of the contact for which you requested the details
  -> Integer -- ^ 'getContactDetailsId': ID of the contact for which you requested the details
  -> Bool -- ^ 'getContactDetailsEmailBlacklisted': Blacklist status for email campaigns (true=blacklisted, false=not blacklisted)
  -> Bool -- ^ 'getContactDetailsSmsBlacklisted': Blacklist status for SMS campaigns (true=blacklisted, false=not blacklisted)
  -> DateTime -- ^ 'getContactDetailsCreatedAt': Creation UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> DateTime -- ^ 'getContactDetailsModifiedAt': Last modification UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> [Integer] -- ^ 'getContactDetailsListIds' 
  -> A.Value -- ^ 'getContactDetailsAttributes': Set of attributes of the contact
  -> GetContactDetails
mkGetContactDetails getContactDetailsEmail getContactDetailsId getContactDetailsEmailBlacklisted getContactDetailsSmsBlacklisted getContactDetailsCreatedAt getContactDetailsModifiedAt getContactDetailsListIds getContactDetailsAttributes =
  GetContactDetails
  { getContactDetailsEmail
  , getContactDetailsId
  , getContactDetailsEmailBlacklisted
  , getContactDetailsSmsBlacklisted
  , getContactDetailsCreatedAt
  , getContactDetailsModifiedAt
  , getContactDetailsListIds
  , getContactDetailsListUnsubscribed = Nothing
  , getContactDetailsAttributes
  }

-- ** GetContacts
-- | GetContacts
data GetContacts = GetContacts
  { getContactsContacts :: !([A.Value]) -- ^ /Required/ "contacts"
  , getContactsCount :: !(Integer) -- ^ /Required/ "count" - Number of contacts
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetContacts
instance A.FromJSON GetContacts where
  parseJSON = A.withObject "GetContacts" $ \o ->
    GetContacts
      <$> (o .:  "contacts")
      <*> (o .:  "count")

-- | ToJSON GetContacts
instance A.ToJSON GetContacts where
  toJSON GetContacts {..} =
   _omitNulls
      [ "contacts" .= getContactsContacts
      , "count" .= getContactsCount
      ]


-- | Construct a value of type 'GetContacts' (by applying it's required fields, if any)
mkGetContacts
  :: [A.Value] -- ^ 'getContactsContacts' 
  -> Integer -- ^ 'getContactsCount': Number of contacts
  -> GetContacts
mkGetContacts getContactsContacts getContactsCount =
  GetContacts
  { getContactsContacts
  , getContactsCount
  }

-- ** GetDeviceBrowserStats
-- | GetDeviceBrowserStats
data GetDeviceBrowserStats = GetDeviceBrowserStats
  { getDeviceBrowserStatsClickers :: !(Integer) -- ^ /Required/ "clickers" - Number of total clicks for the campaign using the particular browser
  , getDeviceBrowserStatsUniqueClicks :: !(Integer) -- ^ /Required/ "uniqueClicks" - Number of unique clicks for the campaign using the particular browser
  , getDeviceBrowserStatsViewed :: !(Integer) -- ^ /Required/ "viewed" - Number of openings for the campaign using the particular browser
  , getDeviceBrowserStatsUniqueViews :: !(Integer) -- ^ /Required/ "uniqueViews" - Number of unique openings for the campaign using the particular browser
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetDeviceBrowserStats
instance A.FromJSON GetDeviceBrowserStats where
  parseJSON = A.withObject "GetDeviceBrowserStats" $ \o ->
    GetDeviceBrowserStats
      <$> (o .:  "clickers")
      <*> (o .:  "uniqueClicks")
      <*> (o .:  "viewed")
      <*> (o .:  "uniqueViews")

-- | ToJSON GetDeviceBrowserStats
instance A.ToJSON GetDeviceBrowserStats where
  toJSON GetDeviceBrowserStats {..} =
   _omitNulls
      [ "clickers" .= getDeviceBrowserStatsClickers
      , "uniqueClicks" .= getDeviceBrowserStatsUniqueClicks
      , "viewed" .= getDeviceBrowserStatsViewed
      , "uniqueViews" .= getDeviceBrowserStatsUniqueViews
      ]


-- | Construct a value of type 'GetDeviceBrowserStats' (by applying it's required fields, if any)
mkGetDeviceBrowserStats
  :: Integer -- ^ 'getDeviceBrowserStatsClickers': Number of total clicks for the campaign using the particular browser
  -> Integer -- ^ 'getDeviceBrowserStatsUniqueClicks': Number of unique clicks for the campaign using the particular browser
  -> Integer -- ^ 'getDeviceBrowserStatsViewed': Number of openings for the campaign using the particular browser
  -> Integer -- ^ 'getDeviceBrowserStatsUniqueViews': Number of unique openings for the campaign using the particular browser
  -> GetDeviceBrowserStats
mkGetDeviceBrowserStats getDeviceBrowserStatsClickers getDeviceBrowserStatsUniqueClicks getDeviceBrowserStatsViewed getDeviceBrowserStatsUniqueViews =
  GetDeviceBrowserStats
  { getDeviceBrowserStatsClickers
  , getDeviceBrowserStatsUniqueClicks
  , getDeviceBrowserStatsViewed
  , getDeviceBrowserStatsUniqueViews
  }

-- ** GetEmailCampaigns
-- | GetEmailCampaigns
data GetEmailCampaigns = GetEmailCampaigns
  { getEmailCampaignsCampaigns :: !(Maybe [A.Value]) -- ^ "campaigns"
  , getEmailCampaignsCount :: !(Integer) -- ^ /Required/ "count" - Number of Email campaigns retrieved
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetEmailCampaigns
instance A.FromJSON GetEmailCampaigns where
  parseJSON = A.withObject "GetEmailCampaigns" $ \o ->
    GetEmailCampaigns
      <$> (o .:? "campaigns")
      <*> (o .:  "count")

-- | ToJSON GetEmailCampaigns
instance A.ToJSON GetEmailCampaigns where
  toJSON GetEmailCampaigns {..} =
   _omitNulls
      [ "campaigns" .= getEmailCampaignsCampaigns
      , "count" .= getEmailCampaignsCount
      ]


-- | Construct a value of type 'GetEmailCampaigns' (by applying it's required fields, if any)
mkGetEmailCampaigns
  :: Integer -- ^ 'getEmailCampaignsCount': Number of Email campaigns retrieved
  -> GetEmailCampaigns
mkGetEmailCampaigns getEmailCampaignsCount =
  GetEmailCampaigns
  { getEmailCampaignsCampaigns = Nothing
  , getEmailCampaignsCount
  }

-- ** GetEmailEventReport
-- | GetEmailEventReport
data GetEmailEventReport = GetEmailEventReport
  { getEmailEventReportEvents :: !(Maybe [GetEmailEventReportEvents]) -- ^ "events"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetEmailEventReport
instance A.FromJSON GetEmailEventReport where
  parseJSON = A.withObject "GetEmailEventReport" $ \o ->
    GetEmailEventReport
      <$> (o .:? "events")

-- | ToJSON GetEmailEventReport
instance A.ToJSON GetEmailEventReport where
  toJSON GetEmailEventReport {..} =
   _omitNulls
      [ "events" .= getEmailEventReportEvents
      ]


-- | Construct a value of type 'GetEmailEventReport' (by applying it's required fields, if any)
mkGetEmailEventReport
  :: GetEmailEventReport
mkGetEmailEventReport =
  GetEmailEventReport
  { getEmailEventReportEvents = Nothing
  }

-- ** GetEmailEventReportEvents
-- | GetEmailEventReportEvents
data GetEmailEventReportEvents = GetEmailEventReportEvents
  { getEmailEventReportEventsEmail :: !(Text) -- ^ /Required/ "email" - Email address which generates the event
  , getEmailEventReportEventsDate :: !(DateTime) -- ^ /Required/ "date" - UTC date-time on which the event has been generated
  , getEmailEventReportEventsSubject :: !(Maybe Text) -- ^ "subject" - Subject of the event
  , getEmailEventReportEventsMessageId :: !(Text) -- ^ /Required/ "messageId" - Message ID which generated the event
  , getEmailEventReportEventsEvent :: !(E'Event) -- ^ /Required/ "event" - Event which occurred
  , getEmailEventReportEventsReason :: !(Maybe Text) -- ^ "reason" - Reason of bounce (only available if the event is hardbounce or softbounce)
  , getEmailEventReportEventsTag :: !(Maybe Text) -- ^ "tag" - Tag of the email which generated the event
  , getEmailEventReportEventsIp :: !(Maybe Text) -- ^ "ip" - IP from which the user has opened the email or clicked on the link (only available if the event is opened or clicks)
  , getEmailEventReportEventsLink :: !(Maybe Text) -- ^ "link" - The link which is sent to the user (only available if the event is requests or opened or clicks)
  , getEmailEventReportEventsFrom :: !(Maybe Text) -- ^ "from" - Sender email from which the emails are sent
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetEmailEventReportEvents
instance A.FromJSON GetEmailEventReportEvents where
  parseJSON = A.withObject "GetEmailEventReportEvents" $ \o ->
    GetEmailEventReportEvents
      <$> (o .:  "email")
      <*> (o .:  "date")
      <*> (o .:? "subject")
      <*> (o .:  "messageId")
      <*> (o .:  "event")
      <*> (o .:? "reason")
      <*> (o .:? "tag")
      <*> (o .:? "ip")
      <*> (o .:? "link")
      <*> (o .:? "from")

-- | ToJSON GetEmailEventReportEvents
instance A.ToJSON GetEmailEventReportEvents where
  toJSON GetEmailEventReportEvents {..} =
   _omitNulls
      [ "email" .= getEmailEventReportEventsEmail
      , "date" .= getEmailEventReportEventsDate
      , "subject" .= getEmailEventReportEventsSubject
      , "messageId" .= getEmailEventReportEventsMessageId
      , "event" .= getEmailEventReportEventsEvent
      , "reason" .= getEmailEventReportEventsReason
      , "tag" .= getEmailEventReportEventsTag
      , "ip" .= getEmailEventReportEventsIp
      , "link" .= getEmailEventReportEventsLink
      , "from" .= getEmailEventReportEventsFrom
      ]


-- | Construct a value of type 'GetEmailEventReportEvents' (by applying it's required fields, if any)
mkGetEmailEventReportEvents
  :: Text -- ^ 'getEmailEventReportEventsEmail': Email address which generates the event
  -> DateTime -- ^ 'getEmailEventReportEventsDate': UTC date-time on which the event has been generated
  -> Text -- ^ 'getEmailEventReportEventsMessageId': Message ID which generated the event
  -> E'Event -- ^ 'getEmailEventReportEventsEvent': Event which occurred
  -> GetEmailEventReportEvents
mkGetEmailEventReportEvents getEmailEventReportEventsEmail getEmailEventReportEventsDate getEmailEventReportEventsMessageId getEmailEventReportEventsEvent =
  GetEmailEventReportEvents
  { getEmailEventReportEventsEmail
  , getEmailEventReportEventsDate
  , getEmailEventReportEventsSubject = Nothing
  , getEmailEventReportEventsMessageId
  , getEmailEventReportEventsEvent
  , getEmailEventReportEventsReason = Nothing
  , getEmailEventReportEventsTag = Nothing
  , getEmailEventReportEventsIp = Nothing
  , getEmailEventReportEventsLink = Nothing
  , getEmailEventReportEventsFrom = Nothing
  }

-- ** GetExtendedCampaignOverviewSender
-- | GetExtendedCampaignOverviewSender
data GetExtendedCampaignOverviewSender = GetExtendedCampaignOverviewSender
  { getExtendedCampaignOverviewSenderName :: !(Maybe Text) -- ^ "name" - Sender name of the campaign
  , getExtendedCampaignOverviewSenderEmail :: !(Maybe Text) -- ^ "email" - Sender email of the campaign
  , getExtendedCampaignOverviewSenderId :: !(Maybe Text) -- ^ "id" - Sender id of the campaign
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedCampaignOverviewSender
instance A.FromJSON GetExtendedCampaignOverviewSender where
  parseJSON = A.withObject "GetExtendedCampaignOverviewSender" $ \o ->
    GetExtendedCampaignOverviewSender
      <$> (o .:? "name")
      <*> (o .:? "email")
      <*> (o .:? "id")

-- | ToJSON GetExtendedCampaignOverviewSender
instance A.ToJSON GetExtendedCampaignOverviewSender where
  toJSON GetExtendedCampaignOverviewSender {..} =
   _omitNulls
      [ "name" .= getExtendedCampaignOverviewSenderName
      , "email" .= getExtendedCampaignOverviewSenderEmail
      , "id" .= getExtendedCampaignOverviewSenderId
      ]


-- | Construct a value of type 'GetExtendedCampaignOverviewSender' (by applying it's required fields, if any)
mkGetExtendedCampaignOverviewSender
  :: GetExtendedCampaignOverviewSender
mkGetExtendedCampaignOverviewSender =
  GetExtendedCampaignOverviewSender
  { getExtendedCampaignOverviewSenderName = Nothing
  , getExtendedCampaignOverviewSenderEmail = Nothing
  , getExtendedCampaignOverviewSenderId = Nothing
  }

-- ** GetExtendedCampaignStats
-- | GetExtendedCampaignStats
data GetExtendedCampaignStats = GetExtendedCampaignStats
  { getExtendedCampaignStatsGlobalStats :: !(A.Value) -- ^ /Required/ "globalStats" - Overall statistics of the campaign
  , getExtendedCampaignStatsCampaignStats :: !([A.Value]) -- ^ /Required/ "campaignStats" - List-wise statistics of the campaign.
  , getExtendedCampaignStatsMirrorClick :: !(Integer) -- ^ /Required/ "mirrorClick" - Number of clicks on mirror link
  , getExtendedCampaignStatsRemaining :: !(Integer) -- ^ /Required/ "remaining" - Number of remaning emails to send
  , getExtendedCampaignStatsLinksStats :: !(A.Value) -- ^ /Required/ "linksStats" - Statistics about the number of clicks for the links
  , getExtendedCampaignStatsStatsByDomain :: !(GetStatsByDomain) -- ^ /Required/ "statsByDomain"
  , getExtendedCampaignStatsStatsByDevice :: !(GetStatsByDevice) -- ^ /Required/ "statsByDevice" - Statistics about the campaign on the basis of various devices
  , getExtendedCampaignStatsStatsByBrowser :: !(GetStatsByBrowser) -- ^ /Required/ "statsByBrowser" - Statistics about the campaign on the basis of various browsers
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedCampaignStats
instance A.FromJSON GetExtendedCampaignStats where
  parseJSON = A.withObject "GetExtendedCampaignStats" $ \o ->
    GetExtendedCampaignStats
      <$> (o .:  "globalStats")
      <*> (o .:  "campaignStats")
      <*> (o .:  "mirrorClick")
      <*> (o .:  "remaining")
      <*> (o .:  "linksStats")
      <*> (o .:  "statsByDomain")
      <*> (o .:  "statsByDevice")
      <*> (o .:  "statsByBrowser")

-- | ToJSON GetExtendedCampaignStats
instance A.ToJSON GetExtendedCampaignStats where
  toJSON GetExtendedCampaignStats {..} =
   _omitNulls
      [ "globalStats" .= getExtendedCampaignStatsGlobalStats
      , "campaignStats" .= getExtendedCampaignStatsCampaignStats
      , "mirrorClick" .= getExtendedCampaignStatsMirrorClick
      , "remaining" .= getExtendedCampaignStatsRemaining
      , "linksStats" .= getExtendedCampaignStatsLinksStats
      , "statsByDomain" .= getExtendedCampaignStatsStatsByDomain
      , "statsByDevice" .= getExtendedCampaignStatsStatsByDevice
      , "statsByBrowser" .= getExtendedCampaignStatsStatsByBrowser
      ]


-- | Construct a value of type 'GetExtendedCampaignStats' (by applying it's required fields, if any)
mkGetExtendedCampaignStats
  :: A.Value -- ^ 'getExtendedCampaignStatsGlobalStats': Overall statistics of the campaign
  -> [A.Value] -- ^ 'getExtendedCampaignStatsCampaignStats': List-wise statistics of the campaign.
  -> Integer -- ^ 'getExtendedCampaignStatsMirrorClick': Number of clicks on mirror link
  -> Integer -- ^ 'getExtendedCampaignStatsRemaining': Number of remaning emails to send
  -> A.Value -- ^ 'getExtendedCampaignStatsLinksStats': Statistics about the number of clicks for the links
  -> GetStatsByDomain -- ^ 'getExtendedCampaignStatsStatsByDomain' 
  -> GetStatsByDevice -- ^ 'getExtendedCampaignStatsStatsByDevice': Statistics about the campaign on the basis of various devices
  -> GetStatsByBrowser -- ^ 'getExtendedCampaignStatsStatsByBrowser': Statistics about the campaign on the basis of various browsers
  -> GetExtendedCampaignStats
mkGetExtendedCampaignStats getExtendedCampaignStatsGlobalStats getExtendedCampaignStatsCampaignStats getExtendedCampaignStatsMirrorClick getExtendedCampaignStatsRemaining getExtendedCampaignStatsLinksStats getExtendedCampaignStatsStatsByDomain getExtendedCampaignStatsStatsByDevice getExtendedCampaignStatsStatsByBrowser =
  GetExtendedCampaignStats
  { getExtendedCampaignStatsGlobalStats
  , getExtendedCampaignStatsCampaignStats
  , getExtendedCampaignStatsMirrorClick
  , getExtendedCampaignStatsRemaining
  , getExtendedCampaignStatsLinksStats
  , getExtendedCampaignStatsStatsByDomain
  , getExtendedCampaignStatsStatsByDevice
  , getExtendedCampaignStatsStatsByBrowser
  }

-- ** GetExtendedClientAddress
-- | GetExtendedClientAddress
-- Address informations
data GetExtendedClientAddress = GetExtendedClientAddress
  { getExtendedClientAddressStreet :: !(Text) -- ^ /Required/ "street" - Street information
  , getExtendedClientAddressCity :: !(Text) -- ^ /Required/ "city" - City information
  , getExtendedClientAddressZipCode :: !(Text) -- ^ /Required/ "zipCode" - Zip Code information
  , getExtendedClientAddressCountry :: !(Text) -- ^ /Required/ "country" - Country information
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedClientAddress
instance A.FromJSON GetExtendedClientAddress where
  parseJSON = A.withObject "GetExtendedClientAddress" $ \o ->
    GetExtendedClientAddress
      <$> (o .:  "street")
      <*> (o .:  "city")
      <*> (o .:  "zipCode")
      <*> (o .:  "country")

-- | ToJSON GetExtendedClientAddress
instance A.ToJSON GetExtendedClientAddress where
  toJSON GetExtendedClientAddress {..} =
   _omitNulls
      [ "street" .= getExtendedClientAddressStreet
      , "city" .= getExtendedClientAddressCity
      , "zipCode" .= getExtendedClientAddressZipCode
      , "country" .= getExtendedClientAddressCountry
      ]


-- | Construct a value of type 'GetExtendedClientAddress' (by applying it's required fields, if any)
mkGetExtendedClientAddress
  :: Text -- ^ 'getExtendedClientAddressStreet': Street information
  -> Text -- ^ 'getExtendedClientAddressCity': City information
  -> Text -- ^ 'getExtendedClientAddressZipCode': Zip Code information
  -> Text -- ^ 'getExtendedClientAddressCountry': Country information
  -> GetExtendedClientAddress
mkGetExtendedClientAddress getExtendedClientAddressStreet getExtendedClientAddressCity getExtendedClientAddressZipCode getExtendedClientAddressCountry =
  GetExtendedClientAddress
  { getExtendedClientAddressStreet
  , getExtendedClientAddressCity
  , getExtendedClientAddressZipCode
  , getExtendedClientAddressCountry
  }

-- ** GetExtendedContactDetailsStatistics
-- | GetExtendedContactDetailsStatistics
-- Campaign statistics of the contact
data GetExtendedContactDetailsStatistics = GetExtendedContactDetailsStatistics
  { getExtendedContactDetailsStatisticsMessagesSent :: !(Maybe [GetExtendedContactDetailsStatisticsMessagesSent]) -- ^ "messagesSent" - Listing of the sent campaign for the contact
  , getExtendedContactDetailsStatisticsHardBounces :: !(Maybe [GetExtendedContactDetailsStatisticsMessagesSent]) -- ^ "hardBounces" - Listing of the hardbounes generated by the contact
  , getExtendedContactDetailsStatisticsSoftBounces :: !(Maybe [GetExtendedContactDetailsStatisticsMessagesSent]) -- ^ "softBounces" - Listing of the softbounes generated by the contact
  , getExtendedContactDetailsStatisticsComplaints :: !(Maybe [GetExtendedContactDetailsStatisticsMessagesSent]) -- ^ "complaints" - Listing of the complaints generated by the contact
  , getExtendedContactDetailsStatisticsUnsubscriptions :: !(Maybe GetExtendedContactDetailsStatisticsUnsubscriptions) -- ^ "unsubscriptions"
  , getExtendedContactDetailsStatisticsOpened :: !(Maybe [GetExtendedContactDetailsStatisticsOpened]) -- ^ "opened" - Listing of the openings generated by the contact
  , getExtendedContactDetailsStatisticsClicked :: !(Maybe [GetExtendedContactDetailsStatisticsClicked]) -- ^ "clicked" - Listing of the clicks generated by the contact
  , getExtendedContactDetailsStatisticsTransacAttributes :: !(Maybe [A.Value]) -- ^ "transacAttributes" - Listing of the transactional attributes for the contact
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedContactDetailsStatistics
instance A.FromJSON GetExtendedContactDetailsStatistics where
  parseJSON = A.withObject "GetExtendedContactDetailsStatistics" $ \o ->
    GetExtendedContactDetailsStatistics
      <$> (o .:? "messagesSent")
      <*> (o .:? "hardBounces")
      <*> (o .:? "softBounces")
      <*> (o .:? "complaints")
      <*> (o .:? "unsubscriptions")
      <*> (o .:? "opened")
      <*> (o .:? "clicked")
      <*> (o .:? "transacAttributes")

-- | ToJSON GetExtendedContactDetailsStatistics
instance A.ToJSON GetExtendedContactDetailsStatistics where
  toJSON GetExtendedContactDetailsStatistics {..} =
   _omitNulls
      [ "messagesSent" .= getExtendedContactDetailsStatisticsMessagesSent
      , "hardBounces" .= getExtendedContactDetailsStatisticsHardBounces
      , "softBounces" .= getExtendedContactDetailsStatisticsSoftBounces
      , "complaints" .= getExtendedContactDetailsStatisticsComplaints
      , "unsubscriptions" .= getExtendedContactDetailsStatisticsUnsubscriptions
      , "opened" .= getExtendedContactDetailsStatisticsOpened
      , "clicked" .= getExtendedContactDetailsStatisticsClicked
      , "transacAttributes" .= getExtendedContactDetailsStatisticsTransacAttributes
      ]


-- | Construct a value of type 'GetExtendedContactDetailsStatistics' (by applying it's required fields, if any)
mkGetExtendedContactDetailsStatistics
  :: GetExtendedContactDetailsStatistics
mkGetExtendedContactDetailsStatistics =
  GetExtendedContactDetailsStatistics
  { getExtendedContactDetailsStatisticsMessagesSent = Nothing
  , getExtendedContactDetailsStatisticsHardBounces = Nothing
  , getExtendedContactDetailsStatisticsSoftBounces = Nothing
  , getExtendedContactDetailsStatisticsComplaints = Nothing
  , getExtendedContactDetailsStatisticsUnsubscriptions = Nothing
  , getExtendedContactDetailsStatisticsOpened = Nothing
  , getExtendedContactDetailsStatisticsClicked = Nothing
  , getExtendedContactDetailsStatisticsTransacAttributes = Nothing
  }

-- ** GetExtendedContactDetailsStatisticsClicked
-- | GetExtendedContactDetailsStatisticsClicked
data GetExtendedContactDetailsStatisticsClicked = GetExtendedContactDetailsStatisticsClicked
  { getExtendedContactDetailsStatisticsClickedCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - ID of the campaign which generated the event
  , getExtendedContactDetailsStatisticsClickedLinks :: !([GetExtendedContactDetailsStatisticsLinks]) -- ^ /Required/ "links" - Listing of the clicked links for the campaign
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedContactDetailsStatisticsClicked
instance A.FromJSON GetExtendedContactDetailsStatisticsClicked where
  parseJSON = A.withObject "GetExtendedContactDetailsStatisticsClicked" $ \o ->
    GetExtendedContactDetailsStatisticsClicked
      <$> (o .:  "campaignId")
      <*> (o .:  "links")

-- | ToJSON GetExtendedContactDetailsStatisticsClicked
instance A.ToJSON GetExtendedContactDetailsStatisticsClicked where
  toJSON GetExtendedContactDetailsStatisticsClicked {..} =
   _omitNulls
      [ "campaignId" .= getExtendedContactDetailsStatisticsClickedCampaignId
      , "links" .= getExtendedContactDetailsStatisticsClickedLinks
      ]


-- | Construct a value of type 'GetExtendedContactDetailsStatisticsClicked' (by applying it's required fields, if any)
mkGetExtendedContactDetailsStatisticsClicked
  :: Integer -- ^ 'getExtendedContactDetailsStatisticsClickedCampaignId': ID of the campaign which generated the event
  -> [GetExtendedContactDetailsStatisticsLinks] -- ^ 'getExtendedContactDetailsStatisticsClickedLinks': Listing of the clicked links for the campaign
  -> GetExtendedContactDetailsStatisticsClicked
mkGetExtendedContactDetailsStatisticsClicked getExtendedContactDetailsStatisticsClickedCampaignId getExtendedContactDetailsStatisticsClickedLinks =
  GetExtendedContactDetailsStatisticsClicked
  { getExtendedContactDetailsStatisticsClickedCampaignId
  , getExtendedContactDetailsStatisticsClickedLinks
  }

-- ** GetExtendedContactDetailsStatisticsLinks
-- | GetExtendedContactDetailsStatisticsLinks
data GetExtendedContactDetailsStatisticsLinks = GetExtendedContactDetailsStatisticsLinks
  { getExtendedContactDetailsStatisticsLinksCount :: !(Integer) -- ^ /Required/ "count" - Number of clicks on this link for the campaign
  , getExtendedContactDetailsStatisticsLinksEventTime :: !(DateTime) -- ^ /Required/ "eventTime" - UTC date-time of the event
  , getExtendedContactDetailsStatisticsLinksIp :: !(Text) -- ^ /Required/ "ip" - IP from which the user has clicked on the link
  , getExtendedContactDetailsStatisticsLinksUrl :: !(Text) -- ^ /Required/ "url" - URL of the clicked link
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedContactDetailsStatisticsLinks
instance A.FromJSON GetExtendedContactDetailsStatisticsLinks where
  parseJSON = A.withObject "GetExtendedContactDetailsStatisticsLinks" $ \o ->
    GetExtendedContactDetailsStatisticsLinks
      <$> (o .:  "count")
      <*> (o .:  "eventTime")
      <*> (o .:  "ip")
      <*> (o .:  "url")

-- | ToJSON GetExtendedContactDetailsStatisticsLinks
instance A.ToJSON GetExtendedContactDetailsStatisticsLinks where
  toJSON GetExtendedContactDetailsStatisticsLinks {..} =
   _omitNulls
      [ "count" .= getExtendedContactDetailsStatisticsLinksCount
      , "eventTime" .= getExtendedContactDetailsStatisticsLinksEventTime
      , "ip" .= getExtendedContactDetailsStatisticsLinksIp
      , "url" .= getExtendedContactDetailsStatisticsLinksUrl
      ]


-- | Construct a value of type 'GetExtendedContactDetailsStatisticsLinks' (by applying it's required fields, if any)
mkGetExtendedContactDetailsStatisticsLinks
  :: Integer -- ^ 'getExtendedContactDetailsStatisticsLinksCount': Number of clicks on this link for the campaign
  -> DateTime -- ^ 'getExtendedContactDetailsStatisticsLinksEventTime': UTC date-time of the event
  -> Text -- ^ 'getExtendedContactDetailsStatisticsLinksIp': IP from which the user has clicked on the link
  -> Text -- ^ 'getExtendedContactDetailsStatisticsLinksUrl': URL of the clicked link
  -> GetExtendedContactDetailsStatisticsLinks
mkGetExtendedContactDetailsStatisticsLinks getExtendedContactDetailsStatisticsLinksCount getExtendedContactDetailsStatisticsLinksEventTime getExtendedContactDetailsStatisticsLinksIp getExtendedContactDetailsStatisticsLinksUrl =
  GetExtendedContactDetailsStatisticsLinks
  { getExtendedContactDetailsStatisticsLinksCount
  , getExtendedContactDetailsStatisticsLinksEventTime
  , getExtendedContactDetailsStatisticsLinksIp
  , getExtendedContactDetailsStatisticsLinksUrl
  }

-- ** GetExtendedContactDetailsStatisticsMessagesSent
-- | GetExtendedContactDetailsStatisticsMessagesSent
data GetExtendedContactDetailsStatisticsMessagesSent = GetExtendedContactDetailsStatisticsMessagesSent
  { getExtendedContactDetailsStatisticsMessagesSentCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - ID of the campaign which generated the event
  , getExtendedContactDetailsStatisticsMessagesSentEventTime :: !(DateTime) -- ^ /Required/ "eventTime" - UTC date-time of the event
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedContactDetailsStatisticsMessagesSent
instance A.FromJSON GetExtendedContactDetailsStatisticsMessagesSent where
  parseJSON = A.withObject "GetExtendedContactDetailsStatisticsMessagesSent" $ \o ->
    GetExtendedContactDetailsStatisticsMessagesSent
      <$> (o .:  "campaignId")
      <*> (o .:  "eventTime")

-- | ToJSON GetExtendedContactDetailsStatisticsMessagesSent
instance A.ToJSON GetExtendedContactDetailsStatisticsMessagesSent where
  toJSON GetExtendedContactDetailsStatisticsMessagesSent {..} =
   _omitNulls
      [ "campaignId" .= getExtendedContactDetailsStatisticsMessagesSentCampaignId
      , "eventTime" .= getExtendedContactDetailsStatisticsMessagesSentEventTime
      ]


-- | Construct a value of type 'GetExtendedContactDetailsStatisticsMessagesSent' (by applying it's required fields, if any)
mkGetExtendedContactDetailsStatisticsMessagesSent
  :: Integer -- ^ 'getExtendedContactDetailsStatisticsMessagesSentCampaignId': ID of the campaign which generated the event
  -> DateTime -- ^ 'getExtendedContactDetailsStatisticsMessagesSentEventTime': UTC date-time of the event
  -> GetExtendedContactDetailsStatisticsMessagesSent
mkGetExtendedContactDetailsStatisticsMessagesSent getExtendedContactDetailsStatisticsMessagesSentCampaignId getExtendedContactDetailsStatisticsMessagesSentEventTime =
  GetExtendedContactDetailsStatisticsMessagesSent
  { getExtendedContactDetailsStatisticsMessagesSentCampaignId
  , getExtendedContactDetailsStatisticsMessagesSentEventTime
  }

-- ** GetExtendedContactDetailsStatisticsOpened
-- | GetExtendedContactDetailsStatisticsOpened
data GetExtendedContactDetailsStatisticsOpened = GetExtendedContactDetailsStatisticsOpened
  { getExtendedContactDetailsStatisticsOpenedCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - ID of the campaign which generated the event
  , getExtendedContactDetailsStatisticsOpenedCount :: !(Integer) -- ^ /Required/ "count" - Number of openings for the campaign
  , getExtendedContactDetailsStatisticsOpenedEventTime :: !(DateTime) -- ^ /Required/ "eventTime" - UTC date-time of the event
  , getExtendedContactDetailsStatisticsOpenedIp :: !(Text) -- ^ /Required/ "ip" - IP from which the user has opened the email
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedContactDetailsStatisticsOpened
instance A.FromJSON GetExtendedContactDetailsStatisticsOpened where
  parseJSON = A.withObject "GetExtendedContactDetailsStatisticsOpened" $ \o ->
    GetExtendedContactDetailsStatisticsOpened
      <$> (o .:  "campaignId")
      <*> (o .:  "count")
      <*> (o .:  "eventTime")
      <*> (o .:  "ip")

-- | ToJSON GetExtendedContactDetailsStatisticsOpened
instance A.ToJSON GetExtendedContactDetailsStatisticsOpened where
  toJSON GetExtendedContactDetailsStatisticsOpened {..} =
   _omitNulls
      [ "campaignId" .= getExtendedContactDetailsStatisticsOpenedCampaignId
      , "count" .= getExtendedContactDetailsStatisticsOpenedCount
      , "eventTime" .= getExtendedContactDetailsStatisticsOpenedEventTime
      , "ip" .= getExtendedContactDetailsStatisticsOpenedIp
      ]


-- | Construct a value of type 'GetExtendedContactDetailsStatisticsOpened' (by applying it's required fields, if any)
mkGetExtendedContactDetailsStatisticsOpened
  :: Integer -- ^ 'getExtendedContactDetailsStatisticsOpenedCampaignId': ID of the campaign which generated the event
  -> Integer -- ^ 'getExtendedContactDetailsStatisticsOpenedCount': Number of openings for the campaign
  -> DateTime -- ^ 'getExtendedContactDetailsStatisticsOpenedEventTime': UTC date-time of the event
  -> Text -- ^ 'getExtendedContactDetailsStatisticsOpenedIp': IP from which the user has opened the email
  -> GetExtendedContactDetailsStatisticsOpened
mkGetExtendedContactDetailsStatisticsOpened getExtendedContactDetailsStatisticsOpenedCampaignId getExtendedContactDetailsStatisticsOpenedCount getExtendedContactDetailsStatisticsOpenedEventTime getExtendedContactDetailsStatisticsOpenedIp =
  GetExtendedContactDetailsStatisticsOpened
  { getExtendedContactDetailsStatisticsOpenedCampaignId
  , getExtendedContactDetailsStatisticsOpenedCount
  , getExtendedContactDetailsStatisticsOpenedEventTime
  , getExtendedContactDetailsStatisticsOpenedIp
  }

-- ** GetExtendedContactDetailsStatisticsUnsubscriptions
-- | GetExtendedContactDetailsStatisticsUnsubscriptions
-- Listing of the unsubscription for the contact
data GetExtendedContactDetailsStatisticsUnsubscriptions = GetExtendedContactDetailsStatisticsUnsubscriptions
  { getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription :: !([GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription]) -- ^ /Required/ "userUnsubscription" - Contact unsubscribe via unsubscription link in a campaign
  , getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription :: !([GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription]) -- ^ /Required/ "adminUnsubscription" - Contact has been unsubscribed from the administrator
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedContactDetailsStatisticsUnsubscriptions
instance A.FromJSON GetExtendedContactDetailsStatisticsUnsubscriptions where
  parseJSON = A.withObject "GetExtendedContactDetailsStatisticsUnsubscriptions" $ \o ->
    GetExtendedContactDetailsStatisticsUnsubscriptions
      <$> (o .:  "userUnsubscription")
      <*> (o .:  "adminUnsubscription")

-- | ToJSON GetExtendedContactDetailsStatisticsUnsubscriptions
instance A.ToJSON GetExtendedContactDetailsStatisticsUnsubscriptions where
  toJSON GetExtendedContactDetailsStatisticsUnsubscriptions {..} =
   _omitNulls
      [ "userUnsubscription" .= getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription
      , "adminUnsubscription" .= getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription
      ]


-- | Construct a value of type 'GetExtendedContactDetailsStatisticsUnsubscriptions' (by applying it's required fields, if any)
mkGetExtendedContactDetailsStatisticsUnsubscriptions
  :: [GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription] -- ^ 'getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription': Contact unsubscribe via unsubscription link in a campaign
  -> [GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription] -- ^ 'getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription': Contact has been unsubscribed from the administrator
  -> GetExtendedContactDetailsStatisticsUnsubscriptions
mkGetExtendedContactDetailsStatisticsUnsubscriptions getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription =
  GetExtendedContactDetailsStatisticsUnsubscriptions
  { getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription
  , getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription
  }

-- ** GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription
-- | GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription
data GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription = GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription
  { getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscriptionEventTime :: !(DateTime) -- ^ /Required/ "eventTime" - UTC date-time of the event
  , getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscriptionIp :: !(Text) -- ^ /Required/ "ip" - IP from which the user has been unsubscribed
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription
instance A.FromJSON GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription where
  parseJSON = A.withObject "GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription" $ \o ->
    GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription
      <$> (o .:  "eventTime")
      <*> (o .:  "ip")

-- | ToJSON GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription
instance A.ToJSON GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription where
  toJSON GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription {..} =
   _omitNulls
      [ "eventTime" .= getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscriptionEventTime
      , "ip" .= getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscriptionIp
      ]


-- | Construct a value of type 'GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription' (by applying it's required fields, if any)
mkGetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription
  :: DateTime -- ^ 'getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscriptionEventTime': UTC date-time of the event
  -> Text -- ^ 'getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscriptionIp': IP from which the user has been unsubscribed
  -> GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription
mkGetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscriptionEventTime getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscriptionIp =
  GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription
  { getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscriptionEventTime
  , getExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscriptionIp
  }

-- ** GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription
-- | GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription
data GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription = GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription
  { getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - ID of the campaign which generated the event
  , getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionEventTime :: !(DateTime) -- ^ /Required/ "eventTime" - UTC date-time of the event
  , getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionIp :: !(Text) -- ^ /Required/ "ip" - IP from which the user has unsubscribed
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription
instance A.FromJSON GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription where
  parseJSON = A.withObject "GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription" $ \o ->
    GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription
      <$> (o .:  "campaignId")
      <*> (o .:  "eventTime")
      <*> (o .:  "ip")

-- | ToJSON GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription
instance A.ToJSON GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription where
  toJSON GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription {..} =
   _omitNulls
      [ "campaignId" .= getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionCampaignId
      , "eventTime" .= getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionEventTime
      , "ip" .= getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionIp
      ]


-- | Construct a value of type 'GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription' (by applying it's required fields, if any)
mkGetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription
  :: Integer -- ^ 'getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionCampaignId': ID of the campaign which generated the event
  -> DateTime -- ^ 'getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionEventTime': UTC date-time of the event
  -> Text -- ^ 'getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionIp': IP from which the user has unsubscribed
  -> GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription
mkGetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionCampaignId getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionEventTime getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionIp =
  GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription
  { getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionCampaignId
  , getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionEventTime
  , getExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscriptionIp
  }

-- ** GetExtendedListCampaignStats
-- | GetExtendedListCampaignStats
data GetExtendedListCampaignStats = GetExtendedListCampaignStats
  { getExtendedListCampaignStatsCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - ID of the campaign
  , getExtendedListCampaignStatsStats :: !(GetCampaignStats) -- ^ /Required/ "stats"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedListCampaignStats
instance A.FromJSON GetExtendedListCampaignStats where
  parseJSON = A.withObject "GetExtendedListCampaignStats" $ \o ->
    GetExtendedListCampaignStats
      <$> (o .:  "campaignId")
      <*> (o .:  "stats")

-- | ToJSON GetExtendedListCampaignStats
instance A.ToJSON GetExtendedListCampaignStats where
  toJSON GetExtendedListCampaignStats {..} =
   _omitNulls
      [ "campaignId" .= getExtendedListCampaignStatsCampaignId
      , "stats" .= getExtendedListCampaignStatsStats
      ]


-- | Construct a value of type 'GetExtendedListCampaignStats' (by applying it's required fields, if any)
mkGetExtendedListCampaignStats
  :: Integer -- ^ 'getExtendedListCampaignStatsCampaignId': ID of the campaign
  -> GetCampaignStats -- ^ 'getExtendedListCampaignStatsStats' 
  -> GetExtendedListCampaignStats
mkGetExtendedListCampaignStats getExtendedListCampaignStatsCampaignId getExtendedListCampaignStatsStats =
  GetExtendedListCampaignStats
  { getExtendedListCampaignStatsCampaignId
  , getExtendedListCampaignStatsStats
  }

-- ** GetFolder
-- | GetFolder
data GetFolder = GetFolder
  { getFolderId :: !(Integer) -- ^ /Required/ "id" - ID of the folder
  , getFolderName :: !(Text) -- ^ /Required/ "name" - Name of the folder
  , getFolderTotalBlacklisted :: !(Integer) -- ^ /Required/ "totalBlacklisted" - Number of blacklisted contacts in the folder
  , getFolderTotalSubscribers :: !(Integer) -- ^ /Required/ "totalSubscribers" - Number of contacts in the folder
  , getFolderUniqueSubscribers :: !(Integer) -- ^ /Required/ "uniqueSubscribers" - Number of unique contacts in the folder
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetFolder
instance A.FromJSON GetFolder where
  parseJSON = A.withObject "GetFolder" $ \o ->
    GetFolder
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "totalBlacklisted")
      <*> (o .:  "totalSubscribers")
      <*> (o .:  "uniqueSubscribers")

-- | ToJSON GetFolder
instance A.ToJSON GetFolder where
  toJSON GetFolder {..} =
   _omitNulls
      [ "id" .= getFolderId
      , "name" .= getFolderName
      , "totalBlacklisted" .= getFolderTotalBlacklisted
      , "totalSubscribers" .= getFolderTotalSubscribers
      , "uniqueSubscribers" .= getFolderUniqueSubscribers
      ]


-- | Construct a value of type 'GetFolder' (by applying it's required fields, if any)
mkGetFolder
  :: Integer -- ^ 'getFolderId': ID of the folder
  -> Text -- ^ 'getFolderName': Name of the folder
  -> Integer -- ^ 'getFolderTotalBlacklisted': Number of blacklisted contacts in the folder
  -> Integer -- ^ 'getFolderTotalSubscribers': Number of contacts in the folder
  -> Integer -- ^ 'getFolderUniqueSubscribers': Number of unique contacts in the folder
  -> GetFolder
mkGetFolder getFolderId getFolderName getFolderTotalBlacklisted getFolderTotalSubscribers getFolderUniqueSubscribers =
  GetFolder
  { getFolderId
  , getFolderName
  , getFolderTotalBlacklisted
  , getFolderTotalSubscribers
  , getFolderUniqueSubscribers
  }

-- ** GetFolderLists
-- | GetFolderLists
data GetFolderLists = GetFolderLists
  { getFolderListsLists :: !([A.Value]) -- ^ /Required/ "lists"
  , getFolderListsCount :: !(Integer) -- ^ /Required/ "count" - Number of lists in the folder
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetFolderLists
instance A.FromJSON GetFolderLists where
  parseJSON = A.withObject "GetFolderLists" $ \o ->
    GetFolderLists
      <$> (o .:  "lists")
      <*> (o .:  "count")

-- | ToJSON GetFolderLists
instance A.ToJSON GetFolderLists where
  toJSON GetFolderLists {..} =
   _omitNulls
      [ "lists" .= getFolderListsLists
      , "count" .= getFolderListsCount
      ]


-- | Construct a value of type 'GetFolderLists' (by applying it's required fields, if any)
mkGetFolderLists
  :: [A.Value] -- ^ 'getFolderListsLists' 
  -> Integer -- ^ 'getFolderListsCount': Number of lists in the folder
  -> GetFolderLists
mkGetFolderLists getFolderListsLists getFolderListsCount =
  GetFolderLists
  { getFolderListsLists
  , getFolderListsCount
  }

-- ** GetFolders
-- | GetFolders
data GetFolders = GetFolders
  { getFoldersFolders :: !(Maybe [A.Value]) -- ^ "folders"
  , getFoldersCount :: !(Maybe Integer) -- ^ "count" - Number of folders available in your account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetFolders
instance A.FromJSON GetFolders where
  parseJSON = A.withObject "GetFolders" $ \o ->
    GetFolders
      <$> (o .:? "folders")
      <*> (o .:? "count")

-- | ToJSON GetFolders
instance A.ToJSON GetFolders where
  toJSON GetFolders {..} =
   _omitNulls
      [ "folders" .= getFoldersFolders
      , "count" .= getFoldersCount
      ]


-- | Construct a value of type 'GetFolders' (by applying it's required fields, if any)
mkGetFolders
  :: GetFolders
mkGetFolders =
  GetFolders
  { getFoldersFolders = Nothing
  , getFoldersCount = Nothing
  }

-- ** GetIp
-- | GetIp
data GetIp = GetIp
  { getIpId :: !(Integer) -- ^ /Required/ "id" - ID of the dedicated IP
  , getIpIp :: !(Text) -- ^ /Required/ "ip" - Dedicated IP
  , getIpActive :: !(Bool) -- ^ /Required/ "active" - Status of the IP (true&#x3D;active, false&#x3D;inactive)
  , getIpDomain :: !(Text) -- ^ /Required/ "domain" - Domain associated to the IP
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetIp
instance A.FromJSON GetIp where
  parseJSON = A.withObject "GetIp" $ \o ->
    GetIp
      <$> (o .:  "id")
      <*> (o .:  "ip")
      <*> (o .:  "active")
      <*> (o .:  "domain")

-- | ToJSON GetIp
instance A.ToJSON GetIp where
  toJSON GetIp {..} =
   _omitNulls
      [ "id" .= getIpId
      , "ip" .= getIpIp
      , "active" .= getIpActive
      , "domain" .= getIpDomain
      ]


-- | Construct a value of type 'GetIp' (by applying it's required fields, if any)
mkGetIp
  :: Integer -- ^ 'getIpId': ID of the dedicated IP
  -> Text -- ^ 'getIpIp': Dedicated IP
  -> Bool -- ^ 'getIpActive': Status of the IP (true=active, false=inactive)
  -> Text -- ^ 'getIpDomain': Domain associated to the IP
  -> GetIp
mkGetIp getIpId getIpIp getIpActive getIpDomain =
  GetIp
  { getIpId
  , getIpIp
  , getIpActive
  , getIpDomain
  }

-- ** GetIpFromSender
-- | GetIpFromSender
data GetIpFromSender = GetIpFromSender
  { getIpFromSenderId :: !(Integer) -- ^ /Required/ "id" - ID of the dedicated IP
  , getIpFromSenderIp :: !(Text) -- ^ /Required/ "ip" - Dedicated IP
  , getIpFromSenderDomain :: !(Text) -- ^ /Required/ "domain" - Domain associated to the IP
  , getIpFromSenderWeight :: !(Integer) -- ^ /Required/ "weight" - Weight of the IP
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetIpFromSender
instance A.FromJSON GetIpFromSender where
  parseJSON = A.withObject "GetIpFromSender" $ \o ->
    GetIpFromSender
      <$> (o .:  "id")
      <*> (o .:  "ip")
      <*> (o .:  "domain")
      <*> (o .:  "weight")

-- | ToJSON GetIpFromSender
instance A.ToJSON GetIpFromSender where
  toJSON GetIpFromSender {..} =
   _omitNulls
      [ "id" .= getIpFromSenderId
      , "ip" .= getIpFromSenderIp
      , "domain" .= getIpFromSenderDomain
      , "weight" .= getIpFromSenderWeight
      ]


-- | Construct a value of type 'GetIpFromSender' (by applying it's required fields, if any)
mkGetIpFromSender
  :: Integer -- ^ 'getIpFromSenderId': ID of the dedicated IP
  -> Text -- ^ 'getIpFromSenderIp': Dedicated IP
  -> Text -- ^ 'getIpFromSenderDomain': Domain associated to the IP
  -> Integer -- ^ 'getIpFromSenderWeight': Weight of the IP
  -> GetIpFromSender
mkGetIpFromSender getIpFromSenderId getIpFromSenderIp getIpFromSenderDomain getIpFromSenderWeight =
  GetIpFromSender
  { getIpFromSenderId
  , getIpFromSenderIp
  , getIpFromSenderDomain
  , getIpFromSenderWeight
  }

-- ** GetIps
-- | GetIps
data GetIps = GetIps
  { getIpsIps :: !([GetIp]) -- ^ /Required/ "ips" - Dedicated IP(s) available on your account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetIps
instance A.FromJSON GetIps where
  parseJSON = A.withObject "GetIps" $ \o ->
    GetIps
      <$> (o .:  "ips")

-- | ToJSON GetIps
instance A.ToJSON GetIps where
  toJSON GetIps {..} =
   _omitNulls
      [ "ips" .= getIpsIps
      ]


-- | Construct a value of type 'GetIps' (by applying it's required fields, if any)
mkGetIps
  :: [GetIp] -- ^ 'getIpsIps': Dedicated IP(s) available on your account
  -> GetIps
mkGetIps getIpsIps =
  GetIps
  { getIpsIps
  }

-- ** GetIpsFromSender
-- | GetIpsFromSender
data GetIpsFromSender = GetIpsFromSender
  { getIpsFromSenderIps :: !([GetIpFromSender]) -- ^ /Required/ "ips" - Dedicated IP(s) linked to a sender
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetIpsFromSender
instance A.FromJSON GetIpsFromSender where
  parseJSON = A.withObject "GetIpsFromSender" $ \o ->
    GetIpsFromSender
      <$> (o .:  "ips")

-- | ToJSON GetIpsFromSender
instance A.ToJSON GetIpsFromSender where
  toJSON GetIpsFromSender {..} =
   _omitNulls
      [ "ips" .= getIpsFromSenderIps
      ]


-- | Construct a value of type 'GetIpsFromSender' (by applying it's required fields, if any)
mkGetIpsFromSender
  :: [GetIpFromSender] -- ^ 'getIpsFromSenderIps': Dedicated IP(s) linked to a sender
  -> GetIpsFromSender
mkGetIpsFromSender getIpsFromSenderIps =
  GetIpsFromSender
  { getIpsFromSenderIps
  }

-- ** GetList
-- | GetList
data GetList = GetList
  { getListId :: !(Integer) -- ^ /Required/ "id" - ID of the list
  , getListName :: !(Text) -- ^ /Required/ "name" - Name of the list
  , getListTotalBlacklisted :: !(Integer) -- ^ /Required/ "totalBlacklisted" - Number of blacklisted contacts in the list
  , getListTotalSubscribers :: !(Integer) -- ^ /Required/ "totalSubscribers" - Number of contacts in the list
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetList
instance A.FromJSON GetList where
  parseJSON = A.withObject "GetList" $ \o ->
    GetList
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "totalBlacklisted")
      <*> (o .:  "totalSubscribers")

-- | ToJSON GetList
instance A.ToJSON GetList where
  toJSON GetList {..} =
   _omitNulls
      [ "id" .= getListId
      , "name" .= getListName
      , "totalBlacklisted" .= getListTotalBlacklisted
      , "totalSubscribers" .= getListTotalSubscribers
      ]


-- | Construct a value of type 'GetList' (by applying it's required fields, if any)
mkGetList
  :: Integer -- ^ 'getListId': ID of the list
  -> Text -- ^ 'getListName': Name of the list
  -> Integer -- ^ 'getListTotalBlacklisted': Number of blacklisted contacts in the list
  -> Integer -- ^ 'getListTotalSubscribers': Number of contacts in the list
  -> GetList
mkGetList getListId getListName getListTotalBlacklisted getListTotalSubscribers =
  GetList
  { getListId
  , getListName
  , getListTotalBlacklisted
  , getListTotalSubscribers
  }

-- ** GetLists
-- | GetLists
data GetLists = GetLists
  { getListsLists :: !([A.Value]) -- ^ /Required/ "lists" - Listing of all the lists available in your account
  , getListsCount :: !(Integer) -- ^ /Required/ "count" - Number of lists in your account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetLists
instance A.FromJSON GetLists where
  parseJSON = A.withObject "GetLists" $ \o ->
    GetLists
      <$> (o .:  "lists")
      <*> (o .:  "count")

-- | ToJSON GetLists
instance A.ToJSON GetLists where
  toJSON GetLists {..} =
   _omitNulls
      [ "lists" .= getListsLists
      , "count" .= getListsCount
      ]


-- | Construct a value of type 'GetLists' (by applying it's required fields, if any)
mkGetLists
  :: [A.Value] -- ^ 'getListsLists': Listing of all the lists available in your account
  -> Integer -- ^ 'getListsCount': Number of lists in your account
  -> GetLists
mkGetLists getListsLists getListsCount =
  GetLists
  { getListsLists
  , getListsCount
  }

-- ** GetProcess
-- | GetProcess
data GetProcess = GetProcess
  { getProcessId :: !(Integer) -- ^ /Required/ "id" - Id of the process
  , getProcessStatus :: !(E'Status) -- ^ /Required/ "status" - Status of the process
  , getProcessName :: !(Text) -- ^ /Required/ "name" - Process name
  , getProcessExportUrl :: !(Maybe Text) -- ^ "export_url" - URL on which send export the of contacts once the process is completed
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetProcess
instance A.FromJSON GetProcess where
  parseJSON = A.withObject "GetProcess" $ \o ->
    GetProcess
      <$> (o .:  "id")
      <*> (o .:  "status")
      <*> (o .:  "name")
      <*> (o .:? "export_url")

-- | ToJSON GetProcess
instance A.ToJSON GetProcess where
  toJSON GetProcess {..} =
   _omitNulls
      [ "id" .= getProcessId
      , "status" .= getProcessStatus
      , "name" .= getProcessName
      , "export_url" .= getProcessExportUrl
      ]


-- | Construct a value of type 'GetProcess' (by applying it's required fields, if any)
mkGetProcess
  :: Integer -- ^ 'getProcessId': Id of the process
  -> E'Status -- ^ 'getProcessStatus': Status of the process
  -> Text -- ^ 'getProcessName': Process name
  -> GetProcess
mkGetProcess getProcessId getProcessStatus getProcessName =
  GetProcess
  { getProcessId
  , getProcessStatus
  , getProcessName
  , getProcessExportUrl = Nothing
  }

-- ** GetProcesses
-- | GetProcesses
data GetProcesses = GetProcesses
  { getProcessesProcesses :: !(Maybe [GetProcess]) -- ^ "processes" - List of processes available on your account
  , getProcessesCount :: !(Integer) -- ^ /Required/ "count" - Number of processes available on your account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetProcesses
instance A.FromJSON GetProcesses where
  parseJSON = A.withObject "GetProcesses" $ \o ->
    GetProcesses
      <$> (o .:? "processes")
      <*> (o .:  "count")

-- | ToJSON GetProcesses
instance A.ToJSON GetProcesses where
  toJSON GetProcesses {..} =
   _omitNulls
      [ "processes" .= getProcessesProcesses
      , "count" .= getProcessesCount
      ]


-- | Construct a value of type 'GetProcesses' (by applying it's required fields, if any)
mkGetProcesses
  :: Integer -- ^ 'getProcessesCount': Number of processes available on your account
  -> GetProcesses
mkGetProcesses getProcessesCount =
  GetProcesses
  { getProcessesProcesses = Nothing
  , getProcessesCount
  }

-- ** GetReports
-- | GetReports
data GetReports = GetReports
  { getReportsReports :: !(Maybe [GetReportsReports]) -- ^ "reports"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetReports
instance A.FromJSON GetReports where
  parseJSON = A.withObject "GetReports" $ \o ->
    GetReports
      <$> (o .:? "reports")

-- | ToJSON GetReports
instance A.ToJSON GetReports where
  toJSON GetReports {..} =
   _omitNulls
      [ "reports" .= getReportsReports
      ]


-- | Construct a value of type 'GetReports' (by applying it's required fields, if any)
mkGetReports
  :: GetReports
mkGetReports =
  GetReports
  { getReportsReports = Nothing
  }

-- ** GetReportsReports
-- | GetReportsReports
data GetReportsReports = GetReportsReports
  { getReportsReportsDate :: !(Date) -- ^ /Required/ "date" - Date of the statistics
  , getReportsReportsRequests :: !(Integer) -- ^ /Required/ "requests" - Number of requests for the date
  , getReportsReportsDelivered :: !(Integer) -- ^ /Required/ "delivered" - Number of delivered emails for the date
  , getReportsReportsHardBounces :: !(Integer) -- ^ /Required/ "hardBounces" - Number of hardbounces for the date
  , getReportsReportsSoftBounces :: !(Integer) -- ^ /Required/ "softBounces" - Number of softbounces for the date
  , getReportsReportsClicks :: !(Integer) -- ^ /Required/ "clicks" - Number of clicks for the date
  , getReportsReportsUniqueClicks :: !(Integer) -- ^ /Required/ "uniqueClicks" - Number of unique clicks for the date
  , getReportsReportsOpens :: !(Integer) -- ^ /Required/ "opens" - Number of openings for the date
  , getReportsReportsUniqueOpens :: !(Integer) -- ^ /Required/ "uniqueOpens" - Number of unique openings for the date
  , getReportsReportsSpamReports :: !(Integer) -- ^ /Required/ "spamReports" - Number of complaints (spam reports) for the date
  , getReportsReportsBlocked :: !(Integer) -- ^ /Required/ "blocked" - Number of blocked emails for the date
  , getReportsReportsInvalid :: !(Integer) -- ^ /Required/ "invalid" - Number of invalid emails for the date
  , getReportsReportsUnsubscribed :: !(Integer) -- ^ /Required/ "unsubscribed" - Number of unsubscribed emails for the date
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetReportsReports
instance A.FromJSON GetReportsReports where
  parseJSON = A.withObject "GetReportsReports" $ \o ->
    GetReportsReports
      <$> (o .:  "date")
      <*> (o .:  "requests")
      <*> (o .:  "delivered")
      <*> (o .:  "hardBounces")
      <*> (o .:  "softBounces")
      <*> (o .:  "clicks")
      <*> (o .:  "uniqueClicks")
      <*> (o .:  "opens")
      <*> (o .:  "uniqueOpens")
      <*> (o .:  "spamReports")
      <*> (o .:  "blocked")
      <*> (o .:  "invalid")
      <*> (o .:  "unsubscribed")

-- | ToJSON GetReportsReports
instance A.ToJSON GetReportsReports where
  toJSON GetReportsReports {..} =
   _omitNulls
      [ "date" .= getReportsReportsDate
      , "requests" .= getReportsReportsRequests
      , "delivered" .= getReportsReportsDelivered
      , "hardBounces" .= getReportsReportsHardBounces
      , "softBounces" .= getReportsReportsSoftBounces
      , "clicks" .= getReportsReportsClicks
      , "uniqueClicks" .= getReportsReportsUniqueClicks
      , "opens" .= getReportsReportsOpens
      , "uniqueOpens" .= getReportsReportsUniqueOpens
      , "spamReports" .= getReportsReportsSpamReports
      , "blocked" .= getReportsReportsBlocked
      , "invalid" .= getReportsReportsInvalid
      , "unsubscribed" .= getReportsReportsUnsubscribed
      ]


-- | Construct a value of type 'GetReportsReports' (by applying it's required fields, if any)
mkGetReportsReports
  :: Date -- ^ 'getReportsReportsDate': Date of the statistics
  -> Integer -- ^ 'getReportsReportsRequests': Number of requests for the date
  -> Integer -- ^ 'getReportsReportsDelivered': Number of delivered emails for the date
  -> Integer -- ^ 'getReportsReportsHardBounces': Number of hardbounces for the date
  -> Integer -- ^ 'getReportsReportsSoftBounces': Number of softbounces for the date
  -> Integer -- ^ 'getReportsReportsClicks': Number of clicks for the date
  -> Integer -- ^ 'getReportsReportsUniqueClicks': Number of unique clicks for the date
  -> Integer -- ^ 'getReportsReportsOpens': Number of openings for the date
  -> Integer -- ^ 'getReportsReportsUniqueOpens': Number of unique openings for the date
  -> Integer -- ^ 'getReportsReportsSpamReports': Number of complaints (spam reports) for the date
  -> Integer -- ^ 'getReportsReportsBlocked': Number of blocked emails for the date
  -> Integer -- ^ 'getReportsReportsInvalid': Number of invalid emails for the date
  -> Integer -- ^ 'getReportsReportsUnsubscribed': Number of unsubscribed emails for the date
  -> GetReportsReports
mkGetReportsReports getReportsReportsDate getReportsReportsRequests getReportsReportsDelivered getReportsReportsHardBounces getReportsReportsSoftBounces getReportsReportsClicks getReportsReportsUniqueClicks getReportsReportsOpens getReportsReportsUniqueOpens getReportsReportsSpamReports getReportsReportsBlocked getReportsReportsInvalid getReportsReportsUnsubscribed =
  GetReportsReports
  { getReportsReportsDate
  , getReportsReportsRequests
  , getReportsReportsDelivered
  , getReportsReportsHardBounces
  , getReportsReportsSoftBounces
  , getReportsReportsClicks
  , getReportsReportsUniqueClicks
  , getReportsReportsOpens
  , getReportsReportsUniqueOpens
  , getReportsReportsSpamReports
  , getReportsReportsBlocked
  , getReportsReportsInvalid
  , getReportsReportsUnsubscribed
  }

-- ** GetSendersList
-- | GetSendersList
data GetSendersList = GetSendersList
  { getSendersListSenders :: !(Maybe [GetSendersListSenders]) -- ^ "senders" - List of the senders available in your account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSendersList
instance A.FromJSON GetSendersList where
  parseJSON = A.withObject "GetSendersList" $ \o ->
    GetSendersList
      <$> (o .:? "senders")

-- | ToJSON GetSendersList
instance A.ToJSON GetSendersList where
  toJSON GetSendersList {..} =
   _omitNulls
      [ "senders" .= getSendersListSenders
      ]


-- | Construct a value of type 'GetSendersList' (by applying it's required fields, if any)
mkGetSendersList
  :: GetSendersList
mkGetSendersList =
  GetSendersList
  { getSendersListSenders = Nothing
  }

-- ** GetSendersListIps
-- | GetSendersListIps
data GetSendersListIps = GetSendersListIps
  { getSendersListIpsIp :: !(Text) -- ^ /Required/ "ip" - Dedicated IP available in your account
  , getSendersListIpsDomain :: !(Text) -- ^ /Required/ "domain" - Domain of the IP
  , getSendersListIpsWeight :: !(Integer) -- ^ /Required/ "weight" - Weight of the IP for this sender
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSendersListIps
instance A.FromJSON GetSendersListIps where
  parseJSON = A.withObject "GetSendersListIps" $ \o ->
    GetSendersListIps
      <$> (o .:  "ip")
      <*> (o .:  "domain")
      <*> (o .:  "weight")

-- | ToJSON GetSendersListIps
instance A.ToJSON GetSendersListIps where
  toJSON GetSendersListIps {..} =
   _omitNulls
      [ "ip" .= getSendersListIpsIp
      , "domain" .= getSendersListIpsDomain
      , "weight" .= getSendersListIpsWeight
      ]


-- | Construct a value of type 'GetSendersListIps' (by applying it's required fields, if any)
mkGetSendersListIps
  :: Text -- ^ 'getSendersListIpsIp': Dedicated IP available in your account
  -> Text -- ^ 'getSendersListIpsDomain': Domain of the IP
  -> Integer -- ^ 'getSendersListIpsWeight': Weight of the IP for this sender
  -> GetSendersListIps
mkGetSendersListIps getSendersListIpsIp getSendersListIpsDomain getSendersListIpsWeight =
  GetSendersListIps
  { getSendersListIpsIp
  , getSendersListIpsDomain
  , getSendersListIpsWeight
  }

-- ** GetSendersListSenders
-- | GetSendersListSenders
data GetSendersListSenders = GetSendersListSenders
  { getSendersListSendersId :: !(Integer) -- ^ /Required/ "id" - Id of the sender
  , getSendersListSendersName :: !(Text) -- ^ /Required/ "name" - From Name associated to the sender
  , getSendersListSendersEmail :: !(Text) -- ^ /Required/ "email" - From Email associated to the sender
  , getSendersListSendersActive :: !(Bool) -- ^ /Required/ "active" - Status of sender (true&#x3D;activated, false&#x3D;deactivated)
  , getSendersListSendersIps :: !(Maybe [GetSendersListIps]) -- ^ "ips" - List of dedicated IP(s) available in the account. This data is displayed only for dedicated IPs
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSendersListSenders
instance A.FromJSON GetSendersListSenders where
  parseJSON = A.withObject "GetSendersListSenders" $ \o ->
    GetSendersListSenders
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "email")
      <*> (o .:  "active")
      <*> (o .:? "ips")

-- | ToJSON GetSendersListSenders
instance A.ToJSON GetSendersListSenders where
  toJSON GetSendersListSenders {..} =
   _omitNulls
      [ "id" .= getSendersListSendersId
      , "name" .= getSendersListSendersName
      , "email" .= getSendersListSendersEmail
      , "active" .= getSendersListSendersActive
      , "ips" .= getSendersListSendersIps
      ]


-- | Construct a value of type 'GetSendersListSenders' (by applying it's required fields, if any)
mkGetSendersListSenders
  :: Integer -- ^ 'getSendersListSendersId': Id of the sender
  -> Text -- ^ 'getSendersListSendersName': From Name associated to the sender
  -> Text -- ^ 'getSendersListSendersEmail': From Email associated to the sender
  -> Bool -- ^ 'getSendersListSendersActive': Status of sender (true=activated, false=deactivated)
  -> GetSendersListSenders
mkGetSendersListSenders getSendersListSendersId getSendersListSendersName getSendersListSendersEmail getSendersListSendersActive =
  GetSendersListSenders
  { getSendersListSendersId
  , getSendersListSendersName
  , getSendersListSendersEmail
  , getSendersListSendersActive
  , getSendersListSendersIps = Nothing
  }

-- ** GetSharedTemplateUrl
-- | GetSharedTemplateUrl
data GetSharedTemplateUrl = GetSharedTemplateUrl
  { getSharedTemplateUrlSharedUrl :: !(Text) -- ^ /Required/ "sharedUrl" - A unique URL for the email campaign or transactional template. This URL can be shared with other Sendinblue users.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSharedTemplateUrl
instance A.FromJSON GetSharedTemplateUrl where
  parseJSON = A.withObject "GetSharedTemplateUrl" $ \o ->
    GetSharedTemplateUrl
      <$> (o .:  "sharedUrl")

-- | ToJSON GetSharedTemplateUrl
instance A.ToJSON GetSharedTemplateUrl where
  toJSON GetSharedTemplateUrl {..} =
   _omitNulls
      [ "sharedUrl" .= getSharedTemplateUrlSharedUrl
      ]


-- | Construct a value of type 'GetSharedTemplateUrl' (by applying it's required fields, if any)
mkGetSharedTemplateUrl
  :: Text -- ^ 'getSharedTemplateUrlSharedUrl': A unique URL for the email campaign or transactional template. This URL can be shared with other Sendinblue users.
  -> GetSharedTemplateUrl
mkGetSharedTemplateUrl getSharedTemplateUrlSharedUrl =
  GetSharedTemplateUrl
  { getSharedTemplateUrlSharedUrl
  }

-- ** GetSmsCampaignOverview
-- | GetSmsCampaignOverview
data GetSmsCampaignOverview = GetSmsCampaignOverview
  { getSmsCampaignOverviewId :: !(Integer) -- ^ /Required/ "id" - ID of the SMS Campaign
  , getSmsCampaignOverviewName :: !(Text) -- ^ /Required/ "name" - Name of the SMS Campaign
  , getSmsCampaignOverviewStatus :: !(E'Status2) -- ^ /Required/ "status" - Status of the SMS Campaign
  , getSmsCampaignOverviewContent :: !(Text) -- ^ /Required/ "content" - Content of the SMS Campaign
  , getSmsCampaignOverviewScheduledAt :: !(DateTime) -- ^ /Required/ "scheduledAt" - UTC date-time on which SMS campaign is scheduled. Should be in YYYY-MM-DDTHH:mm:ss.SSSZ format
  , getSmsCampaignOverviewSender :: !(Text) -- ^ /Required/ "sender" - Sender of the SMS Campaign
  , getSmsCampaignOverviewCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Creation UTC date-time of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getSmsCampaignOverviewModifiedAt :: !(DateTime) -- ^ /Required/ "modifiedAt" - UTC date-time of last modification of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSmsCampaignOverview
instance A.FromJSON GetSmsCampaignOverview where
  parseJSON = A.withObject "GetSmsCampaignOverview" $ \o ->
    GetSmsCampaignOverview
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "status")
      <*> (o .:  "content")
      <*> (o .:  "scheduledAt")
      <*> (o .:  "sender")
      <*> (o .:  "createdAt")
      <*> (o .:  "modifiedAt")

-- | ToJSON GetSmsCampaignOverview
instance A.ToJSON GetSmsCampaignOverview where
  toJSON GetSmsCampaignOverview {..} =
   _omitNulls
      [ "id" .= getSmsCampaignOverviewId
      , "name" .= getSmsCampaignOverviewName
      , "status" .= getSmsCampaignOverviewStatus
      , "content" .= getSmsCampaignOverviewContent
      , "scheduledAt" .= getSmsCampaignOverviewScheduledAt
      , "sender" .= getSmsCampaignOverviewSender
      , "createdAt" .= getSmsCampaignOverviewCreatedAt
      , "modifiedAt" .= getSmsCampaignOverviewModifiedAt
      ]


-- | Construct a value of type 'GetSmsCampaignOverview' (by applying it's required fields, if any)
mkGetSmsCampaignOverview
  :: Integer -- ^ 'getSmsCampaignOverviewId': ID of the SMS Campaign
  -> Text -- ^ 'getSmsCampaignOverviewName': Name of the SMS Campaign
  -> E'Status2 -- ^ 'getSmsCampaignOverviewStatus': Status of the SMS Campaign
  -> Text -- ^ 'getSmsCampaignOverviewContent': Content of the SMS Campaign
  -> DateTime -- ^ 'getSmsCampaignOverviewScheduledAt': UTC date-time on which SMS campaign is scheduled. Should be in YYYY-MM-DDTHH:mm:ss.SSSZ format
  -> Text -- ^ 'getSmsCampaignOverviewSender': Sender of the SMS Campaign
  -> DateTime -- ^ 'getSmsCampaignOverviewCreatedAt': Creation UTC date-time of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> DateTime -- ^ 'getSmsCampaignOverviewModifiedAt': UTC date-time of last modification of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> GetSmsCampaignOverview
mkGetSmsCampaignOverview getSmsCampaignOverviewId getSmsCampaignOverviewName getSmsCampaignOverviewStatus getSmsCampaignOverviewContent getSmsCampaignOverviewScheduledAt getSmsCampaignOverviewSender getSmsCampaignOverviewCreatedAt getSmsCampaignOverviewModifiedAt =
  GetSmsCampaignOverview
  { getSmsCampaignOverviewId
  , getSmsCampaignOverviewName
  , getSmsCampaignOverviewStatus
  , getSmsCampaignOverviewContent
  , getSmsCampaignOverviewScheduledAt
  , getSmsCampaignOverviewSender
  , getSmsCampaignOverviewCreatedAt
  , getSmsCampaignOverviewModifiedAt
  }

-- ** GetSmsCampaignStats
-- | GetSmsCampaignStats
data GetSmsCampaignStats = GetSmsCampaignStats
  { getSmsCampaignStatsDelivered :: !(Integer) -- ^ /Required/ "delivered" - Number of delivered SMS
  , getSmsCampaignStatsSent :: !(Integer) -- ^ /Required/ "sent" - Number of sent SMS
  , getSmsCampaignStatsProcessing :: !(Integer) -- ^ /Required/ "processing" - Number of processing SMS
  , getSmsCampaignStatsSoftBounces :: !(Integer) -- ^ /Required/ "softBounces" - Number of softbounced SMS
  , getSmsCampaignStatsHardBounces :: !(Integer) -- ^ /Required/ "hardBounces" - Number of hardbounced SMS
  , getSmsCampaignStatsUnsubscriptions :: !(Integer) -- ^ /Required/ "unsubscriptions" - Number of unsubscription SMS
  , getSmsCampaignStatsAnswered :: !(Integer) -- ^ /Required/ "answered" - Number of replies to the SMS
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSmsCampaignStats
instance A.FromJSON GetSmsCampaignStats where
  parseJSON = A.withObject "GetSmsCampaignStats" $ \o ->
    GetSmsCampaignStats
      <$> (o .:  "delivered")
      <*> (o .:  "sent")
      <*> (o .:  "processing")
      <*> (o .:  "softBounces")
      <*> (o .:  "hardBounces")
      <*> (o .:  "unsubscriptions")
      <*> (o .:  "answered")

-- | ToJSON GetSmsCampaignStats
instance A.ToJSON GetSmsCampaignStats where
  toJSON GetSmsCampaignStats {..} =
   _omitNulls
      [ "delivered" .= getSmsCampaignStatsDelivered
      , "sent" .= getSmsCampaignStatsSent
      , "processing" .= getSmsCampaignStatsProcessing
      , "softBounces" .= getSmsCampaignStatsSoftBounces
      , "hardBounces" .= getSmsCampaignStatsHardBounces
      , "unsubscriptions" .= getSmsCampaignStatsUnsubscriptions
      , "answered" .= getSmsCampaignStatsAnswered
      ]


-- | Construct a value of type 'GetSmsCampaignStats' (by applying it's required fields, if any)
mkGetSmsCampaignStats
  :: Integer -- ^ 'getSmsCampaignStatsDelivered': Number of delivered SMS
  -> Integer -- ^ 'getSmsCampaignStatsSent': Number of sent SMS
  -> Integer -- ^ 'getSmsCampaignStatsProcessing': Number of processing SMS
  -> Integer -- ^ 'getSmsCampaignStatsSoftBounces': Number of softbounced SMS
  -> Integer -- ^ 'getSmsCampaignStatsHardBounces': Number of hardbounced SMS
  -> Integer -- ^ 'getSmsCampaignStatsUnsubscriptions': Number of unsubscription SMS
  -> Integer -- ^ 'getSmsCampaignStatsAnswered': Number of replies to the SMS
  -> GetSmsCampaignStats
mkGetSmsCampaignStats getSmsCampaignStatsDelivered getSmsCampaignStatsSent getSmsCampaignStatsProcessing getSmsCampaignStatsSoftBounces getSmsCampaignStatsHardBounces getSmsCampaignStatsUnsubscriptions getSmsCampaignStatsAnswered =
  GetSmsCampaignStats
  { getSmsCampaignStatsDelivered
  , getSmsCampaignStatsSent
  , getSmsCampaignStatsProcessing
  , getSmsCampaignStatsSoftBounces
  , getSmsCampaignStatsHardBounces
  , getSmsCampaignStatsUnsubscriptions
  , getSmsCampaignStatsAnswered
  }

-- ** GetSmsCampaigns
-- | GetSmsCampaigns
data GetSmsCampaigns = GetSmsCampaigns
  { getSmsCampaignsCampaigns :: !(Maybe [A.Value]) -- ^ "campaigns"
  , getSmsCampaignsCount :: !(Integer) -- ^ /Required/ "count" - Number of SMS campaigns retrieved
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSmsCampaigns
instance A.FromJSON GetSmsCampaigns where
  parseJSON = A.withObject "GetSmsCampaigns" $ \o ->
    GetSmsCampaigns
      <$> (o .:? "campaigns")
      <*> (o .:  "count")

-- | ToJSON GetSmsCampaigns
instance A.ToJSON GetSmsCampaigns where
  toJSON GetSmsCampaigns {..} =
   _omitNulls
      [ "campaigns" .= getSmsCampaignsCampaigns
      , "count" .= getSmsCampaignsCount
      ]


-- | Construct a value of type 'GetSmsCampaigns' (by applying it's required fields, if any)
mkGetSmsCampaigns
  :: Integer -- ^ 'getSmsCampaignsCount': Number of SMS campaigns retrieved
  -> GetSmsCampaigns
mkGetSmsCampaigns getSmsCampaignsCount =
  GetSmsCampaigns
  { getSmsCampaignsCampaigns = Nothing
  , getSmsCampaignsCount
  }

-- ** GetSmsEventReport
-- | GetSmsEventReport
data GetSmsEventReport = GetSmsEventReport
  { getSmsEventReportEvents :: !(Maybe [GetSmsEventReportEvents]) -- ^ "events"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSmsEventReport
instance A.FromJSON GetSmsEventReport where
  parseJSON = A.withObject "GetSmsEventReport" $ \o ->
    GetSmsEventReport
      <$> (o .:? "events")

-- | ToJSON GetSmsEventReport
instance A.ToJSON GetSmsEventReport where
  toJSON GetSmsEventReport {..} =
   _omitNulls
      [ "events" .= getSmsEventReportEvents
      ]


-- | Construct a value of type 'GetSmsEventReport' (by applying it's required fields, if any)
mkGetSmsEventReport
  :: GetSmsEventReport
mkGetSmsEventReport =
  GetSmsEventReport
  { getSmsEventReportEvents = Nothing
  }

-- ** GetSmsEventReportEvents
-- | GetSmsEventReportEvents
data GetSmsEventReportEvents = GetSmsEventReportEvents
  { getSmsEventReportEventsPhoneNumber :: !(Text) -- ^ /Required/ "phoneNumber" - Phone number which has generated the event
  , getSmsEventReportEventsDate :: !(DateTime) -- ^ /Required/ "date" - UTC date-time on which the event has been generated
  , getSmsEventReportEventsMessageId :: !(Text) -- ^ /Required/ "messageId" - Message ID which generated the event
  , getSmsEventReportEventsEvent :: !(E'Event2) -- ^ /Required/ "event" - Event which occurred
  , getSmsEventReportEventsReason :: !(Maybe Text) -- ^ "reason" - Reason of bounce (only available if the event is hardbounce or softbounce)
  , getSmsEventReportEventsReply :: !(Maybe Text) -- ^ "reply"
  , getSmsEventReportEventsTag :: !(Maybe Text) -- ^ "tag" - Tag of the SMS which generated the event
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSmsEventReportEvents
instance A.FromJSON GetSmsEventReportEvents where
  parseJSON = A.withObject "GetSmsEventReportEvents" $ \o ->
    GetSmsEventReportEvents
      <$> (o .:  "phoneNumber")
      <*> (o .:  "date")
      <*> (o .:  "messageId")
      <*> (o .:  "event")
      <*> (o .:? "reason")
      <*> (o .:? "reply")
      <*> (o .:? "tag")

-- | ToJSON GetSmsEventReportEvents
instance A.ToJSON GetSmsEventReportEvents where
  toJSON GetSmsEventReportEvents {..} =
   _omitNulls
      [ "phoneNumber" .= getSmsEventReportEventsPhoneNumber
      , "date" .= getSmsEventReportEventsDate
      , "messageId" .= getSmsEventReportEventsMessageId
      , "event" .= getSmsEventReportEventsEvent
      , "reason" .= getSmsEventReportEventsReason
      , "reply" .= getSmsEventReportEventsReply
      , "tag" .= getSmsEventReportEventsTag
      ]


-- | Construct a value of type 'GetSmsEventReportEvents' (by applying it's required fields, if any)
mkGetSmsEventReportEvents
  :: Text -- ^ 'getSmsEventReportEventsPhoneNumber': Phone number which has generated the event
  -> DateTime -- ^ 'getSmsEventReportEventsDate': UTC date-time on which the event has been generated
  -> Text -- ^ 'getSmsEventReportEventsMessageId': Message ID which generated the event
  -> E'Event2 -- ^ 'getSmsEventReportEventsEvent': Event which occurred
  -> GetSmsEventReportEvents
mkGetSmsEventReportEvents getSmsEventReportEventsPhoneNumber getSmsEventReportEventsDate getSmsEventReportEventsMessageId getSmsEventReportEventsEvent =
  GetSmsEventReportEvents
  { getSmsEventReportEventsPhoneNumber
  , getSmsEventReportEventsDate
  , getSmsEventReportEventsMessageId
  , getSmsEventReportEventsEvent
  , getSmsEventReportEventsReason = Nothing
  , getSmsEventReportEventsReply = Nothing
  , getSmsEventReportEventsTag = Nothing
  }

-- ** GetSmtpTemplateOverview
-- | GetSmtpTemplateOverview
data GetSmtpTemplateOverview = GetSmtpTemplateOverview
  { getSmtpTemplateOverviewId :: !(Integer) -- ^ /Required/ "id" - ID of the template
  , getSmtpTemplateOverviewName :: !(Text) -- ^ /Required/ "name" - Name of the template
  , getSmtpTemplateOverviewSubject :: !(Text) -- ^ /Required/ "subject" - Subject of the template
  , getSmtpTemplateOverviewIsActive :: !(Bool) -- ^ /Required/ "isActive" - Status of template (true&#x3D;active, false&#x3D;inactive)
  , getSmtpTemplateOverviewTestSent :: !(Bool) -- ^ /Required/ "testSent" - Status of test sending for the template (true&#x3D;test email has been sent, false&#x3D;test email has not been sent)
  , getSmtpTemplateOverviewSender :: !(GetSmtpTemplateOverviewSender) -- ^ /Required/ "sender"
  , getSmtpTemplateOverviewReplyTo :: !(Text) -- ^ /Required/ "replyTo" - Email defined as the \&quot;Reply to\&quot; for the template
  , getSmtpTemplateOverviewToField :: !(Text) -- ^ /Required/ "toField" - Customisation of the \&quot;to\&quot; field for the template
  , getSmtpTemplateOverviewTag :: !(Text) -- ^ /Required/ "tag" - Tag of the template
  , getSmtpTemplateOverviewHtmlContent :: !(Text) -- ^ /Required/ "htmlContent" - HTML content of the template
  , getSmtpTemplateOverviewCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Creation UTC date-time of the template (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getSmtpTemplateOverviewModifiedAt :: !(DateTime) -- ^ /Required/ "modifiedAt" - Last modification UTC date-time of the template (YYYY-MM-DDTHH:mm:ss.SSSZ)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSmtpTemplateOverview
instance A.FromJSON GetSmtpTemplateOverview where
  parseJSON = A.withObject "GetSmtpTemplateOverview" $ \o ->
    GetSmtpTemplateOverview
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "subject")
      <*> (o .:  "isActive")
      <*> (o .:  "testSent")
      <*> (o .:  "sender")
      <*> (o .:  "replyTo")
      <*> (o .:  "toField")
      <*> (o .:  "tag")
      <*> (o .:  "htmlContent")
      <*> (o .:  "createdAt")
      <*> (o .:  "modifiedAt")

-- | ToJSON GetSmtpTemplateOverview
instance A.ToJSON GetSmtpTemplateOverview where
  toJSON GetSmtpTemplateOverview {..} =
   _omitNulls
      [ "id" .= getSmtpTemplateOverviewId
      , "name" .= getSmtpTemplateOverviewName
      , "subject" .= getSmtpTemplateOverviewSubject
      , "isActive" .= getSmtpTemplateOverviewIsActive
      , "testSent" .= getSmtpTemplateOverviewTestSent
      , "sender" .= getSmtpTemplateOverviewSender
      , "replyTo" .= getSmtpTemplateOverviewReplyTo
      , "toField" .= getSmtpTemplateOverviewToField
      , "tag" .= getSmtpTemplateOverviewTag
      , "htmlContent" .= getSmtpTemplateOverviewHtmlContent
      , "createdAt" .= getSmtpTemplateOverviewCreatedAt
      , "modifiedAt" .= getSmtpTemplateOverviewModifiedAt
      ]


-- | Construct a value of type 'GetSmtpTemplateOverview' (by applying it's required fields, if any)
mkGetSmtpTemplateOverview
  :: Integer -- ^ 'getSmtpTemplateOverviewId': ID of the template
  -> Text -- ^ 'getSmtpTemplateOverviewName': Name of the template
  -> Text -- ^ 'getSmtpTemplateOverviewSubject': Subject of the template
  -> Bool -- ^ 'getSmtpTemplateOverviewIsActive': Status of template (true=active, false=inactive)
  -> Bool -- ^ 'getSmtpTemplateOverviewTestSent': Status of test sending for the template (true=test email has been sent, false=test email has not been sent)
  -> GetSmtpTemplateOverviewSender -- ^ 'getSmtpTemplateOverviewSender' 
  -> Text -- ^ 'getSmtpTemplateOverviewReplyTo': Email defined as the \"Reply to\" for the template
  -> Text -- ^ 'getSmtpTemplateOverviewToField': Customisation of the \"to\" field for the template
  -> Text -- ^ 'getSmtpTemplateOverviewTag': Tag of the template
  -> Text -- ^ 'getSmtpTemplateOverviewHtmlContent': HTML content of the template
  -> DateTime -- ^ 'getSmtpTemplateOverviewCreatedAt': Creation UTC date-time of the template (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> DateTime -- ^ 'getSmtpTemplateOverviewModifiedAt': Last modification UTC date-time of the template (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> GetSmtpTemplateOverview
mkGetSmtpTemplateOverview getSmtpTemplateOverviewId getSmtpTemplateOverviewName getSmtpTemplateOverviewSubject getSmtpTemplateOverviewIsActive getSmtpTemplateOverviewTestSent getSmtpTemplateOverviewSender getSmtpTemplateOverviewReplyTo getSmtpTemplateOverviewToField getSmtpTemplateOverviewTag getSmtpTemplateOverviewHtmlContent getSmtpTemplateOverviewCreatedAt getSmtpTemplateOverviewModifiedAt =
  GetSmtpTemplateOverview
  { getSmtpTemplateOverviewId
  , getSmtpTemplateOverviewName
  , getSmtpTemplateOverviewSubject
  , getSmtpTemplateOverviewIsActive
  , getSmtpTemplateOverviewTestSent
  , getSmtpTemplateOverviewSender
  , getSmtpTemplateOverviewReplyTo
  , getSmtpTemplateOverviewToField
  , getSmtpTemplateOverviewTag
  , getSmtpTemplateOverviewHtmlContent
  , getSmtpTemplateOverviewCreatedAt
  , getSmtpTemplateOverviewModifiedAt
  }

-- ** GetSmtpTemplateOverviewSender
-- | GetSmtpTemplateOverviewSender
data GetSmtpTemplateOverviewSender = GetSmtpTemplateOverviewSender
  { getSmtpTemplateOverviewSenderName :: !(Maybe Text) -- ^ "name" - From email for the template
  , getSmtpTemplateOverviewSenderEmail :: !(Maybe Text) -- ^ "email" - From email for the template
  , getSmtpTemplateOverviewSenderId :: !(Maybe Text) -- ^ "id" - Sender id of the template
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSmtpTemplateOverviewSender
instance A.FromJSON GetSmtpTemplateOverviewSender where
  parseJSON = A.withObject "GetSmtpTemplateOverviewSender" $ \o ->
    GetSmtpTemplateOverviewSender
      <$> (o .:? "name")
      <*> (o .:? "email")
      <*> (o .:? "id")

-- | ToJSON GetSmtpTemplateOverviewSender
instance A.ToJSON GetSmtpTemplateOverviewSender where
  toJSON GetSmtpTemplateOverviewSender {..} =
   _omitNulls
      [ "name" .= getSmtpTemplateOverviewSenderName
      , "email" .= getSmtpTemplateOverviewSenderEmail
      , "id" .= getSmtpTemplateOverviewSenderId
      ]


-- | Construct a value of type 'GetSmtpTemplateOverviewSender' (by applying it's required fields, if any)
mkGetSmtpTemplateOverviewSender
  :: GetSmtpTemplateOverviewSender
mkGetSmtpTemplateOverviewSender =
  GetSmtpTemplateOverviewSender
  { getSmtpTemplateOverviewSenderName = Nothing
  , getSmtpTemplateOverviewSenderEmail = Nothing
  , getSmtpTemplateOverviewSenderId = Nothing
  }

-- ** GetSmtpTemplates
-- | GetSmtpTemplates
data GetSmtpTemplates = GetSmtpTemplates
  { getSmtpTemplatesCount :: !(Maybe Integer) -- ^ "count" - Count of transactional email templates
  , getSmtpTemplatesTemplates :: !(Maybe [GetSmtpTemplateOverview]) -- ^ "templates"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSmtpTemplates
instance A.FromJSON GetSmtpTemplates where
  parseJSON = A.withObject "GetSmtpTemplates" $ \o ->
    GetSmtpTemplates
      <$> (o .:? "count")
      <*> (o .:? "templates")

-- | ToJSON GetSmtpTemplates
instance A.ToJSON GetSmtpTemplates where
  toJSON GetSmtpTemplates {..} =
   _omitNulls
      [ "count" .= getSmtpTemplatesCount
      , "templates" .= getSmtpTemplatesTemplates
      ]


-- | Construct a value of type 'GetSmtpTemplates' (by applying it's required fields, if any)
mkGetSmtpTemplates
  :: GetSmtpTemplates
mkGetSmtpTemplates =
  GetSmtpTemplates
  { getSmtpTemplatesCount = Nothing
  , getSmtpTemplatesTemplates = Nothing
  }

-- ** GetSsoToken
-- | GetSsoToken
data GetSsoToken = GetSsoToken
  { getSsoTokenToken :: !(Text) -- ^ /Required/ "token" - Session token. It will remain valid for a short period of time only.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSsoToken
instance A.FromJSON GetSsoToken where
  parseJSON = A.withObject "GetSsoToken" $ \o ->
    GetSsoToken
      <$> (o .:  "token")

-- | ToJSON GetSsoToken
instance A.ToJSON GetSsoToken where
  toJSON GetSsoToken {..} =
   _omitNulls
      [ "token" .= getSsoTokenToken
      ]


-- | Construct a value of type 'GetSsoToken' (by applying it's required fields, if any)
mkGetSsoToken
  :: Text -- ^ 'getSsoTokenToken': Session token. It will remain valid for a short period of time only.
  -> GetSsoToken
mkGetSsoToken getSsoTokenToken =
  GetSsoToken
  { getSsoTokenToken
  }

-- ** GetStatsByBrowser
-- | GetStatsByBrowser
data GetStatsByBrowser = GetStatsByBrowser
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetStatsByBrowser
instance A.FromJSON GetStatsByBrowser where
  parseJSON = A.withObject "GetStatsByBrowser" $ \o ->
    pure GetStatsByBrowser
      

-- | ToJSON GetStatsByBrowser
instance A.ToJSON GetStatsByBrowser where
  toJSON GetStatsByBrowser  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'GetStatsByBrowser' (by applying it's required fields, if any)
mkGetStatsByBrowser
  :: GetStatsByBrowser
mkGetStatsByBrowser =
  GetStatsByBrowser
  { 
  }

-- ** GetStatsByDevice
-- | GetStatsByDevice
data GetStatsByDevice = GetStatsByDevice
  { getStatsByDeviceDesktop :: !(Maybe (Map.Map String GetDeviceBrowserStats)) -- ^ "desktop" - Statistics of the campaign on the basis of desktop devices
  , getStatsByDeviceMobile :: !(Maybe (Map.Map String GetDeviceBrowserStats)) -- ^ "mobile" - Statistics of the campaign on the basis of mobile devices
  , getStatsByDeviceTablet :: !(Maybe (Map.Map String GetDeviceBrowserStats)) -- ^ "tablet" - Statistics of the campaign on the basis of tablet devices
  , getStatsByDeviceUnknown :: !(Maybe (Map.Map String GetDeviceBrowserStats)) -- ^ "unknown" - Statistics of the campaign on the basis of unknown devices
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetStatsByDevice
instance A.FromJSON GetStatsByDevice where
  parseJSON = A.withObject "GetStatsByDevice" $ \o ->
    GetStatsByDevice
      <$> (o .:? "desktop")
      <*> (o .:? "mobile")
      <*> (o .:? "tablet")
      <*> (o .:? "unknown")

-- | ToJSON GetStatsByDevice
instance A.ToJSON GetStatsByDevice where
  toJSON GetStatsByDevice {..} =
   _omitNulls
      [ "desktop" .= getStatsByDeviceDesktop
      , "mobile" .= getStatsByDeviceMobile
      , "tablet" .= getStatsByDeviceTablet
      , "unknown" .= getStatsByDeviceUnknown
      ]


-- | Construct a value of type 'GetStatsByDevice' (by applying it's required fields, if any)
mkGetStatsByDevice
  :: GetStatsByDevice
mkGetStatsByDevice =
  GetStatsByDevice
  { getStatsByDeviceDesktop = Nothing
  , getStatsByDeviceMobile = Nothing
  , getStatsByDeviceTablet = Nothing
  , getStatsByDeviceUnknown = Nothing
  }

-- ** GetStatsByDomain
-- | GetStatsByDomain
data GetStatsByDomain = GetStatsByDomain
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetStatsByDomain
instance A.FromJSON GetStatsByDomain where
  parseJSON = A.withObject "GetStatsByDomain" $ \o ->
    pure GetStatsByDomain
      

-- | ToJSON GetStatsByDomain
instance A.ToJSON GetStatsByDomain where
  toJSON GetStatsByDomain  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'GetStatsByDomain' (by applying it's required fields, if any)
mkGetStatsByDomain
  :: GetStatsByDomain
mkGetStatsByDomain =
  GetStatsByDomain
  { 
  }

-- ** GetTransacAggregatedSmsReport
-- | GetTransacAggregatedSmsReport
data GetTransacAggregatedSmsReport = GetTransacAggregatedSmsReport
  { getTransacAggregatedSmsReportRange :: !(Text) -- ^ /Required/ "range" - Time frame of the report
  , getTransacAggregatedSmsReportRequests :: !(Integer) -- ^ /Required/ "requests" - Number of requests for the timeframe
  , getTransacAggregatedSmsReportDelivered :: !(Integer) -- ^ /Required/ "delivered" - Number of delivered SMS for the timeframe
  , getTransacAggregatedSmsReportHardBounces :: !(Integer) -- ^ /Required/ "hardBounces" - Number of hardbounces for the timeframe
  , getTransacAggregatedSmsReportSoftBounces :: !(Integer) -- ^ /Required/ "softBounces" - Number of softbounces for the timeframe
  , getTransacAggregatedSmsReportBlocked :: !(Integer) -- ^ /Required/ "blocked" - Number of blocked contact for the timeframe
  , getTransacAggregatedSmsReportUnsubscribed :: !(Integer) -- ^ /Required/ "unsubscribed" - Number of unsubscription for the timeframe
  , getTransacAggregatedSmsReportReplied :: !(Integer) -- ^ /Required/ "replied" - Number of answered SMS for the timeframe
  , getTransacAggregatedSmsReportAccepted :: !(Integer) -- ^ /Required/ "accepted" - Number of accepted for the timeframe
  , getTransacAggregatedSmsReportRejected :: !(Integer) -- ^ /Required/ "rejected" - Number of rejected for the timeframe
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetTransacAggregatedSmsReport
instance A.FromJSON GetTransacAggregatedSmsReport where
  parseJSON = A.withObject "GetTransacAggregatedSmsReport" $ \o ->
    GetTransacAggregatedSmsReport
      <$> (o .:  "range")
      <*> (o .:  "requests")
      <*> (o .:  "delivered")
      <*> (o .:  "hardBounces")
      <*> (o .:  "softBounces")
      <*> (o .:  "blocked")
      <*> (o .:  "unsubscribed")
      <*> (o .:  "replied")
      <*> (o .:  "accepted")
      <*> (o .:  "rejected")

-- | ToJSON GetTransacAggregatedSmsReport
instance A.ToJSON GetTransacAggregatedSmsReport where
  toJSON GetTransacAggregatedSmsReport {..} =
   _omitNulls
      [ "range" .= getTransacAggregatedSmsReportRange
      , "requests" .= getTransacAggregatedSmsReportRequests
      , "delivered" .= getTransacAggregatedSmsReportDelivered
      , "hardBounces" .= getTransacAggregatedSmsReportHardBounces
      , "softBounces" .= getTransacAggregatedSmsReportSoftBounces
      , "blocked" .= getTransacAggregatedSmsReportBlocked
      , "unsubscribed" .= getTransacAggregatedSmsReportUnsubscribed
      , "replied" .= getTransacAggregatedSmsReportReplied
      , "accepted" .= getTransacAggregatedSmsReportAccepted
      , "rejected" .= getTransacAggregatedSmsReportRejected
      ]


-- | Construct a value of type 'GetTransacAggregatedSmsReport' (by applying it's required fields, if any)
mkGetTransacAggregatedSmsReport
  :: Text -- ^ 'getTransacAggregatedSmsReportRange': Time frame of the report
  -> Integer -- ^ 'getTransacAggregatedSmsReportRequests': Number of requests for the timeframe
  -> Integer -- ^ 'getTransacAggregatedSmsReportDelivered': Number of delivered SMS for the timeframe
  -> Integer -- ^ 'getTransacAggregatedSmsReportHardBounces': Number of hardbounces for the timeframe
  -> Integer -- ^ 'getTransacAggregatedSmsReportSoftBounces': Number of softbounces for the timeframe
  -> Integer -- ^ 'getTransacAggregatedSmsReportBlocked': Number of blocked contact for the timeframe
  -> Integer -- ^ 'getTransacAggregatedSmsReportUnsubscribed': Number of unsubscription for the timeframe
  -> Integer -- ^ 'getTransacAggregatedSmsReportReplied': Number of answered SMS for the timeframe
  -> Integer -- ^ 'getTransacAggregatedSmsReportAccepted': Number of accepted for the timeframe
  -> Integer -- ^ 'getTransacAggregatedSmsReportRejected': Number of rejected for the timeframe
  -> GetTransacAggregatedSmsReport
mkGetTransacAggregatedSmsReport getTransacAggregatedSmsReportRange getTransacAggregatedSmsReportRequests getTransacAggregatedSmsReportDelivered getTransacAggregatedSmsReportHardBounces getTransacAggregatedSmsReportSoftBounces getTransacAggregatedSmsReportBlocked getTransacAggregatedSmsReportUnsubscribed getTransacAggregatedSmsReportReplied getTransacAggregatedSmsReportAccepted getTransacAggregatedSmsReportRejected =
  GetTransacAggregatedSmsReport
  { getTransacAggregatedSmsReportRange
  , getTransacAggregatedSmsReportRequests
  , getTransacAggregatedSmsReportDelivered
  , getTransacAggregatedSmsReportHardBounces
  , getTransacAggregatedSmsReportSoftBounces
  , getTransacAggregatedSmsReportBlocked
  , getTransacAggregatedSmsReportUnsubscribed
  , getTransacAggregatedSmsReportReplied
  , getTransacAggregatedSmsReportAccepted
  , getTransacAggregatedSmsReportRejected
  }

-- ** GetTransacBlockedContacts
-- | GetTransacBlockedContacts
data GetTransacBlockedContacts = GetTransacBlockedContacts
  { getTransacBlockedContactsCount :: !(Maybe Integer) -- ^ "count" - Count of blocked or unsubscribed contact
  , getTransacBlockedContactsContacts :: !(Maybe [GetTransacBlockedContactsContacts]) -- ^ "contacts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetTransacBlockedContacts
instance A.FromJSON GetTransacBlockedContacts where
  parseJSON = A.withObject "GetTransacBlockedContacts" $ \o ->
    GetTransacBlockedContacts
      <$> (o .:? "count")
      <*> (o .:? "contacts")

-- | ToJSON GetTransacBlockedContacts
instance A.ToJSON GetTransacBlockedContacts where
  toJSON GetTransacBlockedContacts {..} =
   _omitNulls
      [ "count" .= getTransacBlockedContactsCount
      , "contacts" .= getTransacBlockedContactsContacts
      ]


-- | Construct a value of type 'GetTransacBlockedContacts' (by applying it's required fields, if any)
mkGetTransacBlockedContacts
  :: GetTransacBlockedContacts
mkGetTransacBlockedContacts =
  GetTransacBlockedContacts
  { getTransacBlockedContactsCount = Nothing
  , getTransacBlockedContactsContacts = Nothing
  }

-- ** GetTransacBlockedContactsContacts
-- | GetTransacBlockedContactsContacts
data GetTransacBlockedContactsContacts = GetTransacBlockedContactsContacts
  { getTransacBlockedContactsContactsEmail :: !(Text) -- ^ /Required/ "email" - Email address of the blocked or unsubscribed contact
  , getTransacBlockedContactsContactsSenderEmail :: !(Text) -- ^ /Required/ "senderEmail" - Sender email address of the blocked or unsubscribed contact
  , getTransacBlockedContactsContactsReason :: !(GetTransacBlockedContactsReason) -- ^ /Required/ "reason"
  , getTransacBlockedContactsContactsBlockedAt :: !(Date) -- ^ /Required/ "blockedAt" - Date when the contact was blocked or unsubscribed on
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetTransacBlockedContactsContacts
instance A.FromJSON GetTransacBlockedContactsContacts where
  parseJSON = A.withObject "GetTransacBlockedContactsContacts" $ \o ->
    GetTransacBlockedContactsContacts
      <$> (o .:  "email")
      <*> (o .:  "senderEmail")
      <*> (o .:  "reason")
      <*> (o .:  "blockedAt")

-- | ToJSON GetTransacBlockedContactsContacts
instance A.ToJSON GetTransacBlockedContactsContacts where
  toJSON GetTransacBlockedContactsContacts {..} =
   _omitNulls
      [ "email" .= getTransacBlockedContactsContactsEmail
      , "senderEmail" .= getTransacBlockedContactsContactsSenderEmail
      , "reason" .= getTransacBlockedContactsContactsReason
      , "blockedAt" .= getTransacBlockedContactsContactsBlockedAt
      ]


-- | Construct a value of type 'GetTransacBlockedContactsContacts' (by applying it's required fields, if any)
mkGetTransacBlockedContactsContacts
  :: Text -- ^ 'getTransacBlockedContactsContactsEmail': Email address of the blocked or unsubscribed contact
  -> Text -- ^ 'getTransacBlockedContactsContactsSenderEmail': Sender email address of the blocked or unsubscribed contact
  -> GetTransacBlockedContactsReason -- ^ 'getTransacBlockedContactsContactsReason' 
  -> Date -- ^ 'getTransacBlockedContactsContactsBlockedAt': Date when the contact was blocked or unsubscribed on
  -> GetTransacBlockedContactsContacts
mkGetTransacBlockedContactsContacts getTransacBlockedContactsContactsEmail getTransacBlockedContactsContactsSenderEmail getTransacBlockedContactsContactsReason getTransacBlockedContactsContactsBlockedAt =
  GetTransacBlockedContactsContacts
  { getTransacBlockedContactsContactsEmail
  , getTransacBlockedContactsContactsSenderEmail
  , getTransacBlockedContactsContactsReason
  , getTransacBlockedContactsContactsBlockedAt
  }

-- ** GetTransacBlockedContactsReason
-- | GetTransacBlockedContactsReason
-- Reason for blocking / unsubscribing
data GetTransacBlockedContactsReason = GetTransacBlockedContactsReason
  { getTransacBlockedContactsReasonCode :: !(Maybe E'Code2) -- ^ "code" - Reason code for blocking / unsubscribing (This code is safe for comparison)
  , getTransacBlockedContactsReasonMessage :: !(Maybe Text) -- ^ "message" - Reason for blocking / unsubscribing (This string is not safe for comparison)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetTransacBlockedContactsReason
instance A.FromJSON GetTransacBlockedContactsReason where
  parseJSON = A.withObject "GetTransacBlockedContactsReason" $ \o ->
    GetTransacBlockedContactsReason
      <$> (o .:? "code")
      <*> (o .:? "message")

-- | ToJSON GetTransacBlockedContactsReason
instance A.ToJSON GetTransacBlockedContactsReason where
  toJSON GetTransacBlockedContactsReason {..} =
   _omitNulls
      [ "code" .= getTransacBlockedContactsReasonCode
      , "message" .= getTransacBlockedContactsReasonMessage
      ]


-- | Construct a value of type 'GetTransacBlockedContactsReason' (by applying it's required fields, if any)
mkGetTransacBlockedContactsReason
  :: GetTransacBlockedContactsReason
mkGetTransacBlockedContactsReason =
  GetTransacBlockedContactsReason
  { getTransacBlockedContactsReasonCode = Nothing
  , getTransacBlockedContactsReasonMessage = Nothing
  }

-- ** GetTransacEmailContent
-- | GetTransacEmailContent
data GetTransacEmailContent = GetTransacEmailContent
  { getTransacEmailContentEmail :: !(Text) -- ^ /Required/ "email" - Email address to which transactional email has been sent
  , getTransacEmailContentSubject :: !(Text) -- ^ /Required/ "subject" - Subject of the sent email
  , getTransacEmailContentTemplateId :: !(Maybe Integer) -- ^ "templateId" - Id of the template
  , getTransacEmailContentDate :: !(DateTime) -- ^ /Required/ "date" - Date on which transactional email was sent
  , getTransacEmailContentEvents :: !([GetTransacEmailContentEvents]) -- ^ /Required/ "events" - Series of events which occurred on the transactional email
  , getTransacEmailContentBody :: !(Text) -- ^ /Required/ "body" - Actual content of the transactional email that has been sent
  , getTransacEmailContentAttachmentCount :: !(Integer) -- ^ /Required/ "attachmentCount" - Count of the attachments that were sent in the email
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetTransacEmailContent
instance A.FromJSON GetTransacEmailContent where
  parseJSON = A.withObject "GetTransacEmailContent" $ \o ->
    GetTransacEmailContent
      <$> (o .:  "email")
      <*> (o .:  "subject")
      <*> (o .:? "templateId")
      <*> (o .:  "date")
      <*> (o .:  "events")
      <*> (o .:  "body")
      <*> (o .:  "attachmentCount")

-- | ToJSON GetTransacEmailContent
instance A.ToJSON GetTransacEmailContent where
  toJSON GetTransacEmailContent {..} =
   _omitNulls
      [ "email" .= getTransacEmailContentEmail
      , "subject" .= getTransacEmailContentSubject
      , "templateId" .= getTransacEmailContentTemplateId
      , "date" .= getTransacEmailContentDate
      , "events" .= getTransacEmailContentEvents
      , "body" .= getTransacEmailContentBody
      , "attachmentCount" .= getTransacEmailContentAttachmentCount
      ]


-- | Construct a value of type 'GetTransacEmailContent' (by applying it's required fields, if any)
mkGetTransacEmailContent
  :: Text -- ^ 'getTransacEmailContentEmail': Email address to which transactional email has been sent
  -> Text -- ^ 'getTransacEmailContentSubject': Subject of the sent email
  -> DateTime -- ^ 'getTransacEmailContentDate': Date on which transactional email was sent
  -> [GetTransacEmailContentEvents] -- ^ 'getTransacEmailContentEvents': Series of events which occurred on the transactional email
  -> Text -- ^ 'getTransacEmailContentBody': Actual content of the transactional email that has been sent
  -> Integer -- ^ 'getTransacEmailContentAttachmentCount': Count of the attachments that were sent in the email
  -> GetTransacEmailContent
mkGetTransacEmailContent getTransacEmailContentEmail getTransacEmailContentSubject getTransacEmailContentDate getTransacEmailContentEvents getTransacEmailContentBody getTransacEmailContentAttachmentCount =
  GetTransacEmailContent
  { getTransacEmailContentEmail
  , getTransacEmailContentSubject
  , getTransacEmailContentTemplateId = Nothing
  , getTransacEmailContentDate
  , getTransacEmailContentEvents
  , getTransacEmailContentBody
  , getTransacEmailContentAttachmentCount
  }

-- ** GetTransacEmailContentEvents
-- | GetTransacEmailContentEvents
data GetTransacEmailContentEvents = GetTransacEmailContentEvents
  { getTransacEmailContentEventsName :: !(Text) -- ^ /Required/ "name" - Name of the event that occurred on the sent email
  , getTransacEmailContentEventsTime :: !(DateTime) -- ^ /Required/ "time" - Time at which the event occurred
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetTransacEmailContentEvents
instance A.FromJSON GetTransacEmailContentEvents where
  parseJSON = A.withObject "GetTransacEmailContentEvents" $ \o ->
    GetTransacEmailContentEvents
      <$> (o .:  "name")
      <*> (o .:  "time")

-- | ToJSON GetTransacEmailContentEvents
instance A.ToJSON GetTransacEmailContentEvents where
  toJSON GetTransacEmailContentEvents {..} =
   _omitNulls
      [ "name" .= getTransacEmailContentEventsName
      , "time" .= getTransacEmailContentEventsTime
      ]


-- | Construct a value of type 'GetTransacEmailContentEvents' (by applying it's required fields, if any)
mkGetTransacEmailContentEvents
  :: Text -- ^ 'getTransacEmailContentEventsName': Name of the event that occurred on the sent email
  -> DateTime -- ^ 'getTransacEmailContentEventsTime': Time at which the event occurred
  -> GetTransacEmailContentEvents
mkGetTransacEmailContentEvents getTransacEmailContentEventsName getTransacEmailContentEventsTime =
  GetTransacEmailContentEvents
  { getTransacEmailContentEventsName
  , getTransacEmailContentEventsTime
  }

-- ** GetTransacEmailsList
-- | GetTransacEmailsList
data GetTransacEmailsList = GetTransacEmailsList
  { getTransacEmailsListTransactionalEmails :: !(Maybe [GetTransacEmailsListTransactionalEmails]) -- ^ "transactionalEmails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetTransacEmailsList
instance A.FromJSON GetTransacEmailsList where
  parseJSON = A.withObject "GetTransacEmailsList" $ \o ->
    GetTransacEmailsList
      <$> (o .:? "transactionalEmails")

-- | ToJSON GetTransacEmailsList
instance A.ToJSON GetTransacEmailsList where
  toJSON GetTransacEmailsList {..} =
   _omitNulls
      [ "transactionalEmails" .= getTransacEmailsListTransactionalEmails
      ]


-- | Construct a value of type 'GetTransacEmailsList' (by applying it's required fields, if any)
mkGetTransacEmailsList
  :: GetTransacEmailsList
mkGetTransacEmailsList =
  GetTransacEmailsList
  { getTransacEmailsListTransactionalEmails = Nothing
  }

-- ** GetTransacEmailsListTransactionalEmails
-- | GetTransacEmailsListTransactionalEmails
data GetTransacEmailsListTransactionalEmails = GetTransacEmailsListTransactionalEmails
  { getTransacEmailsListTransactionalEmailsEmail :: !(Text) -- ^ /Required/ "email" - Email address to which transactional email has been sent
  , getTransacEmailsListTransactionalEmailsSubject :: !(Text) -- ^ /Required/ "subject" - Subject of the sent email
  , getTransacEmailsListTransactionalEmailsTemplateId :: !(Maybe Integer) -- ^ "templateId" - Id of the template
  , getTransacEmailsListTransactionalEmailsMessageId :: !(Text) -- ^ /Required/ "messageId" - Message Id of the sent email
  , getTransacEmailsListTransactionalEmailsUuid :: !(Text) -- ^ /Required/ "uuid" - Unique id of the email sent to a particular contact
  , getTransacEmailsListTransactionalEmailsDate :: !(DateTime) -- ^ /Required/ "date" - Date on which transactional email was sent
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetTransacEmailsListTransactionalEmails
instance A.FromJSON GetTransacEmailsListTransactionalEmails where
  parseJSON = A.withObject "GetTransacEmailsListTransactionalEmails" $ \o ->
    GetTransacEmailsListTransactionalEmails
      <$> (o .:  "email")
      <*> (o .:  "subject")
      <*> (o .:? "templateId")
      <*> (o .:  "messageId")
      <*> (o .:  "uuid")
      <*> (o .:  "date")

-- | ToJSON GetTransacEmailsListTransactionalEmails
instance A.ToJSON GetTransacEmailsListTransactionalEmails where
  toJSON GetTransacEmailsListTransactionalEmails {..} =
   _omitNulls
      [ "email" .= getTransacEmailsListTransactionalEmailsEmail
      , "subject" .= getTransacEmailsListTransactionalEmailsSubject
      , "templateId" .= getTransacEmailsListTransactionalEmailsTemplateId
      , "messageId" .= getTransacEmailsListTransactionalEmailsMessageId
      , "uuid" .= getTransacEmailsListTransactionalEmailsUuid
      , "date" .= getTransacEmailsListTransactionalEmailsDate
      ]


-- | Construct a value of type 'GetTransacEmailsListTransactionalEmails' (by applying it's required fields, if any)
mkGetTransacEmailsListTransactionalEmails
  :: Text -- ^ 'getTransacEmailsListTransactionalEmailsEmail': Email address to which transactional email has been sent
  -> Text -- ^ 'getTransacEmailsListTransactionalEmailsSubject': Subject of the sent email
  -> Text -- ^ 'getTransacEmailsListTransactionalEmailsMessageId': Message Id of the sent email
  -> Text -- ^ 'getTransacEmailsListTransactionalEmailsUuid': Unique id of the email sent to a particular contact
  -> DateTime -- ^ 'getTransacEmailsListTransactionalEmailsDate': Date on which transactional email was sent
  -> GetTransacEmailsListTransactionalEmails
mkGetTransacEmailsListTransactionalEmails getTransacEmailsListTransactionalEmailsEmail getTransacEmailsListTransactionalEmailsSubject getTransacEmailsListTransactionalEmailsMessageId getTransacEmailsListTransactionalEmailsUuid getTransacEmailsListTransactionalEmailsDate =
  GetTransacEmailsListTransactionalEmails
  { getTransacEmailsListTransactionalEmailsEmail
  , getTransacEmailsListTransactionalEmailsSubject
  , getTransacEmailsListTransactionalEmailsTemplateId = Nothing
  , getTransacEmailsListTransactionalEmailsMessageId
  , getTransacEmailsListTransactionalEmailsUuid
  , getTransacEmailsListTransactionalEmailsDate
  }

-- ** GetTransacSmsReport
-- | GetTransacSmsReport
data GetTransacSmsReport = GetTransacSmsReport
  { getTransacSmsReportReports :: !(Maybe [GetTransacSmsReportReports]) -- ^ "reports"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetTransacSmsReport
instance A.FromJSON GetTransacSmsReport where
  parseJSON = A.withObject "GetTransacSmsReport" $ \o ->
    GetTransacSmsReport
      <$> (o .:? "reports")

-- | ToJSON GetTransacSmsReport
instance A.ToJSON GetTransacSmsReport where
  toJSON GetTransacSmsReport {..} =
   _omitNulls
      [ "reports" .= getTransacSmsReportReports
      ]


-- | Construct a value of type 'GetTransacSmsReport' (by applying it's required fields, if any)
mkGetTransacSmsReport
  :: GetTransacSmsReport
mkGetTransacSmsReport =
  GetTransacSmsReport
  { getTransacSmsReportReports = Nothing
  }

-- ** GetTransacSmsReportReports
-- | GetTransacSmsReportReports
data GetTransacSmsReportReports = GetTransacSmsReportReports
  { getTransacSmsReportReportsDate :: !(Date) -- ^ /Required/ "date" - Date for which statistics are retrieved
  , getTransacSmsReportReportsRequests :: !(Integer) -- ^ /Required/ "requests" - Number of requests for the date
  , getTransacSmsReportReportsDelivered :: !(Integer) -- ^ /Required/ "delivered" - Number of delivered SMS for the date
  , getTransacSmsReportReportsHardBounces :: !(Integer) -- ^ /Required/ "hardBounces" - Number of hardbounces for the date
  , getTransacSmsReportReportsSoftBounces :: !(Integer) -- ^ /Required/ "softBounces" - Number of softbounces for the date
  , getTransacSmsReportReportsBlocked :: !(Integer) -- ^ /Required/ "blocked" - Number of blocked contact for the date
  , getTransacSmsReportReportsUnsubscribed :: !(Integer) -- ^ /Required/ "unsubscribed" - Number of unsubscription for the date
  , getTransacSmsReportReportsReplied :: !(Integer) -- ^ /Required/ "replied" - Number of answered SMS for the date
  , getTransacSmsReportReportsAccepted :: !(Integer) -- ^ /Required/ "accepted" - Number of accepted for the date
  , getTransacSmsReportReportsRejected :: !(Integer) -- ^ /Required/ "rejected" - Number of rejected for the date
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetTransacSmsReportReports
instance A.FromJSON GetTransacSmsReportReports where
  parseJSON = A.withObject "GetTransacSmsReportReports" $ \o ->
    GetTransacSmsReportReports
      <$> (o .:  "date")
      <*> (o .:  "requests")
      <*> (o .:  "delivered")
      <*> (o .:  "hardBounces")
      <*> (o .:  "softBounces")
      <*> (o .:  "blocked")
      <*> (o .:  "unsubscribed")
      <*> (o .:  "replied")
      <*> (o .:  "accepted")
      <*> (o .:  "rejected")

-- | ToJSON GetTransacSmsReportReports
instance A.ToJSON GetTransacSmsReportReports where
  toJSON GetTransacSmsReportReports {..} =
   _omitNulls
      [ "date" .= getTransacSmsReportReportsDate
      , "requests" .= getTransacSmsReportReportsRequests
      , "delivered" .= getTransacSmsReportReportsDelivered
      , "hardBounces" .= getTransacSmsReportReportsHardBounces
      , "softBounces" .= getTransacSmsReportReportsSoftBounces
      , "blocked" .= getTransacSmsReportReportsBlocked
      , "unsubscribed" .= getTransacSmsReportReportsUnsubscribed
      , "replied" .= getTransacSmsReportReportsReplied
      , "accepted" .= getTransacSmsReportReportsAccepted
      , "rejected" .= getTransacSmsReportReportsRejected
      ]


-- | Construct a value of type 'GetTransacSmsReportReports' (by applying it's required fields, if any)
mkGetTransacSmsReportReports
  :: Date -- ^ 'getTransacSmsReportReportsDate': Date for which statistics are retrieved
  -> Integer -- ^ 'getTransacSmsReportReportsRequests': Number of requests for the date
  -> Integer -- ^ 'getTransacSmsReportReportsDelivered': Number of delivered SMS for the date
  -> Integer -- ^ 'getTransacSmsReportReportsHardBounces': Number of hardbounces for the date
  -> Integer -- ^ 'getTransacSmsReportReportsSoftBounces': Number of softbounces for the date
  -> Integer -- ^ 'getTransacSmsReportReportsBlocked': Number of blocked contact for the date
  -> Integer -- ^ 'getTransacSmsReportReportsUnsubscribed': Number of unsubscription for the date
  -> Integer -- ^ 'getTransacSmsReportReportsReplied': Number of answered SMS for the date
  -> Integer -- ^ 'getTransacSmsReportReportsAccepted': Number of accepted for the date
  -> Integer -- ^ 'getTransacSmsReportReportsRejected': Number of rejected for the date
  -> GetTransacSmsReportReports
mkGetTransacSmsReportReports getTransacSmsReportReportsDate getTransacSmsReportReportsRequests getTransacSmsReportReportsDelivered getTransacSmsReportReportsHardBounces getTransacSmsReportReportsSoftBounces getTransacSmsReportReportsBlocked getTransacSmsReportReportsUnsubscribed getTransacSmsReportReportsReplied getTransacSmsReportReportsAccepted getTransacSmsReportReportsRejected =
  GetTransacSmsReportReports
  { getTransacSmsReportReportsDate
  , getTransacSmsReportReportsRequests
  , getTransacSmsReportReportsDelivered
  , getTransacSmsReportReportsHardBounces
  , getTransacSmsReportReportsSoftBounces
  , getTransacSmsReportReportsBlocked
  , getTransacSmsReportReportsUnsubscribed
  , getTransacSmsReportReportsReplied
  , getTransacSmsReportReportsAccepted
  , getTransacSmsReportReportsRejected
  }

-- ** GetWebhook
-- | GetWebhook
data GetWebhook = GetWebhook
  { getWebhookUrl :: !(Text) -- ^ /Required/ "url" - URL of the webhook
  , getWebhookId :: !(Integer) -- ^ /Required/ "id" - ID of the webhook
  , getWebhookDescription :: !(Text) -- ^ /Required/ "description" - Description of the webhook
  , getWebhookEvents :: !([Text]) -- ^ /Required/ "events"
  , getWebhookType :: !(E'Type2) -- ^ /Required/ "type" - Type of webhook (marketing or transac)
  , getWebhookCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Creation UTC date-time of the webhook (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getWebhookModifiedAt :: !(DateTime) -- ^ /Required/ "modifiedAt" - Last modification UTC date-time of the webhook (YYYY-MM-DDTHH:mm:ss.SSSZ)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetWebhook
instance A.FromJSON GetWebhook where
  parseJSON = A.withObject "GetWebhook" $ \o ->
    GetWebhook
      <$> (o .:  "url")
      <*> (o .:  "id")
      <*> (o .:  "description")
      <*> (o .:  "events")
      <*> (o .:  "type")
      <*> (o .:  "createdAt")
      <*> (o .:  "modifiedAt")

-- | ToJSON GetWebhook
instance A.ToJSON GetWebhook where
  toJSON GetWebhook {..} =
   _omitNulls
      [ "url" .= getWebhookUrl
      , "id" .= getWebhookId
      , "description" .= getWebhookDescription
      , "events" .= getWebhookEvents
      , "type" .= getWebhookType
      , "createdAt" .= getWebhookCreatedAt
      , "modifiedAt" .= getWebhookModifiedAt
      ]


-- | Construct a value of type 'GetWebhook' (by applying it's required fields, if any)
mkGetWebhook
  :: Text -- ^ 'getWebhookUrl': URL of the webhook
  -> Integer -- ^ 'getWebhookId': ID of the webhook
  -> Text -- ^ 'getWebhookDescription': Description of the webhook
  -> [Text] -- ^ 'getWebhookEvents' 
  -> E'Type2 -- ^ 'getWebhookType': Type of webhook (marketing or transac)
  -> DateTime -- ^ 'getWebhookCreatedAt': Creation UTC date-time of the webhook (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> DateTime -- ^ 'getWebhookModifiedAt': Last modification UTC date-time of the webhook (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> GetWebhook
mkGetWebhook getWebhookUrl getWebhookId getWebhookDescription getWebhookEvents getWebhookType getWebhookCreatedAt getWebhookModifiedAt =
  GetWebhook
  { getWebhookUrl
  , getWebhookId
  , getWebhookDescription
  , getWebhookEvents
  , getWebhookType
  , getWebhookCreatedAt
  , getWebhookModifiedAt
  }

-- ** GetWebhooks
-- | GetWebhooks
data GetWebhooks = GetWebhooks
  { getWebhooksWebhooks :: !([A.Value]) -- ^ /Required/ "webhooks"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetWebhooks
instance A.FromJSON GetWebhooks where
  parseJSON = A.withObject "GetWebhooks" $ \o ->
    GetWebhooks
      <$> (o .:  "webhooks")

-- | ToJSON GetWebhooks
instance A.ToJSON GetWebhooks where
  toJSON GetWebhooks {..} =
   _omitNulls
      [ "webhooks" .= getWebhooksWebhooks
      ]


-- | Construct a value of type 'GetWebhooks' (by applying it's required fields, if any)
mkGetWebhooks
  :: [A.Value] -- ^ 'getWebhooksWebhooks' 
  -> GetWebhooks
mkGetWebhooks getWebhooksWebhooks =
  GetWebhooks
  { getWebhooksWebhooks
  }

-- ** ManageIp
-- | ManageIp
data ManageIp = ManageIp
  { manageIpIp :: !(Maybe Text) -- ^ "ip" - Dedicated ID
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ManageIp
instance A.FromJSON ManageIp where
  parseJSON = A.withObject "ManageIp" $ \o ->
    ManageIp
      <$> (o .:? "ip")

-- | ToJSON ManageIp
instance A.ToJSON ManageIp where
  toJSON ManageIp {..} =
   _omitNulls
      [ "ip" .= manageIpIp
      ]


-- | Construct a value of type 'ManageIp' (by applying it's required fields, if any)
mkManageIp
  :: ManageIp
mkManageIp =
  ManageIp
  { manageIpIp = Nothing
  }

-- ** PostContactInfo
-- | PostContactInfo
data PostContactInfo = PostContactInfo
  { postContactInfoContacts :: !(PostContactInfoContacts) -- ^ /Required/ "contacts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PostContactInfo
instance A.FromJSON PostContactInfo where
  parseJSON = A.withObject "PostContactInfo" $ \o ->
    PostContactInfo
      <$> (o .:  "contacts")

-- | ToJSON PostContactInfo
instance A.ToJSON PostContactInfo where
  toJSON PostContactInfo {..} =
   _omitNulls
      [ "contacts" .= postContactInfoContacts
      ]


-- | Construct a value of type 'PostContactInfo' (by applying it's required fields, if any)
mkPostContactInfo
  :: PostContactInfoContacts -- ^ 'postContactInfoContacts' 
  -> PostContactInfo
mkPostContactInfo postContactInfoContacts =
  PostContactInfo
  { postContactInfoContacts
  }

-- ** PostContactInfoContacts
-- | PostContactInfoContacts
data PostContactInfoContacts = PostContactInfoContacts
  { postContactInfoContactsSuccess :: !(Maybe [Text]) -- ^ "success"
  , postContactInfoContactsFailure :: !(Maybe [Text]) -- ^ "failure"
  , postContactInfoContactsTotal :: !(Maybe Integer) -- ^ "total" - Displays the count of total number of contacts removed from list when user opts for \&quot;all\&quot; option.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PostContactInfoContacts
instance A.FromJSON PostContactInfoContacts where
  parseJSON = A.withObject "PostContactInfoContacts" $ \o ->
    PostContactInfoContacts
      <$> (o .:? "success")
      <*> (o .:? "failure")
      <*> (o .:? "total")

-- | ToJSON PostContactInfoContacts
instance A.ToJSON PostContactInfoContacts where
  toJSON PostContactInfoContacts {..} =
   _omitNulls
      [ "success" .= postContactInfoContactsSuccess
      , "failure" .= postContactInfoContactsFailure
      , "total" .= postContactInfoContactsTotal
      ]


-- | Construct a value of type 'PostContactInfoContacts' (by applying it's required fields, if any)
mkPostContactInfoContacts
  :: PostContactInfoContacts
mkPostContactInfoContacts =
  PostContactInfoContacts
  { postContactInfoContactsSuccess = Nothing
  , postContactInfoContactsFailure = Nothing
  , postContactInfoContactsTotal = Nothing
  }

-- ** PostSendFailed
-- | PostSendFailed
data PostSendFailed = PostSendFailed
  { postSendFailedCode :: !(Integer) -- ^ /Required/ "code" - Response code
  , postSendFailedMessage :: !(Text) -- ^ /Required/ "message" - Response message
  , postSendFailedUnexistingEmails :: !(Maybe [Text]) -- ^ "unexistingEmails"
  , postSendFailedWithoutListEmails :: !(Maybe [Text]) -- ^ "withoutListEmails"
  , postSendFailedBlackListedEmails :: !(Maybe [Text]) -- ^ "blackListedEmails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PostSendFailed
instance A.FromJSON PostSendFailed where
  parseJSON = A.withObject "PostSendFailed" $ \o ->
    PostSendFailed
      <$> (o .:  "code")
      <*> (o .:  "message")
      <*> (o .:? "unexistingEmails")
      <*> (o .:? "withoutListEmails")
      <*> (o .:? "blackListedEmails")

-- | ToJSON PostSendFailed
instance A.ToJSON PostSendFailed where
  toJSON PostSendFailed {..} =
   _omitNulls
      [ "code" .= postSendFailedCode
      , "message" .= postSendFailedMessage
      , "unexistingEmails" .= postSendFailedUnexistingEmails
      , "withoutListEmails" .= postSendFailedWithoutListEmails
      , "blackListedEmails" .= postSendFailedBlackListedEmails
      ]


-- | Construct a value of type 'PostSendFailed' (by applying it's required fields, if any)
mkPostSendFailed
  :: Integer -- ^ 'postSendFailedCode': Response code
  -> Text -- ^ 'postSendFailedMessage': Response message
  -> PostSendFailed
mkPostSendFailed postSendFailedCode postSendFailedMessage =
  PostSendFailed
  { postSendFailedCode
  , postSendFailedMessage
  , postSendFailedUnexistingEmails = Nothing
  , postSendFailedWithoutListEmails = Nothing
  , postSendFailedBlackListedEmails = Nothing
  }

-- ** PostSendSmsTestFailed
-- | PostSendSmsTestFailed
data PostSendSmsTestFailed = PostSendSmsTestFailed
  { postSendSmsTestFailedCode :: !(Integer) -- ^ /Required/ "code" - Response code
  , postSendSmsTestFailedMessage :: !(Text) -- ^ /Required/ "message" - Response message
  , postSendSmsTestFailedUnexistingSms :: !(Maybe [Text]) -- ^ "unexistingSms"
  , postSendSmsTestFailedWithoutListSms :: !(Maybe [Text]) -- ^ "withoutListSms"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PostSendSmsTestFailed
instance A.FromJSON PostSendSmsTestFailed where
  parseJSON = A.withObject "PostSendSmsTestFailed" $ \o ->
    PostSendSmsTestFailed
      <$> (o .:  "code")
      <*> (o .:  "message")
      <*> (o .:? "unexistingSms")
      <*> (o .:? "withoutListSms")

-- | ToJSON PostSendSmsTestFailed
instance A.ToJSON PostSendSmsTestFailed where
  toJSON PostSendSmsTestFailed {..} =
   _omitNulls
      [ "code" .= postSendSmsTestFailedCode
      , "message" .= postSendSmsTestFailedMessage
      , "unexistingSms" .= postSendSmsTestFailedUnexistingSms
      , "withoutListSms" .= postSendSmsTestFailedWithoutListSms
      ]


-- | Construct a value of type 'PostSendSmsTestFailed' (by applying it's required fields, if any)
mkPostSendSmsTestFailed
  :: Integer -- ^ 'postSendSmsTestFailedCode': Response code
  -> Text -- ^ 'postSendSmsTestFailedMessage': Response message
  -> PostSendSmsTestFailed
mkPostSendSmsTestFailed postSendSmsTestFailedCode postSendSmsTestFailedMessage =
  PostSendSmsTestFailed
  { postSendSmsTestFailedCode
  , postSendSmsTestFailedMessage
  , postSendSmsTestFailedUnexistingSms = Nothing
  , postSendSmsTestFailedWithoutListSms = Nothing
  }

-- ** RemainingCreditModel
-- | RemainingCreditModel
data RemainingCreditModel = RemainingCreditModel
  { remainingCreditModelChild :: !(RemainingCreditModelChild) -- ^ /Required/ "child"
  , remainingCreditModelReseller :: !(RemainingCreditModelReseller) -- ^ /Required/ "reseller"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RemainingCreditModel
instance A.FromJSON RemainingCreditModel where
  parseJSON = A.withObject "RemainingCreditModel" $ \o ->
    RemainingCreditModel
      <$> (o .:  "child")
      <*> (o .:  "reseller")

-- | ToJSON RemainingCreditModel
instance A.ToJSON RemainingCreditModel where
  toJSON RemainingCreditModel {..} =
   _omitNulls
      [ "child" .= remainingCreditModelChild
      , "reseller" .= remainingCreditModelReseller
      ]


-- | Construct a value of type 'RemainingCreditModel' (by applying it's required fields, if any)
mkRemainingCreditModel
  :: RemainingCreditModelChild -- ^ 'remainingCreditModelChild' 
  -> RemainingCreditModelReseller -- ^ 'remainingCreditModelReseller' 
  -> RemainingCreditModel
mkRemainingCreditModel remainingCreditModelChild remainingCreditModelReseller =
  RemainingCreditModel
  { remainingCreditModelChild
  , remainingCreditModelReseller
  }

-- ** RemainingCreditModelChild
-- | RemainingCreditModelChild
-- Credits remaining for child account
data RemainingCreditModelChild = RemainingCreditModelChild
  { remainingCreditModelChildSms :: !(Integer) -- ^ /Required/ "sms" - SMS Credits remaining for child account
  , remainingCreditModelChildEmail :: !(Integer) -- ^ /Required/ "email" - Email Credits remaining for child account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RemainingCreditModelChild
instance A.FromJSON RemainingCreditModelChild where
  parseJSON = A.withObject "RemainingCreditModelChild" $ \o ->
    RemainingCreditModelChild
      <$> (o .:  "sms")
      <*> (o .:  "email")

-- | ToJSON RemainingCreditModelChild
instance A.ToJSON RemainingCreditModelChild where
  toJSON RemainingCreditModelChild {..} =
   _omitNulls
      [ "sms" .= remainingCreditModelChildSms
      , "email" .= remainingCreditModelChildEmail
      ]


-- | Construct a value of type 'RemainingCreditModelChild' (by applying it's required fields, if any)
mkRemainingCreditModelChild
  :: Integer -- ^ 'remainingCreditModelChildSms': SMS Credits remaining for child account
  -> Integer -- ^ 'remainingCreditModelChildEmail': Email Credits remaining for child account
  -> RemainingCreditModelChild
mkRemainingCreditModelChild remainingCreditModelChildSms remainingCreditModelChildEmail =
  RemainingCreditModelChild
  { remainingCreditModelChildSms
  , remainingCreditModelChildEmail
  }

-- ** RemainingCreditModelReseller
-- | RemainingCreditModelReseller
data RemainingCreditModelReseller = RemainingCreditModelReseller
  { remainingCreditModelResellerSms :: !(Integer) -- ^ /Required/ "sms" - SMS Credits remaining for reseller account
  , remainingCreditModelResellerEmail :: !(Integer) -- ^ /Required/ "email" - Email Credits remaining for reseller account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RemainingCreditModelReseller
instance A.FromJSON RemainingCreditModelReseller where
  parseJSON = A.withObject "RemainingCreditModelReseller" $ \o ->
    RemainingCreditModelReseller
      <$> (o .:  "sms")
      <*> (o .:  "email")

-- | ToJSON RemainingCreditModelReseller
instance A.ToJSON RemainingCreditModelReseller where
  toJSON RemainingCreditModelReseller {..} =
   _omitNulls
      [ "sms" .= remainingCreditModelResellerSms
      , "email" .= remainingCreditModelResellerEmail
      ]


-- | Construct a value of type 'RemainingCreditModelReseller' (by applying it's required fields, if any)
mkRemainingCreditModelReseller
  :: Integer -- ^ 'remainingCreditModelResellerSms': SMS Credits remaining for reseller account
  -> Integer -- ^ 'remainingCreditModelResellerEmail': Email Credits remaining for reseller account
  -> RemainingCreditModelReseller
mkRemainingCreditModelReseller remainingCreditModelResellerSms remainingCreditModelResellerEmail =
  RemainingCreditModelReseller
  { remainingCreditModelResellerSms
  , remainingCreditModelResellerEmail
  }

-- ** RemoveContactFromList
-- | RemoveContactFromList
data RemoveContactFromList = RemoveContactFromList
  { removeContactFromListEmails :: !(Maybe [Text]) -- ^ "emails" - Required if &#39;all&#39; is false. Emails to remove from a list
  , removeContactFromListAll :: !(Maybe Bool) -- ^ "all" - Required if &#39;emails&#39; is empty. Remove all existing contacts from a list
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RemoveContactFromList
instance A.FromJSON RemoveContactFromList where
  parseJSON = A.withObject "RemoveContactFromList" $ \o ->
    RemoveContactFromList
      <$> (o .:? "emails")
      <*> (o .:? "all")

-- | ToJSON RemoveContactFromList
instance A.ToJSON RemoveContactFromList where
  toJSON RemoveContactFromList {..} =
   _omitNulls
      [ "emails" .= removeContactFromListEmails
      , "all" .= removeContactFromListAll
      ]


-- | Construct a value of type 'RemoveContactFromList' (by applying it's required fields, if any)
mkRemoveContactFromList
  :: RemoveContactFromList
mkRemoveContactFromList =
  RemoveContactFromList
  { removeContactFromListEmails = Nothing
  , removeContactFromListAll = Nothing
  }

-- ** RemoveCredits
-- | RemoveCredits
data RemoveCredits = RemoveCredits
  { removeCreditsSms :: !(Maybe Integer) -- ^ "sms" - Required if email credits are empty. SMS credits to be removed from the child account
  , removeCreditsEmail :: !(Maybe Integer) -- ^ "email" - Required if sms credits are empty. Email credits to be removed from the child account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RemoveCredits
instance A.FromJSON RemoveCredits where
  parseJSON = A.withObject "RemoveCredits" $ \o ->
    RemoveCredits
      <$> (o .:? "sms")
      <*> (o .:? "email")

-- | ToJSON RemoveCredits
instance A.ToJSON RemoveCredits where
  toJSON RemoveCredits {..} =
   _omitNulls
      [ "sms" .= removeCreditsSms
      , "email" .= removeCreditsEmail
      ]


-- | Construct a value of type 'RemoveCredits' (by applying it's required fields, if any)
mkRemoveCredits
  :: RemoveCredits
mkRemoveCredits =
  RemoveCredits
  { removeCreditsSms = Nothing
  , removeCreditsEmail = Nothing
  }

-- ** RequestContactExport
-- | RequestContactExport
data RequestContactExport = RequestContactExport
  { requestContactExportExportAttributes :: !(Maybe [Text]) -- ^ "exportAttributes" - List of all the attributes that you want to export. These attributes must be present in your contact database. For example, [&#39;fname&#39;, &#39;lname&#39;, &#39;email&#39;].
  , requestContactExportContactFilter :: !(A.Value) -- ^ /Required/ "contactFilter" - Set the filter for the contacts to be exported. For example, {&#39;blacklisted&#39;:true} will export all the blacklisted contacts.
  , requestContactExportNotifyUrl :: !(Maybe Text) -- ^ "notifyUrl" - Webhook that will be called once the export process is finished
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestContactExport
instance A.FromJSON RequestContactExport where
  parseJSON = A.withObject "RequestContactExport" $ \o ->
    RequestContactExport
      <$> (o .:? "exportAttributes")
      <*> (o .:  "contactFilter")
      <*> (o .:? "notifyUrl")

-- | ToJSON RequestContactExport
instance A.ToJSON RequestContactExport where
  toJSON RequestContactExport {..} =
   _omitNulls
      [ "exportAttributes" .= requestContactExportExportAttributes
      , "contactFilter" .= requestContactExportContactFilter
      , "notifyUrl" .= requestContactExportNotifyUrl
      ]


-- | Construct a value of type 'RequestContactExport' (by applying it's required fields, if any)
mkRequestContactExport
  :: A.Value -- ^ 'requestContactExportContactFilter': Set the filter for the contacts to be exported. For example, {'blacklisted':true} will export all the blacklisted contacts.
  -> RequestContactExport
mkRequestContactExport requestContactExportContactFilter =
  RequestContactExport
  { requestContactExportExportAttributes = Nothing
  , requestContactExportContactFilter
  , requestContactExportNotifyUrl = Nothing
  }

-- ** RequestContactImport
-- | RequestContactImport
data RequestContactImport = RequestContactImport
  { requestContactImportFileUrl :: !(Maybe Text) -- ^ "fileUrl" - Mandatory if fileBody is not defined. URL of the file to be imported (no local file). Possible file formats: .txt, .csv
  , requestContactImportFileBody :: !(Maybe Text) -- ^ "fileBody" - Mandatory if fileUrl is not defined. CSV content to be imported. Use semicolon to separate multiple attributes
  , requestContactImportListIds :: !(Maybe [Integer]) -- ^ "listIds" - Mandatory if newList is not defined. Ids of the lists in which the contacts shall be imported. For example, [2, 4, 7].
  , requestContactImportNotifyUrl :: !(Maybe Text) -- ^ "notifyUrl" - URL that will be called once the export process is finished
  , requestContactImportNewList :: !(Maybe RequestContactImportNewList) -- ^ "newList"
  , requestContactImportEmailBlacklist :: !(Maybe Bool) -- ^ "emailBlacklist" - To blacklist all the contacts for email
  , requestContactImportSmsBlacklist :: !(Maybe Bool) -- ^ "smsBlacklist" - To blacklist all the contacts for sms
  , requestContactImportUpdateExistingContacts :: !(Maybe Bool) -- ^ "updateExistingContacts" - To facilitate the choice to update the existing contacts
  , requestContactImportEmptyContactsAttributes :: !(Maybe Bool) -- ^ "emptyContactsAttributes" - To facilitate the choice to erase any attribute of the existing contacts with empty value. emptyContactsAttributes &#x3D; true means the empty fields in your import will erase any attribute that currently contain data in SendinBlue, &amp; emptyContactsAttributes &#x3D; false means the empty fields will not affect your existing data ( only available if &#x60;updateExistingContacts&#x60; set to true )
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestContactImport
instance A.FromJSON RequestContactImport where
  parseJSON = A.withObject "RequestContactImport" $ \o ->
    RequestContactImport
      <$> (o .:? "fileUrl")
      <*> (o .:? "fileBody")
      <*> (o .:? "listIds")
      <*> (o .:? "notifyUrl")
      <*> (o .:? "newList")
      <*> (o .:? "emailBlacklist")
      <*> (o .:? "smsBlacklist")
      <*> (o .:? "updateExistingContacts")
      <*> (o .:? "emptyContactsAttributes")

-- | ToJSON RequestContactImport
instance A.ToJSON RequestContactImport where
  toJSON RequestContactImport {..} =
   _omitNulls
      [ "fileUrl" .= requestContactImportFileUrl
      , "fileBody" .= requestContactImportFileBody
      , "listIds" .= requestContactImportListIds
      , "notifyUrl" .= requestContactImportNotifyUrl
      , "newList" .= requestContactImportNewList
      , "emailBlacklist" .= requestContactImportEmailBlacklist
      , "smsBlacklist" .= requestContactImportSmsBlacklist
      , "updateExistingContacts" .= requestContactImportUpdateExistingContacts
      , "emptyContactsAttributes" .= requestContactImportEmptyContactsAttributes
      ]


-- | Construct a value of type 'RequestContactImport' (by applying it's required fields, if any)
mkRequestContactImport
  :: RequestContactImport
mkRequestContactImport =
  RequestContactImport
  { requestContactImportFileUrl = Nothing
  , requestContactImportFileBody = Nothing
  , requestContactImportListIds = Nothing
  , requestContactImportNotifyUrl = Nothing
  , requestContactImportNewList = Nothing
  , requestContactImportEmailBlacklist = Nothing
  , requestContactImportSmsBlacklist = Nothing
  , requestContactImportUpdateExistingContacts = Nothing
  , requestContactImportEmptyContactsAttributes = Nothing
  }

-- ** RequestContactImportNewList
-- | RequestContactImportNewList
-- To create a new list and import the contacts into it, pass the listName and an optional folderId.
data RequestContactImportNewList = RequestContactImportNewList
  { requestContactImportNewListListName :: !(Maybe Text) -- ^ "listName" - List with listName will be created first and users will be imported in it (Mandatory if listIds is empty).
  , requestContactImportNewListFolderId :: !(Maybe Integer) -- ^ "folderId" - Id of the folder where this new list shall be created (Mandatory if listName is not empty).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestContactImportNewList
instance A.FromJSON RequestContactImportNewList where
  parseJSON = A.withObject "RequestContactImportNewList" $ \o ->
    RequestContactImportNewList
      <$> (o .:? "listName")
      <*> (o .:? "folderId")

-- | ToJSON RequestContactImportNewList
instance A.ToJSON RequestContactImportNewList where
  toJSON RequestContactImportNewList {..} =
   _omitNulls
      [ "listName" .= requestContactImportNewListListName
      , "folderId" .= requestContactImportNewListFolderId
      ]


-- | Construct a value of type 'RequestContactImportNewList' (by applying it's required fields, if any)
mkRequestContactImportNewList
  :: RequestContactImportNewList
mkRequestContactImportNewList =
  RequestContactImportNewList
  { requestContactImportNewListListName = Nothing
  , requestContactImportNewListFolderId = Nothing
  }

-- ** RequestSmsRecipientExport
-- | RequestSmsRecipientExport
data RequestSmsRecipientExport = RequestSmsRecipientExport
  { requestSmsRecipientExportNotifyUrl :: !(Maybe Text) -- ^ "notifyURL" - URL that will be called once the export process is finished
  , requestSmsRecipientExportRecipientsType :: !(E'RecipientsType2) -- ^ /Required/ "recipientsType" - Filter the recipients based on how they interacted with the campaign
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestSmsRecipientExport
instance A.FromJSON RequestSmsRecipientExport where
  parseJSON = A.withObject "RequestSmsRecipientExport" $ \o ->
    RequestSmsRecipientExport
      <$> (o .:? "notifyURL")
      <*> (o .:  "recipientsType")

-- | ToJSON RequestSmsRecipientExport
instance A.ToJSON RequestSmsRecipientExport where
  toJSON RequestSmsRecipientExport {..} =
   _omitNulls
      [ "notifyURL" .= requestSmsRecipientExportNotifyUrl
      , "recipientsType" .= requestSmsRecipientExportRecipientsType
      ]


-- | Construct a value of type 'RequestSmsRecipientExport' (by applying it's required fields, if any)
mkRequestSmsRecipientExport
  :: E'RecipientsType2 -- ^ 'requestSmsRecipientExportRecipientsType': Filter the recipients based on how they interacted with the campaign
  -> RequestSmsRecipientExport
mkRequestSmsRecipientExport requestSmsRecipientExportRecipientsType =
  RequestSmsRecipientExport
  { requestSmsRecipientExportNotifyUrl = Nothing
  , requestSmsRecipientExportRecipientsType
  }

-- ** SendEmail
-- | SendEmail
data SendEmail = SendEmail
  { sendEmailEmailTo :: !([Text]) -- ^ /Required/ "emailTo" - List of the email addresses of the recipients. For example, [&#39;abc@example.com&#39;, &#39;asd@example.com&#39;].
  , sendEmailEmailBcc :: !(Maybe [Text]) -- ^ "emailBcc" - List of the email addresses of the recipients in bcc
  , sendEmailEmailCc :: !(Maybe [Text]) -- ^ "emailCc" - List of the email addresses of the recipients in cc
  , sendEmailReplyTo :: !(Maybe Text) -- ^ "replyTo" - Email address which shall be used by campaign recipients to reply back
  , sendEmailAttachmentUrl :: !(Maybe Text) -- ^ "attachmentUrl" - Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
  , sendEmailAttachment :: !(Maybe [SendEmailAttachment]) -- ^ "attachment" - Pass the list of content (base64 encoded) and name of the attachment. For example, [{&#39;content&#39;:&#39;base64 encoded content 1&#39;, &#39;name&#39;:&#39;attcahment1&#39;}, {&#39;content&#39;:&#39;base64 encoded content 2&#39;, &#39;name&#39;:&#39;attcahment2&#39;}].
  , sendEmailHeaders :: !(Maybe A.Value) -- ^ "headers" - Pass the set of headers that shall be sent along the mail headers in the original email. &#39;sender.ip&#39; header can be set (only for dedicated ip users) to mention the IP to be used for sending transactional emails. For example, {&#39;Content-Type&#39;:&#39;text/html&#39;, &#39;charset&#39;:&#39;iso-8859-1&#39;, &#39;sender.ip&#39;:&#39;1.2.3.4&#39;}
  , sendEmailAttributes :: !(Maybe A.Value) -- ^ "attributes" - Pass the set of attributes to customize the template. For example, {&#39;FNAME&#39;:&#39;Joe&#39;, &#39;LNAME&#39;:&#39;Doe&#39;}
  , sendEmailTags :: !(Maybe [Text]) -- ^ "tags" - Tag your emails to find them more easily
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendEmail
instance A.FromJSON SendEmail where
  parseJSON = A.withObject "SendEmail" $ \o ->
    SendEmail
      <$> (o .:  "emailTo")
      <*> (o .:? "emailBcc")
      <*> (o .:? "emailCc")
      <*> (o .:? "replyTo")
      <*> (o .:? "attachmentUrl")
      <*> (o .:? "attachment")
      <*> (o .:? "headers")
      <*> (o .:? "attributes")
      <*> (o .:? "tags")

-- | ToJSON SendEmail
instance A.ToJSON SendEmail where
  toJSON SendEmail {..} =
   _omitNulls
      [ "emailTo" .= sendEmailEmailTo
      , "emailBcc" .= sendEmailEmailBcc
      , "emailCc" .= sendEmailEmailCc
      , "replyTo" .= sendEmailReplyTo
      , "attachmentUrl" .= sendEmailAttachmentUrl
      , "attachment" .= sendEmailAttachment
      , "headers" .= sendEmailHeaders
      , "attributes" .= sendEmailAttributes
      , "tags" .= sendEmailTags
      ]


-- | Construct a value of type 'SendEmail' (by applying it's required fields, if any)
mkSendEmail
  :: [Text] -- ^ 'sendEmailEmailTo': List of the email addresses of the recipients. For example, ['abc@example.com', 'asd@example.com'].
  -> SendEmail
mkSendEmail sendEmailEmailTo =
  SendEmail
  { sendEmailEmailTo
  , sendEmailEmailBcc = Nothing
  , sendEmailEmailCc = Nothing
  , sendEmailReplyTo = Nothing
  , sendEmailAttachmentUrl = Nothing
  , sendEmailAttachment = Nothing
  , sendEmailHeaders = Nothing
  , sendEmailAttributes = Nothing
  , sendEmailTags = Nothing
  }

-- ** SendEmailAttachment
-- | SendEmailAttachment
data SendEmailAttachment = SendEmailAttachment
  { sendEmailAttachmentContent :: !(ByteArray) -- ^ /Required/ "content" - Base64 encoded chunk data of the attachment generated on the fly
  , sendEmailAttachmentName :: !(Text) -- ^ /Required/ "name" - Required for content. Name of the attachment
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendEmailAttachment
instance A.FromJSON SendEmailAttachment where
  parseJSON = A.withObject "SendEmailAttachment" $ \o ->
    SendEmailAttachment
      <$> (o .:  "content")
      <*> (o .:  "name")

-- | ToJSON SendEmailAttachment
instance A.ToJSON SendEmailAttachment where
  toJSON SendEmailAttachment {..} =
   _omitNulls
      [ "content" .= sendEmailAttachmentContent
      , "name" .= sendEmailAttachmentName
      ]


-- | Construct a value of type 'SendEmailAttachment' (by applying it's required fields, if any)
mkSendEmailAttachment
  :: ByteArray -- ^ 'sendEmailAttachmentContent': Base64 encoded chunk data of the attachment generated on the fly
  -> Text -- ^ 'sendEmailAttachmentName': Required for content. Name of the attachment
  -> SendEmailAttachment
mkSendEmailAttachment sendEmailAttachmentContent sendEmailAttachmentName =
  SendEmailAttachment
  { sendEmailAttachmentContent
  , sendEmailAttachmentName
  }

-- ** SendReport
-- | SendReport
data SendReport = SendReport
  { sendReportLanguage :: !(Maybe E'Language) -- ^ "language" - Language of email content for campaign report sending.
  , sendReportEmail :: !(SendReportEmail) -- ^ /Required/ "email"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendReport
instance A.FromJSON SendReport where
  parseJSON = A.withObject "SendReport" $ \o ->
    SendReport
      <$> (o .:? "language")
      <*> (o .:  "email")

-- | ToJSON SendReport
instance A.ToJSON SendReport where
  toJSON SendReport {..} =
   _omitNulls
      [ "language" .= sendReportLanguage
      , "email" .= sendReportEmail
      ]


-- | Construct a value of type 'SendReport' (by applying it's required fields, if any)
mkSendReport
  :: SendReportEmail -- ^ 'sendReportEmail' 
  -> SendReport
mkSendReport sendReportEmail =
  SendReport
  { sendReportLanguage = Nothing
  , sendReportEmail
  }

-- ** SendReportEmail
-- | SendReportEmail
-- Email sending credentials including subject, body, to, cc etc.
data SendReportEmail = SendReportEmail
  { sendReportEmailSubject :: !(Text) -- ^ /Required/ "subject" - Subject of the email message
  , sendReportEmailTo :: !([Text]) -- ^ /Required/ "to" - Email addresses of the recipients
  , sendReportEmailContentType :: !(Maybe E'ContentType) -- ^ "contentType" - Type of the message body
  , sendReportEmailBcc :: !(Maybe [Text]) -- ^ "bcc" - Email addresses of the recipients in bcc
  , sendReportEmailCc :: !(Maybe [Text]) -- ^ "cc" - Email addresses of the recipients in cc
  , sendReportEmailBody :: !(Text) -- ^ /Required/ "body" - Body of the email message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendReportEmail
instance A.FromJSON SendReportEmail where
  parseJSON = A.withObject "SendReportEmail" $ \o ->
    SendReportEmail
      <$> (o .:  "subject")
      <*> (o .:  "to")
      <*> (o .:? "contentType")
      <*> (o .:? "bcc")
      <*> (o .:? "cc")
      <*> (o .:  "body")

-- | ToJSON SendReportEmail
instance A.ToJSON SendReportEmail where
  toJSON SendReportEmail {..} =
   _omitNulls
      [ "subject" .= sendReportEmailSubject
      , "to" .= sendReportEmailTo
      , "contentType" .= sendReportEmailContentType
      , "bcc" .= sendReportEmailBcc
      , "cc" .= sendReportEmailCc
      , "body" .= sendReportEmailBody
      ]


-- | Construct a value of type 'SendReportEmail' (by applying it's required fields, if any)
mkSendReportEmail
  :: Text -- ^ 'sendReportEmailSubject': Subject of the email message
  -> [Text] -- ^ 'sendReportEmailTo': Email addresses of the recipients
  -> Text -- ^ 'sendReportEmailBody': Body of the email message
  -> SendReportEmail
mkSendReportEmail sendReportEmailSubject sendReportEmailTo sendReportEmailBody =
  SendReportEmail
  { sendReportEmailSubject
  , sendReportEmailTo
  , sendReportEmailContentType = Nothing
  , sendReportEmailBcc = Nothing
  , sendReportEmailCc = Nothing
  , sendReportEmailBody
  }

-- ** SendSms
-- | SendSms
data SendSms = SendSms
  { sendSmsReference :: !(Text) -- ^ /Required/ "reference"
  , sendSmsMessageId :: !(Integer) -- ^ /Required/ "messageId"
  , sendSmsSmsCount :: !(Maybe Integer) -- ^ "smsCount" - Count of SMS&#39;s to send multiple text messages
  , sendSmsUsedCredits :: !(Maybe Float) -- ^ "usedCredits" - SMS credits used per text message
  , sendSmsRemainingCredits :: !(Maybe Float) -- ^ "remainingCredits" - Remaining SMS credits of the user
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendSms
instance A.FromJSON SendSms where
  parseJSON = A.withObject "SendSms" $ \o ->
    SendSms
      <$> (o .:  "reference")
      <*> (o .:  "messageId")
      <*> (o .:? "smsCount")
      <*> (o .:? "usedCredits")
      <*> (o .:? "remainingCredits")

-- | ToJSON SendSms
instance A.ToJSON SendSms where
  toJSON SendSms {..} =
   _omitNulls
      [ "reference" .= sendSmsReference
      , "messageId" .= sendSmsMessageId
      , "smsCount" .= sendSmsSmsCount
      , "usedCredits" .= sendSmsUsedCredits
      , "remainingCredits" .= sendSmsRemainingCredits
      ]


-- | Construct a value of type 'SendSms' (by applying it's required fields, if any)
mkSendSms
  :: Text -- ^ 'sendSmsReference' 
  -> Integer -- ^ 'sendSmsMessageId' 
  -> SendSms
mkSendSms sendSmsReference sendSmsMessageId =
  SendSms
  { sendSmsReference
  , sendSmsMessageId
  , sendSmsSmsCount = Nothing
  , sendSmsUsedCredits = Nothing
  , sendSmsRemainingCredits = Nothing
  }

-- ** SendSmtpEmail
-- | SendSmtpEmail
data SendSmtpEmail = SendSmtpEmail
  { sendSmtpEmailSender :: !(Maybe SendSmtpEmailSender) -- ^ "sender"
  , sendSmtpEmailTo :: !([SendSmtpEmailTo]) -- ^ /Required/ "to" - List of email addresses and names (optional) of the recipients. For example, [{&#39;name&#39;:&#39;Jimmy&#39;, &#39;email&#39;:&#39;jimmy98@example.com&#39;}, {&#39;name&#39;:&#39;Joe&#39;, &#39;email&#39;:&#39;joe@example.com&#39;}]
  , sendSmtpEmailBcc :: !(Maybe [SendSmtpEmailBcc]) -- ^ "bcc" - List of email addresses and names (optional) of the recipients in bcc
  , sendSmtpEmailCc :: !(Maybe [SendSmtpEmailCc]) -- ^ "cc" - List of email addresses and names (optional) of the recipients in cc
  , sendSmtpEmailHtmlContent :: !(Maybe Text) -- ^ "htmlContent" - HTML body of the message ( Mandatory if &#39;templateId&#39; is not passed, ignored if &#39;templateId&#39; is passed )
  , sendSmtpEmailTextContent :: !(Maybe Text) -- ^ "textContent" - Plain Text body of the message ( Ignored if &#39;templateId&#39; is passed )
  , sendSmtpEmailSubject :: !(Maybe Text) -- ^ "subject" - Subject of the message. Mandatory if &#39;templateId&#39; is not passed
  , sendSmtpEmailReplyTo :: !(Maybe SendSmtpEmailReplyTo) -- ^ "replyTo"
  , sendSmtpEmailAttachment :: !(Maybe [SendSmtpEmailAttachment]) -- ^ "attachment" - Pass the absolute URL (no local file) or the base64 content of the attachment along with the attachment name (Mandatory if attachment content is passed). For example, &#x60;[{\&quot;url\&quot;:\&quot;https://attachment.domain.com/myAttachmentFromUrl.jpg\&quot;, \&quot;name\&quot;:\&quot;My attachment 1\&quot;}, {\&quot;content\&quot;:\&quot;base64 exmaple content\&quot;, \&quot;name\&quot;:\&quot;My attachment 2\&quot;}]&#x60;. Allowed extensions for attachment file: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub, eps, odt, mp3, m4a, m4v, wma, ogg, flac, wav, aif, aifc, aiff, mp4, mov, avi, mkv, mpeg, mpg and wmv ( If &#39;templateId&#39; is passed and is in New Template Language format then only attachment url is accepted. If template is in Old template Language format, then &#39;attachment&#39; is ignored )
  , sendSmtpEmailHeaders :: !(Maybe A.Value) -- ^ "headers" - Pass the set of custom headers (not the standard headers) that shall be sent along the mail headers in the original email. &#39;sender.ip&#39; header can be set (only for dedicated ip users) to mention the IP to be used for sending transactional emails. For example, &#x60;{\&quot;sender.ip\&quot;:\&quot;1.2.3.4\&quot;, \&quot;X-Mailin-custom\&quot;:\&quot;some_custom_header\&quot;}&#x60;.
  , sendSmtpEmailTemplateId :: !(Maybe Integer) -- ^ "templateId" - Id of the template
  , sendSmtpEmailParams :: !(Maybe A.Value) -- ^ "params" - Pass the set of attributes to customize the template. For example, {&#39;FNAME&#39;:&#39;Joe&#39;, &#39;LNAME&#39;:&#39;Doe&#39;}. It&#39;s considered only if template is in New Template Language format.
  , sendSmtpEmailTags :: !(Maybe [Text]) -- ^ "tags" - Tag your emails to find them more easily
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendSmtpEmail
instance A.FromJSON SendSmtpEmail where
  parseJSON = A.withObject "SendSmtpEmail" $ \o ->
    SendSmtpEmail
      <$> (o .:? "sender")
      <*> (o .:  "to")
      <*> (o .:? "bcc")
      <*> (o .:? "cc")
      <*> (o .:? "htmlContent")
      <*> (o .:? "textContent")
      <*> (o .:? "subject")
      <*> (o .:? "replyTo")
      <*> (o .:? "attachment")
      <*> (o .:? "headers")
      <*> (o .:? "templateId")
      <*> (o .:? "params")
      <*> (o .:? "tags")

-- | ToJSON SendSmtpEmail
instance A.ToJSON SendSmtpEmail where
  toJSON SendSmtpEmail {..} =
   _omitNulls
      [ "sender" .= sendSmtpEmailSender
      , "to" .= sendSmtpEmailTo
      , "bcc" .= sendSmtpEmailBcc
      , "cc" .= sendSmtpEmailCc
      , "htmlContent" .= sendSmtpEmailHtmlContent
      , "textContent" .= sendSmtpEmailTextContent
      , "subject" .= sendSmtpEmailSubject
      , "replyTo" .= sendSmtpEmailReplyTo
      , "attachment" .= sendSmtpEmailAttachment
      , "headers" .= sendSmtpEmailHeaders
      , "templateId" .= sendSmtpEmailTemplateId
      , "params" .= sendSmtpEmailParams
      , "tags" .= sendSmtpEmailTags
      ]


-- | Construct a value of type 'SendSmtpEmail' (by applying it's required fields, if any)
mkSendSmtpEmail
  :: [SendSmtpEmailTo] -- ^ 'sendSmtpEmailTo': List of email addresses and names (optional) of the recipients. For example, [{'name':'Jimmy', 'email':'jimmy98@example.com'}, {'name':'Joe', 'email':'joe@example.com'}]
  -> SendSmtpEmail
mkSendSmtpEmail sendSmtpEmailTo =
  SendSmtpEmail
  { sendSmtpEmailSender = Nothing
  , sendSmtpEmailTo
  , sendSmtpEmailBcc = Nothing
  , sendSmtpEmailCc = Nothing
  , sendSmtpEmailHtmlContent = Nothing
  , sendSmtpEmailTextContent = Nothing
  , sendSmtpEmailSubject = Nothing
  , sendSmtpEmailReplyTo = Nothing
  , sendSmtpEmailAttachment = Nothing
  , sendSmtpEmailHeaders = Nothing
  , sendSmtpEmailTemplateId = Nothing
  , sendSmtpEmailParams = Nothing
  , sendSmtpEmailTags = Nothing
  }

-- ** SendSmtpEmailAttachment
-- | SendSmtpEmailAttachment
data SendSmtpEmailAttachment = SendSmtpEmailAttachment
  { sendSmtpEmailAttachmentUrl :: !(Maybe Text) -- ^ "url" - Absolute url of the attachment (no local file).
  , sendSmtpEmailAttachmentContent :: !(Maybe ByteArray) -- ^ "content" - Base64 encoded chunk data of the attachment generated on the fly
  , sendSmtpEmailAttachmentName :: !(Maybe Text) -- ^ "name" - Required if content is passed. Name of the attachment
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendSmtpEmailAttachment
instance A.FromJSON SendSmtpEmailAttachment where
  parseJSON = A.withObject "SendSmtpEmailAttachment" $ \o ->
    SendSmtpEmailAttachment
      <$> (o .:? "url")
      <*> (o .:? "content")
      <*> (o .:? "name")

-- | ToJSON SendSmtpEmailAttachment
instance A.ToJSON SendSmtpEmailAttachment where
  toJSON SendSmtpEmailAttachment {..} =
   _omitNulls
      [ "url" .= sendSmtpEmailAttachmentUrl
      , "content" .= sendSmtpEmailAttachmentContent
      , "name" .= sendSmtpEmailAttachmentName
      ]


-- | Construct a value of type 'SendSmtpEmailAttachment' (by applying it's required fields, if any)
mkSendSmtpEmailAttachment
  :: SendSmtpEmailAttachment
mkSendSmtpEmailAttachment =
  SendSmtpEmailAttachment
  { sendSmtpEmailAttachmentUrl = Nothing
  , sendSmtpEmailAttachmentContent = Nothing
  , sendSmtpEmailAttachmentName = Nothing
  }

-- ** SendSmtpEmailBcc
-- | SendSmtpEmailBcc
data SendSmtpEmailBcc = SendSmtpEmailBcc
  { sendSmtpEmailBccEmail :: !(Text) -- ^ /Required/ "email" - Email address of the recipient in bcc
  , sendSmtpEmailBccName :: !(Maybe Text) -- ^ "name" - Name of the recipient in bcc. Maximum allowed characters are 70.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendSmtpEmailBcc
instance A.FromJSON SendSmtpEmailBcc where
  parseJSON = A.withObject "SendSmtpEmailBcc" $ \o ->
    SendSmtpEmailBcc
      <$> (o .:  "email")
      <*> (o .:? "name")

-- | ToJSON SendSmtpEmailBcc
instance A.ToJSON SendSmtpEmailBcc where
  toJSON SendSmtpEmailBcc {..} =
   _omitNulls
      [ "email" .= sendSmtpEmailBccEmail
      , "name" .= sendSmtpEmailBccName
      ]


-- | Construct a value of type 'SendSmtpEmailBcc' (by applying it's required fields, if any)
mkSendSmtpEmailBcc
  :: Text -- ^ 'sendSmtpEmailBccEmail': Email address of the recipient in bcc
  -> SendSmtpEmailBcc
mkSendSmtpEmailBcc sendSmtpEmailBccEmail =
  SendSmtpEmailBcc
  { sendSmtpEmailBccEmail
  , sendSmtpEmailBccName = Nothing
  }

-- ** SendSmtpEmailCc
-- | SendSmtpEmailCc
data SendSmtpEmailCc = SendSmtpEmailCc
  { sendSmtpEmailCcEmail :: !(Text) -- ^ /Required/ "email" - Email address of the recipient in cc
  , sendSmtpEmailCcName :: !(Maybe Text) -- ^ "name" - Name of the recipient in cc. Maximum allowed characters are 70.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendSmtpEmailCc
instance A.FromJSON SendSmtpEmailCc where
  parseJSON = A.withObject "SendSmtpEmailCc" $ \o ->
    SendSmtpEmailCc
      <$> (o .:  "email")
      <*> (o .:? "name")

-- | ToJSON SendSmtpEmailCc
instance A.ToJSON SendSmtpEmailCc where
  toJSON SendSmtpEmailCc {..} =
   _omitNulls
      [ "email" .= sendSmtpEmailCcEmail
      , "name" .= sendSmtpEmailCcName
      ]


-- | Construct a value of type 'SendSmtpEmailCc' (by applying it's required fields, if any)
mkSendSmtpEmailCc
  :: Text -- ^ 'sendSmtpEmailCcEmail': Email address of the recipient in cc
  -> SendSmtpEmailCc
mkSendSmtpEmailCc sendSmtpEmailCcEmail =
  SendSmtpEmailCc
  { sendSmtpEmailCcEmail
  , sendSmtpEmailCcName = Nothing
  }

-- ** SendSmtpEmailReplyTo
-- | SendSmtpEmailReplyTo
-- Email (required), along with name (optional), on which transactional mail recipients will be able to reply back. For example, {'email':'ann6533@example.com', 'name':'Ann'}.
data SendSmtpEmailReplyTo = SendSmtpEmailReplyTo
  { sendSmtpEmailReplyToEmail :: !(Text) -- ^ /Required/ "email" - Email address in reply to
  , sendSmtpEmailReplyToName :: !(Maybe Text) -- ^ "name" - Name in reply to. Maximum allowed characters are 70.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendSmtpEmailReplyTo
instance A.FromJSON SendSmtpEmailReplyTo where
  parseJSON = A.withObject "SendSmtpEmailReplyTo" $ \o ->
    SendSmtpEmailReplyTo
      <$> (o .:  "email")
      <*> (o .:? "name")

-- | ToJSON SendSmtpEmailReplyTo
instance A.ToJSON SendSmtpEmailReplyTo where
  toJSON SendSmtpEmailReplyTo {..} =
   _omitNulls
      [ "email" .= sendSmtpEmailReplyToEmail
      , "name" .= sendSmtpEmailReplyToName
      ]


-- | Construct a value of type 'SendSmtpEmailReplyTo' (by applying it's required fields, if any)
mkSendSmtpEmailReplyTo
  :: Text -- ^ 'sendSmtpEmailReplyToEmail': Email address in reply to
  -> SendSmtpEmailReplyTo
mkSendSmtpEmailReplyTo sendSmtpEmailReplyToEmail =
  SendSmtpEmailReplyTo
  { sendSmtpEmailReplyToEmail
  , sendSmtpEmailReplyToName = Nothing
  }

-- ** SendSmtpEmailSender
-- | SendSmtpEmailSender
-- Mandatory if 'templateId' is not passed. Pass name (optional) and email of sender from which emails will be sent. For example, {'name':'Mary from MyShop', 'email':'no-reply@myshop.com'}
data SendSmtpEmailSender = SendSmtpEmailSender
  { sendSmtpEmailSenderName :: !(Maybe Text) -- ^ "name" - Name of the sender from which the emails will be sent. Maximum allowed characters are 70.
  , sendSmtpEmailSenderEmail :: !(Text) -- ^ /Required/ "email" - Email of the sender from which the emails will be sent
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendSmtpEmailSender
instance A.FromJSON SendSmtpEmailSender where
  parseJSON = A.withObject "SendSmtpEmailSender" $ \o ->
    SendSmtpEmailSender
      <$> (o .:? "name")
      <*> (o .:  "email")

-- | ToJSON SendSmtpEmailSender
instance A.ToJSON SendSmtpEmailSender where
  toJSON SendSmtpEmailSender {..} =
   _omitNulls
      [ "name" .= sendSmtpEmailSenderName
      , "email" .= sendSmtpEmailSenderEmail
      ]


-- | Construct a value of type 'SendSmtpEmailSender' (by applying it's required fields, if any)
mkSendSmtpEmailSender
  :: Text -- ^ 'sendSmtpEmailSenderEmail': Email of the sender from which the emails will be sent
  -> SendSmtpEmailSender
mkSendSmtpEmailSender sendSmtpEmailSenderEmail =
  SendSmtpEmailSender
  { sendSmtpEmailSenderName = Nothing
  , sendSmtpEmailSenderEmail
  }

-- ** SendSmtpEmailTo
-- | SendSmtpEmailTo
data SendSmtpEmailTo = SendSmtpEmailTo
  { sendSmtpEmailToEmail :: !(Text) -- ^ /Required/ "email" - Email address of the recipient
  , sendSmtpEmailToName :: !(Maybe Text) -- ^ "name" - Name of the recipient. Maximum allowed characters are 70.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendSmtpEmailTo
instance A.FromJSON SendSmtpEmailTo where
  parseJSON = A.withObject "SendSmtpEmailTo" $ \o ->
    SendSmtpEmailTo
      <$> (o .:  "email")
      <*> (o .:? "name")

-- | ToJSON SendSmtpEmailTo
instance A.ToJSON SendSmtpEmailTo where
  toJSON SendSmtpEmailTo {..} =
   _omitNulls
      [ "email" .= sendSmtpEmailToEmail
      , "name" .= sendSmtpEmailToName
      ]


-- | Construct a value of type 'SendSmtpEmailTo' (by applying it's required fields, if any)
mkSendSmtpEmailTo
  :: Text -- ^ 'sendSmtpEmailToEmail': Email address of the recipient
  -> SendSmtpEmailTo
mkSendSmtpEmailTo sendSmtpEmailToEmail =
  SendSmtpEmailTo
  { sendSmtpEmailToEmail
  , sendSmtpEmailToName = Nothing
  }

-- ** SendTemplateEmail
-- | SendTemplateEmail
data SendTemplateEmail = SendTemplateEmail
  { sendTemplateEmailMessageId :: !(Text) -- ^ /Required/ "messageId" - Message ID of the template Email sent
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendTemplateEmail
instance A.FromJSON SendTemplateEmail where
  parseJSON = A.withObject "SendTemplateEmail" $ \o ->
    SendTemplateEmail
      <$> (o .:  "messageId")

-- | ToJSON SendTemplateEmail
instance A.ToJSON SendTemplateEmail where
  toJSON SendTemplateEmail {..} =
   _omitNulls
      [ "messageId" .= sendTemplateEmailMessageId
      ]


-- | Construct a value of type 'SendTemplateEmail' (by applying it's required fields, if any)
mkSendTemplateEmail
  :: Text -- ^ 'sendTemplateEmailMessageId': Message ID of the template Email sent
  -> SendTemplateEmail
mkSendTemplateEmail sendTemplateEmailMessageId =
  SendTemplateEmail
  { sendTemplateEmailMessageId
  }

-- ** SendTestEmail
-- | SendTestEmail
data SendTestEmail = SendTestEmail
  { sendTestEmailEmailTo :: !(Maybe [Text]) -- ^ "emailTo" - List of the email addresses of the recipients whom you wish to send the test mail. If left empty, the test mail will be sent to your entire test list.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendTestEmail
instance A.FromJSON SendTestEmail where
  parseJSON = A.withObject "SendTestEmail" $ \o ->
    SendTestEmail
      <$> (o .:? "emailTo")

-- | ToJSON SendTestEmail
instance A.ToJSON SendTestEmail where
  toJSON SendTestEmail {..} =
   _omitNulls
      [ "emailTo" .= sendTestEmailEmailTo
      ]


-- | Construct a value of type 'SendTestEmail' (by applying it's required fields, if any)
mkSendTestEmail
  :: SendTestEmail
mkSendTestEmail =
  SendTestEmail
  { sendTestEmailEmailTo = Nothing
  }

-- ** SendTestSms
-- | SendTestSms
data SendTestSms = SendTestSms
  { sendTestSmsPhoneNumber :: !(Maybe Text) -- ^ "phoneNumber" - Mobile number of the recipient with the country code. This number must belong to one of your contacts in SendinBlue account and must not be blacklisted
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendTestSms
instance A.FromJSON SendTestSms where
  parseJSON = A.withObject "SendTestSms" $ \o ->
    SendTestSms
      <$> (o .:? "phoneNumber")

-- | ToJSON SendTestSms
instance A.ToJSON SendTestSms where
  toJSON SendTestSms {..} =
   _omitNulls
      [ "phoneNumber" .= sendTestSmsPhoneNumber
      ]


-- | Construct a value of type 'SendTestSms' (by applying it's required fields, if any)
mkSendTestSms
  :: SendTestSms
mkSendTestSms =
  SendTestSms
  { sendTestSmsPhoneNumber = Nothing
  }

-- ** SendTransacSms
-- | SendTransacSms
data SendTransacSms = SendTransacSms
  { sendTransacSmsSender :: !(Text) -- ^ /Required/ "sender" - Name of the sender. Only alphanumeric characters. No more than 11 characters
  , sendTransacSmsRecipient :: !(Text) -- ^ /Required/ "recipient" - Mobile number to send SMS with the country code
  , sendTransacSmsContent :: !(Text) -- ^ /Required/ "content" - Content of the message. If more than 160 characters long, will be sent as multiple text messages
  , sendTransacSmsType :: !(Maybe E'Type3) -- ^ "type" - Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.
  , sendTransacSmsTag :: !(Maybe Text) -- ^ "tag" - Tag of the message
  , sendTransacSmsWebUrl :: !(Maybe Text) -- ^ "webUrl" - Webhook to call for each event triggered by the message (delivered etc.)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendTransacSms
instance A.FromJSON SendTransacSms where
  parseJSON = A.withObject "SendTransacSms" $ \o ->
    SendTransacSms
      <$> (o .:  "sender")
      <*> (o .:  "recipient")
      <*> (o .:  "content")
      <*> (o .:? "type")
      <*> (o .:? "tag")
      <*> (o .:? "webUrl")

-- | ToJSON SendTransacSms
instance A.ToJSON SendTransacSms where
  toJSON SendTransacSms {..} =
   _omitNulls
      [ "sender" .= sendTransacSmsSender
      , "recipient" .= sendTransacSmsRecipient
      , "content" .= sendTransacSmsContent
      , "type" .= sendTransacSmsType
      , "tag" .= sendTransacSmsTag
      , "webUrl" .= sendTransacSmsWebUrl
      ]


-- | Construct a value of type 'SendTransacSms' (by applying it's required fields, if any)
mkSendTransacSms
  :: Text -- ^ 'sendTransacSmsSender': Name of the sender. Only alphanumeric characters. No more than 11 characters
  -> Text -- ^ 'sendTransacSmsRecipient': Mobile number to send SMS with the country code
  -> Text -- ^ 'sendTransacSmsContent': Content of the message. If more than 160 characters long, will be sent as multiple text messages
  -> SendTransacSms
mkSendTransacSms sendTransacSmsSender sendTransacSmsRecipient sendTransacSmsContent =
  SendTransacSms
  { sendTransacSmsSender
  , sendTransacSmsRecipient
  , sendTransacSmsContent
  , sendTransacSmsType = Nothing
  , sendTransacSmsTag = Nothing
  , sendTransacSmsWebUrl = Nothing
  }

-- ** UpdateAttribute
-- | UpdateAttribute
data UpdateAttribute = UpdateAttribute
  { updateAttributeValue :: !(Maybe Text) -- ^ "value" - Value of the attribute to update. Use only if the attribute&#39;s category is &#39;calculated&#39; or &#39;global&#39;
  , updateAttributeEnumeration :: !(Maybe [UpdateAttributeEnumeration]) -- ^ "enumeration" - List of the values and labels that the attribute can take. Use only if the attribute&#39;s category is \&quot;category\&quot;. For example, [{&#39;value&#39;:1, &#39;label&#39;:&#39;male&#39;}, {&#39;value&#39;:2, &#39;label&#39;:&#39;female&#39;}]
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateAttribute
instance A.FromJSON UpdateAttribute where
  parseJSON = A.withObject "UpdateAttribute" $ \o ->
    UpdateAttribute
      <$> (o .:? "value")
      <*> (o .:? "enumeration")

-- | ToJSON UpdateAttribute
instance A.ToJSON UpdateAttribute where
  toJSON UpdateAttribute {..} =
   _omitNulls
      [ "value" .= updateAttributeValue
      , "enumeration" .= updateAttributeEnumeration
      ]


-- | Construct a value of type 'UpdateAttribute' (by applying it's required fields, if any)
mkUpdateAttribute
  :: UpdateAttribute
mkUpdateAttribute =
  UpdateAttribute
  { updateAttributeValue = Nothing
  , updateAttributeEnumeration = Nothing
  }

-- ** UpdateAttributeEnumeration
-- | UpdateAttributeEnumeration
data UpdateAttributeEnumeration = UpdateAttributeEnumeration
  { updateAttributeEnumerationValue :: !(Int) -- ^ /Required/ "value" - Id of the value
  , updateAttributeEnumerationLabel :: !(Text) -- ^ /Required/ "label" - Label of the value
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateAttributeEnumeration
instance A.FromJSON UpdateAttributeEnumeration where
  parseJSON = A.withObject "UpdateAttributeEnumeration" $ \o ->
    UpdateAttributeEnumeration
      <$> (o .:  "value")
      <*> (o .:  "label")

-- | ToJSON UpdateAttributeEnumeration
instance A.ToJSON UpdateAttributeEnumeration where
  toJSON UpdateAttributeEnumeration {..} =
   _omitNulls
      [ "value" .= updateAttributeEnumerationValue
      , "label" .= updateAttributeEnumerationLabel
      ]


-- | Construct a value of type 'UpdateAttributeEnumeration' (by applying it's required fields, if any)
mkUpdateAttributeEnumeration
  :: Int -- ^ 'updateAttributeEnumerationValue': Id of the value
  -> Text -- ^ 'updateAttributeEnumerationLabel': Label of the value
  -> UpdateAttributeEnumeration
mkUpdateAttributeEnumeration updateAttributeEnumerationValue updateAttributeEnumerationLabel =
  UpdateAttributeEnumeration
  { updateAttributeEnumerationValue
  , updateAttributeEnumerationLabel
  }

-- ** UpdateCampaignStatus
-- | UpdateCampaignStatus
-- Status of the campaign
data UpdateCampaignStatus = UpdateCampaignStatus
  { updateCampaignStatusStatus :: !(Maybe E'Status4) -- ^ "status" - Note:- replicateTemplate status will be available only for template type campaigns.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateCampaignStatus
instance A.FromJSON UpdateCampaignStatus where
  parseJSON = A.withObject "UpdateCampaignStatus" $ \o ->
    UpdateCampaignStatus
      <$> (o .:? "status")

-- | ToJSON UpdateCampaignStatus
instance A.ToJSON UpdateCampaignStatus where
  toJSON UpdateCampaignStatus {..} =
   _omitNulls
      [ "status" .= updateCampaignStatusStatus
      ]


-- | Construct a value of type 'UpdateCampaignStatus' (by applying it's required fields, if any)
mkUpdateCampaignStatus
  :: UpdateCampaignStatus
mkUpdateCampaignStatus =
  UpdateCampaignStatus
  { updateCampaignStatusStatus = Nothing
  }

-- ** UpdateChild
-- | UpdateChild
data UpdateChild = UpdateChild
  { updateChildEmail :: !(Maybe Text) -- ^ "email" - New Email address to update the child account
  , updateChildFirstName :: !(Maybe Text) -- ^ "firstName" - New First name to use to update the child account
  , updateChildLastName :: !(Maybe Text) -- ^ "lastName" - New Last name to use to update the child account
  , updateChildCompanyName :: !(Maybe Text) -- ^ "companyName" - New Company name to use to update the child account
  , updateChildPassword :: !(Maybe Text) -- ^ "password" - New password for the child account to login
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateChild
instance A.FromJSON UpdateChild where
  parseJSON = A.withObject "UpdateChild" $ \o ->
    UpdateChild
      <$> (o .:? "email")
      <*> (o .:? "firstName")
      <*> (o .:? "lastName")
      <*> (o .:? "companyName")
      <*> (o .:? "password")

-- | ToJSON UpdateChild
instance A.ToJSON UpdateChild where
  toJSON UpdateChild {..} =
   _omitNulls
      [ "email" .= updateChildEmail
      , "firstName" .= updateChildFirstName
      , "lastName" .= updateChildLastName
      , "companyName" .= updateChildCompanyName
      , "password" .= updateChildPassword
      ]


-- | Construct a value of type 'UpdateChild' (by applying it's required fields, if any)
mkUpdateChild
  :: UpdateChild
mkUpdateChild =
  UpdateChild
  { updateChildEmail = Nothing
  , updateChildFirstName = Nothing
  , updateChildLastName = Nothing
  , updateChildCompanyName = Nothing
  , updateChildPassword = Nothing
  }

-- ** UpdateChildAccountStatus
-- | UpdateChildAccountStatus
data UpdateChildAccountStatus = UpdateChildAccountStatus
  { updateChildAccountStatusTransactionalEmail :: !(Maybe Bool) -- ^ "transactionalEmail" - Status of Transactional Email Platform activation for your account (true&#x3D;enabled, false&#x3D;disabled)
  , updateChildAccountStatusTransactionalSms :: !(Maybe Bool) -- ^ "transactionalSms" - Status of Transactional SMS Platform activation for your account (true&#x3D;enabled, false&#x3D;disabled)
  , updateChildAccountStatusMarketingAutomation :: !(Maybe Bool) -- ^ "marketingAutomation" - Status of Marketing Automation Platform activation for your account (true&#x3D;enabled, false&#x3D;disabled)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateChildAccountStatus
instance A.FromJSON UpdateChildAccountStatus where
  parseJSON = A.withObject "UpdateChildAccountStatus" $ \o ->
    UpdateChildAccountStatus
      <$> (o .:? "transactionalEmail")
      <*> (o .:? "transactionalSms")
      <*> (o .:? "marketingAutomation")

-- | ToJSON UpdateChildAccountStatus
instance A.ToJSON UpdateChildAccountStatus where
  toJSON UpdateChildAccountStatus {..} =
   _omitNulls
      [ "transactionalEmail" .= updateChildAccountStatusTransactionalEmail
      , "transactionalSms" .= updateChildAccountStatusTransactionalSms
      , "marketingAutomation" .= updateChildAccountStatusMarketingAutomation
      ]


-- | Construct a value of type 'UpdateChildAccountStatus' (by applying it's required fields, if any)
mkUpdateChildAccountStatus
  :: UpdateChildAccountStatus
mkUpdateChildAccountStatus =
  UpdateChildAccountStatus
  { updateChildAccountStatusTransactionalEmail = Nothing
  , updateChildAccountStatusTransactionalSms = Nothing
  , updateChildAccountStatusMarketingAutomation = Nothing
  }

-- ** UpdateChildDomain
-- | UpdateChildDomain
data UpdateChildDomain = UpdateChildDomain
  { updateChildDomainDomain :: !(Maybe Text) -- ^ "domain" - Value for the sender domain that will replace the existing domain
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateChildDomain
instance A.FromJSON UpdateChildDomain where
  parseJSON = A.withObject "UpdateChildDomain" $ \o ->
    UpdateChildDomain
      <$> (o .:? "domain")

-- | ToJSON UpdateChildDomain
instance A.ToJSON UpdateChildDomain where
  toJSON UpdateChildDomain {..} =
   _omitNulls
      [ "domain" .= updateChildDomainDomain
      ]


-- | Construct a value of type 'UpdateChildDomain' (by applying it's required fields, if any)
mkUpdateChildDomain
  :: UpdateChildDomain
mkUpdateChildDomain =
  UpdateChildDomain
  { updateChildDomainDomain = Nothing
  }

-- ** UpdateContact
-- | UpdateContact
data UpdateContact = UpdateContact
  { updateContactAttributes :: !(Maybe A.Value) -- ^ "attributes" - Pass the set of attributes to be updated. These attributes must be present in your account. To update existing email address of a contact with the new one please pass EMAIL in attribtes. For eg. { &#39;EMAIL&#39;:&#39;newemail@domain.com&#39;, &#39;FNAME&#39;:&#39;Ellie&#39;, &#39;LNAME&#39;:&#39;Roger&#39;}
  , updateContactEmailBlacklisted :: !(Maybe Bool) -- ^ "emailBlacklisted" - Set/unset this field to blacklist/allow the contact for emails (emailBlacklisted &#x3D; true)
  , updateContactSmsBlacklisted :: !(Maybe Bool) -- ^ "smsBlacklisted" - Set/unset this field to blacklist/allow the contact for SMS (smsBlacklisted &#x3D; true)
  , updateContactListIds :: !(Maybe [Integer]) -- ^ "listIds" - Ids of the lists to add the contact to
  , updateContactUnlinkListIds :: !(Maybe [Integer]) -- ^ "unlinkListIds" - Ids of the lists to remove the contact from
  , updateContactSmtpBlacklistSender :: !(Maybe [Text]) -- ^ "smtpBlacklistSender" - transactional email forbidden sender for contact. Use only for email Contact
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateContact
instance A.FromJSON UpdateContact where
  parseJSON = A.withObject "UpdateContact" $ \o ->
    UpdateContact
      <$> (o .:? "attributes")
      <*> (o .:? "emailBlacklisted")
      <*> (o .:? "smsBlacklisted")
      <*> (o .:? "listIds")
      <*> (o .:? "unlinkListIds")
      <*> (o .:? "smtpBlacklistSender")

-- | ToJSON UpdateContact
instance A.ToJSON UpdateContact where
  toJSON UpdateContact {..} =
   _omitNulls
      [ "attributes" .= updateContactAttributes
      , "emailBlacklisted" .= updateContactEmailBlacklisted
      , "smsBlacklisted" .= updateContactSmsBlacklisted
      , "listIds" .= updateContactListIds
      , "unlinkListIds" .= updateContactUnlinkListIds
      , "smtpBlacklistSender" .= updateContactSmtpBlacklistSender
      ]


-- | Construct a value of type 'UpdateContact' (by applying it's required fields, if any)
mkUpdateContact
  :: UpdateContact
mkUpdateContact =
  UpdateContact
  { updateContactAttributes = Nothing
  , updateContactEmailBlacklisted = Nothing
  , updateContactSmsBlacklisted = Nothing
  , updateContactListIds = Nothing
  , updateContactUnlinkListIds = Nothing
  , updateContactSmtpBlacklistSender = Nothing
  }

-- ** UpdateEmailCampaign
-- | UpdateEmailCampaign
data UpdateEmailCampaign = UpdateEmailCampaign
  { updateEmailCampaignTag :: !(Maybe Text) -- ^ "tag" - Tag of the campaign
  , updateEmailCampaignSender :: !(Maybe UpdateEmailCampaignSender) -- ^ "sender"
  , updateEmailCampaignName :: !(Maybe Text) -- ^ "name" - Name of the campaign
  , updateEmailCampaignHtmlContent :: !(Maybe Text) -- ^ "htmlContent" - Body of the message (HTML version). REQUIRED if htmlUrl is empty
  , updateEmailCampaignHtmlUrl :: !(Maybe Text) -- ^ "htmlUrl" - Url which contents the body of the email message. REQUIRED if htmlContent is empty
  , updateEmailCampaignScheduledAt :: !(Maybe DateTime) -- ^ "scheduledAt" - UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result. If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part).
  , updateEmailCampaignSubject :: !(Maybe Text) -- ^ "subject" - Subject of the campaign
  , updateEmailCampaignReplyTo :: !(Maybe Text) -- ^ "replyTo" - Email on which campaign recipients will be able to reply to
  , updateEmailCampaignToField :: !(Maybe Text) -- ^ "toField" - To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter &#39;params&#39; used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
  , updateEmailCampaignRecipients :: !(Maybe UpdateEmailCampaignRecipients) -- ^ "recipients"
  , updateEmailCampaignAttachmentUrl :: !(Maybe Text) -- ^ "attachmentUrl" - Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
  , updateEmailCampaignInlineImageActivation :: !(Maybe Bool) -- ^ "inlineImageActivation" - Status of inline image. inlineImageActivation &#x3D; false means image can’t be embedded, &amp; inlineImageActivation &#x3D; true means image can be embedded, in the email. You cannot send a campaign of more than 4MB with images embedded in the email. Campaigns with the images embedded in the email must be sent to less than 5000 contacts.
  , updateEmailCampaignMirrorActive :: !(Maybe Bool) -- ^ "mirrorActive" - Status of mirror links in campaign. mirrorActive &#x3D; false means mirror links are deactivated, &amp; mirrorActive &#x3D; true means mirror links are activated, in the campaign
  , updateEmailCampaignRecurring :: !(Maybe Bool) -- ^ "recurring" - FOR TRIGGER ONLY ! Type of trigger campaign.recurring &#x3D; false means contact can receive the same Trigger campaign only once, &amp; recurring &#x3D; true means contact can receive the same Trigger campaign several times
  , updateEmailCampaignFooter :: !(Maybe Text) -- ^ "footer" - Footer of the email campaign
  , updateEmailCampaignHeader :: !(Maybe Text) -- ^ "header" - Header of the email campaign
  , updateEmailCampaignUtmCampaign :: !(Maybe Text) -- ^ "utmCampaign" - Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed
  , updateEmailCampaignParams :: !(Maybe A.Value) -- ^ "params" - Pass the set of attributes to customize the type &#39;classic&#39; campaign. For example, {&#39;FNAME&#39;:&#39;Joe&#39;, &#39;LNAME&#39;:&#39;Doe&#39;}. The &#39;params&#39; field will get updated, only if the campaign is in New Template Language, else ignored. The New Template Language is dependent on the values of &#39;subject&#39;, &#39;htmlContent/htmlUrl&#39;, &#39;sender.name&#39; &amp; &#39;toField&#39;
  , updateEmailCampaignSendAtBestTime :: !(Maybe Bool) -- ^ "sendAtBestTime" - Set this to true if you want to send your campaign at best time. Note:- if true, warmup ip will be disabled.
  , updateEmailCampaignAbTesting :: !(Maybe Bool) -- ^ "abTesting" - Status of A/B Test. abTesting &#x3D; false means it is disabled, &amp; abTesting &#x3D; true means it is enabled. &#39;subjectA&#39;, &#39;subjectB&#39;, &#39;splitRule&#39;, &#39;winnerCriteria&#39; &amp; &#39;winnerDelay&#39; will be considered if abTesting is set to true. &#39;subject&#39; if passed is ignored.  Can be set to true only if &#39;sendAtBestTime&#39; is &#39;false&#39;. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B
  , updateEmailCampaignSubjectA :: !(Maybe Text) -- ^ "subjectA" - Subject A of the campaign. Considered if abTesting &#x3D; true. subjectA &amp; subjectB should have unique value
  , updateEmailCampaignSubjectB :: !(Maybe Text) -- ^ "subjectB" - Subject B of the campaign. Considered if abTesting &#x3D; true. subjectA &amp; subjectB should have unique value
  , updateEmailCampaignSplitRule :: !(Maybe Integer) -- ^ "splitRule" - Add the size of your test groups. Considered if abTesting &#x3D; true. We&#39;ll send version A and B to a random sample of recipients, and then the winning version to everyone else
  , updateEmailCampaignWinnerCriteria :: !(Maybe E'WinnerCriteria) -- ^ "winnerCriteria" - Choose the metrics that will determinate the winning version. Considered if &#39;splitRule&#39; &gt;&#x3D; 1 and &lt; 50. If splitRule &#x3D; 50, &#39;winnerCriteria&#39; is ignored if passed or alreday exist in record
  , updateEmailCampaignWinnerDelay :: !(Maybe Integer) -- ^ "winnerDelay" - Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 &#x3D; 168 hours. The winning version will be sent at the end of the test. Considered if &#39;splitRule&#39; &gt;&#x3D; 1 and &lt; 50. If splitRule &#x3D; 50, &#39;winnerDelay&#39; is ignored if passed or alreday exist in record
  , updateEmailCampaignIpWarmupEnable :: !(Maybe Bool) -- ^ "ipWarmupEnable" - Available for dedicated ip clients. Set this to true if you wish to warm up your ip.
  , updateEmailCampaignInitialQuota :: !(Maybe Integer) -- ^ "initialQuota" - Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.
  , updateEmailCampaignIncreaseRate :: !(Maybe Integer) -- ^ "increaseRate" - Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateEmailCampaign
instance A.FromJSON UpdateEmailCampaign where
  parseJSON = A.withObject "UpdateEmailCampaign" $ \o ->
    UpdateEmailCampaign
      <$> (o .:? "tag")
      <*> (o .:? "sender")
      <*> (o .:? "name")
      <*> (o .:? "htmlContent")
      <*> (o .:? "htmlUrl")
      <*> (o .:? "scheduledAt")
      <*> (o .:? "subject")
      <*> (o .:? "replyTo")
      <*> (o .:? "toField")
      <*> (o .:? "recipients")
      <*> (o .:? "attachmentUrl")
      <*> (o .:? "inlineImageActivation")
      <*> (o .:? "mirrorActive")
      <*> (o .:? "recurring")
      <*> (o .:? "footer")
      <*> (o .:? "header")
      <*> (o .:? "utmCampaign")
      <*> (o .:? "params")
      <*> (o .:? "sendAtBestTime")
      <*> (o .:? "abTesting")
      <*> (o .:? "subjectA")
      <*> (o .:? "subjectB")
      <*> (o .:? "splitRule")
      <*> (o .:? "winnerCriteria")
      <*> (o .:? "winnerDelay")
      <*> (o .:? "ipWarmupEnable")
      <*> (o .:? "initialQuota")
      <*> (o .:? "increaseRate")

-- | ToJSON UpdateEmailCampaign
instance A.ToJSON UpdateEmailCampaign where
  toJSON UpdateEmailCampaign {..} =
   _omitNulls
      [ "tag" .= updateEmailCampaignTag
      , "sender" .= updateEmailCampaignSender
      , "name" .= updateEmailCampaignName
      , "htmlContent" .= updateEmailCampaignHtmlContent
      , "htmlUrl" .= updateEmailCampaignHtmlUrl
      , "scheduledAt" .= updateEmailCampaignScheduledAt
      , "subject" .= updateEmailCampaignSubject
      , "replyTo" .= updateEmailCampaignReplyTo
      , "toField" .= updateEmailCampaignToField
      , "recipients" .= updateEmailCampaignRecipients
      , "attachmentUrl" .= updateEmailCampaignAttachmentUrl
      , "inlineImageActivation" .= updateEmailCampaignInlineImageActivation
      , "mirrorActive" .= updateEmailCampaignMirrorActive
      , "recurring" .= updateEmailCampaignRecurring
      , "footer" .= updateEmailCampaignFooter
      , "header" .= updateEmailCampaignHeader
      , "utmCampaign" .= updateEmailCampaignUtmCampaign
      , "params" .= updateEmailCampaignParams
      , "sendAtBestTime" .= updateEmailCampaignSendAtBestTime
      , "abTesting" .= updateEmailCampaignAbTesting
      , "subjectA" .= updateEmailCampaignSubjectA
      , "subjectB" .= updateEmailCampaignSubjectB
      , "splitRule" .= updateEmailCampaignSplitRule
      , "winnerCriteria" .= updateEmailCampaignWinnerCriteria
      , "winnerDelay" .= updateEmailCampaignWinnerDelay
      , "ipWarmupEnable" .= updateEmailCampaignIpWarmupEnable
      , "initialQuota" .= updateEmailCampaignInitialQuota
      , "increaseRate" .= updateEmailCampaignIncreaseRate
      ]


-- | Construct a value of type 'UpdateEmailCampaign' (by applying it's required fields, if any)
mkUpdateEmailCampaign
  :: UpdateEmailCampaign
mkUpdateEmailCampaign =
  UpdateEmailCampaign
  { updateEmailCampaignTag = Nothing
  , updateEmailCampaignSender = Nothing
  , updateEmailCampaignName = Nothing
  , updateEmailCampaignHtmlContent = Nothing
  , updateEmailCampaignHtmlUrl = Nothing
  , updateEmailCampaignScheduledAt = Nothing
  , updateEmailCampaignSubject = Nothing
  , updateEmailCampaignReplyTo = Nothing
  , updateEmailCampaignToField = Nothing
  , updateEmailCampaignRecipients = Nothing
  , updateEmailCampaignAttachmentUrl = Nothing
  , updateEmailCampaignInlineImageActivation = Nothing
  , updateEmailCampaignMirrorActive = Nothing
  , updateEmailCampaignRecurring = Nothing
  , updateEmailCampaignFooter = Nothing
  , updateEmailCampaignHeader = Nothing
  , updateEmailCampaignUtmCampaign = Nothing
  , updateEmailCampaignParams = Nothing
  , updateEmailCampaignSendAtBestTime = Nothing
  , updateEmailCampaignAbTesting = Nothing
  , updateEmailCampaignSubjectA = Nothing
  , updateEmailCampaignSubjectB = Nothing
  , updateEmailCampaignSplitRule = Nothing
  , updateEmailCampaignWinnerCriteria = Nothing
  , updateEmailCampaignWinnerDelay = Nothing
  , updateEmailCampaignIpWarmupEnable = Nothing
  , updateEmailCampaignInitialQuota = Nothing
  , updateEmailCampaignIncreaseRate = Nothing
  }

-- ** UpdateEmailCampaignRecipients
-- | UpdateEmailCampaignRecipients
-- List ids to include/exclude from campaign
data UpdateEmailCampaignRecipients = UpdateEmailCampaignRecipients
  { updateEmailCampaignRecipientsExclusionListIds :: !(Maybe [Integer]) -- ^ "exclusionListIds" - List ids which have to be excluded from a campaign
  , updateEmailCampaignRecipientsListIds :: !(Maybe [Integer]) -- ^ "listIds" - Lists Ids to send the campaign to. REQUIRED if already not present in campaign and scheduledAt is not empty
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateEmailCampaignRecipients
instance A.FromJSON UpdateEmailCampaignRecipients where
  parseJSON = A.withObject "UpdateEmailCampaignRecipients" $ \o ->
    UpdateEmailCampaignRecipients
      <$> (o .:? "exclusionListIds")
      <*> (o .:? "listIds")

-- | ToJSON UpdateEmailCampaignRecipients
instance A.ToJSON UpdateEmailCampaignRecipients where
  toJSON UpdateEmailCampaignRecipients {..} =
   _omitNulls
      [ "exclusionListIds" .= updateEmailCampaignRecipientsExclusionListIds
      , "listIds" .= updateEmailCampaignRecipientsListIds
      ]


-- | Construct a value of type 'UpdateEmailCampaignRecipients' (by applying it's required fields, if any)
mkUpdateEmailCampaignRecipients
  :: UpdateEmailCampaignRecipients
mkUpdateEmailCampaignRecipients =
  UpdateEmailCampaignRecipients
  { updateEmailCampaignRecipientsExclusionListIds = Nothing
  , updateEmailCampaignRecipientsListIds = Nothing
  }

-- ** UpdateEmailCampaignSender
-- | UpdateEmailCampaignSender
-- Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
data UpdateEmailCampaignSender = UpdateEmailCampaignSender
  { updateEmailCampaignSenderName :: !(Maybe Text) -- ^ "name" - Sender Name from which the campaign emails are sent
  , updateEmailCampaignSenderEmail :: !(Maybe Text) -- ^ "email" - Sender email from which the campaign emails are sent
  , updateEmailCampaignSenderId :: !(Maybe Integer) -- ^ "id" - Select the sender for the campaign on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateEmailCampaignSender
instance A.FromJSON UpdateEmailCampaignSender where
  parseJSON = A.withObject "UpdateEmailCampaignSender" $ \o ->
    UpdateEmailCampaignSender
      <$> (o .:? "name")
      <*> (o .:? "email")
      <*> (o .:? "id")

-- | ToJSON UpdateEmailCampaignSender
instance A.ToJSON UpdateEmailCampaignSender where
  toJSON UpdateEmailCampaignSender {..} =
   _omitNulls
      [ "name" .= updateEmailCampaignSenderName
      , "email" .= updateEmailCampaignSenderEmail
      , "id" .= updateEmailCampaignSenderId
      ]


-- | Construct a value of type 'UpdateEmailCampaignSender' (by applying it's required fields, if any)
mkUpdateEmailCampaignSender
  :: UpdateEmailCampaignSender
mkUpdateEmailCampaignSender =
  UpdateEmailCampaignSender
  { updateEmailCampaignSenderName = Nothing
  , updateEmailCampaignSenderEmail = Nothing
  , updateEmailCampaignSenderId = Nothing
  }

-- ** UpdateList
-- | UpdateList
data UpdateList = UpdateList
  { updateListName :: !(Maybe Text) -- ^ "name" - Name of the list. Either of the two parameters (name, folderId) can be updated at a time.
  , updateListFolderId :: !(Maybe Integer) -- ^ "folderId" - Id of the folder in which the list is to be moved. Either of the two parameters (name, folderId) can be updated at a time.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateList
instance A.FromJSON UpdateList where
  parseJSON = A.withObject "UpdateList" $ \o ->
    UpdateList
      <$> (o .:? "name")
      <*> (o .:? "folderId")

-- | ToJSON UpdateList
instance A.ToJSON UpdateList where
  toJSON UpdateList {..} =
   _omitNulls
      [ "name" .= updateListName
      , "folderId" .= updateListFolderId
      ]


-- | Construct a value of type 'UpdateList' (by applying it's required fields, if any)
mkUpdateList
  :: UpdateList
mkUpdateList =
  UpdateList
  { updateListName = Nothing
  , updateListFolderId = Nothing
  }

-- ** UpdateSender
-- | UpdateSender
data UpdateSender = UpdateSender
  { updateSenderName :: !(Maybe Text) -- ^ "name" - From Name to update the sender
  , updateSenderEmail :: !(Maybe Text) -- ^ "email" - From Email to update the sender
  , updateSenderIps :: !(Maybe [CreateSenderIps]) -- ^ "ips" - Only in case of dedicated IP, IPs to associate to the sender. If passed, will replace all the existing IPs.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateSender
instance A.FromJSON UpdateSender where
  parseJSON = A.withObject "UpdateSender" $ \o ->
    UpdateSender
      <$> (o .:? "name")
      <*> (o .:? "email")
      <*> (o .:? "ips")

-- | ToJSON UpdateSender
instance A.ToJSON UpdateSender where
  toJSON UpdateSender {..} =
   _omitNulls
      [ "name" .= updateSenderName
      , "email" .= updateSenderEmail
      , "ips" .= updateSenderIps
      ]


-- | Construct a value of type 'UpdateSender' (by applying it's required fields, if any)
mkUpdateSender
  :: UpdateSender
mkUpdateSender =
  UpdateSender
  { updateSenderName = Nothing
  , updateSenderEmail = Nothing
  , updateSenderIps = Nothing
  }

-- ** UpdateSmsCampaign
-- | UpdateSmsCampaign
data UpdateSmsCampaign = UpdateSmsCampaign
  { updateSmsCampaignName :: !(Maybe Text) -- ^ "name" - Name of the campaign
  , updateSmsCampaignSender :: !(Maybe Text) -- ^ "sender" - Name of the sender. The number of characters is limited to 11
  , updateSmsCampaignContent :: !(Maybe Text) -- ^ "content" - Content of the message. The maximum characters used per SMS is 160, if used more than that, it will be counted as more than one SMS
  , updateSmsCampaignRecipients :: !(Maybe CreateSmsCampaignRecipients) -- ^ "recipients"
  , updateSmsCampaignScheduledAt :: !(Maybe DateTime) -- ^ "scheduledAt" - UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateSmsCampaign
instance A.FromJSON UpdateSmsCampaign where
  parseJSON = A.withObject "UpdateSmsCampaign" $ \o ->
    UpdateSmsCampaign
      <$> (o .:? "name")
      <*> (o .:? "sender")
      <*> (o .:? "content")
      <*> (o .:? "recipients")
      <*> (o .:? "scheduledAt")

-- | ToJSON UpdateSmsCampaign
instance A.ToJSON UpdateSmsCampaign where
  toJSON UpdateSmsCampaign {..} =
   _omitNulls
      [ "name" .= updateSmsCampaignName
      , "sender" .= updateSmsCampaignSender
      , "content" .= updateSmsCampaignContent
      , "recipients" .= updateSmsCampaignRecipients
      , "scheduledAt" .= updateSmsCampaignScheduledAt
      ]


-- | Construct a value of type 'UpdateSmsCampaign' (by applying it's required fields, if any)
mkUpdateSmsCampaign
  :: UpdateSmsCampaign
mkUpdateSmsCampaign =
  UpdateSmsCampaign
  { updateSmsCampaignName = Nothing
  , updateSmsCampaignSender = Nothing
  , updateSmsCampaignContent = Nothing
  , updateSmsCampaignRecipients = Nothing
  , updateSmsCampaignScheduledAt = Nothing
  }

-- ** UpdateSmtpTemplate
-- | UpdateSmtpTemplate
data UpdateSmtpTemplate = UpdateSmtpTemplate
  { updateSmtpTemplateTag :: !(Maybe Text) -- ^ "tag" - Tag of the template
  , updateSmtpTemplateSender :: !(Maybe UpdateSmtpTemplateSender) -- ^ "sender"
  , updateSmtpTemplateTemplateName :: !(Maybe Text) -- ^ "templateName" - Name of the template
  , updateSmtpTemplateHtmlContent :: !(Maybe Text) -- ^ "htmlContent" - Required if htmlUrl is empty. Body of the message (HTML must have more than 10 characters)
  , updateSmtpTemplateHtmlUrl :: !(Maybe Text) -- ^ "htmlUrl" - Required if htmlContent is empty. URL to the body of the email (HTML)
  , updateSmtpTemplateSubject :: !(Maybe Text) -- ^ "subject" - Subject of the email
  , updateSmtpTemplateReplyTo :: !(Maybe Text) -- ^ "replyTo" - Email on which campaign recipients will be able to reply to
  , updateSmtpTemplateToField :: !(Maybe Text) -- ^ "toField" - To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter &#39;params&#39; used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
  , updateSmtpTemplateAttachmentUrl :: !(Maybe Text) -- ^ "attachmentUrl" - Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
  , updateSmtpTemplateIsActive :: !(Maybe Bool) -- ^ "isActive" - Status of the template. isActive &#x3D; false means template is inactive, isActive &#x3D; true means template is active
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateSmtpTemplate
instance A.FromJSON UpdateSmtpTemplate where
  parseJSON = A.withObject "UpdateSmtpTemplate" $ \o ->
    UpdateSmtpTemplate
      <$> (o .:? "tag")
      <*> (o .:? "sender")
      <*> (o .:? "templateName")
      <*> (o .:? "htmlContent")
      <*> (o .:? "htmlUrl")
      <*> (o .:? "subject")
      <*> (o .:? "replyTo")
      <*> (o .:? "toField")
      <*> (o .:? "attachmentUrl")
      <*> (o .:? "isActive")

-- | ToJSON UpdateSmtpTemplate
instance A.ToJSON UpdateSmtpTemplate where
  toJSON UpdateSmtpTemplate {..} =
   _omitNulls
      [ "tag" .= updateSmtpTemplateTag
      , "sender" .= updateSmtpTemplateSender
      , "templateName" .= updateSmtpTemplateTemplateName
      , "htmlContent" .= updateSmtpTemplateHtmlContent
      , "htmlUrl" .= updateSmtpTemplateHtmlUrl
      , "subject" .= updateSmtpTemplateSubject
      , "replyTo" .= updateSmtpTemplateReplyTo
      , "toField" .= updateSmtpTemplateToField
      , "attachmentUrl" .= updateSmtpTemplateAttachmentUrl
      , "isActive" .= updateSmtpTemplateIsActive
      ]


-- | Construct a value of type 'UpdateSmtpTemplate' (by applying it's required fields, if any)
mkUpdateSmtpTemplate
  :: UpdateSmtpTemplate
mkUpdateSmtpTemplate =
  UpdateSmtpTemplate
  { updateSmtpTemplateTag = Nothing
  , updateSmtpTemplateSender = Nothing
  , updateSmtpTemplateTemplateName = Nothing
  , updateSmtpTemplateHtmlContent = Nothing
  , updateSmtpTemplateHtmlUrl = Nothing
  , updateSmtpTemplateSubject = Nothing
  , updateSmtpTemplateReplyTo = Nothing
  , updateSmtpTemplateToField = Nothing
  , updateSmtpTemplateAttachmentUrl = Nothing
  , updateSmtpTemplateIsActive = Nothing
  }

-- ** UpdateSmtpTemplateSender
-- | UpdateSmtpTemplateSender
-- Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
data UpdateSmtpTemplateSender = UpdateSmtpTemplateSender
  { updateSmtpTemplateSenderName :: !(Maybe Text) -- ^ "name" - Name of the sender
  , updateSmtpTemplateSenderEmail :: !(Maybe Text) -- ^ "email" - Email of the sender
  , updateSmtpTemplateSenderId :: !(Maybe Integer) -- ^ "id" - Select the sender for the template on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateSmtpTemplateSender
instance A.FromJSON UpdateSmtpTemplateSender where
  parseJSON = A.withObject "UpdateSmtpTemplateSender" $ \o ->
    UpdateSmtpTemplateSender
      <$> (o .:? "name")
      <*> (o .:? "email")
      <*> (o .:? "id")

-- | ToJSON UpdateSmtpTemplateSender
instance A.ToJSON UpdateSmtpTemplateSender where
  toJSON UpdateSmtpTemplateSender {..} =
   _omitNulls
      [ "name" .= updateSmtpTemplateSenderName
      , "email" .= updateSmtpTemplateSenderEmail
      , "id" .= updateSmtpTemplateSenderId
      ]


-- | Construct a value of type 'UpdateSmtpTemplateSender' (by applying it's required fields, if any)
mkUpdateSmtpTemplateSender
  :: UpdateSmtpTemplateSender
mkUpdateSmtpTemplateSender =
  UpdateSmtpTemplateSender
  { updateSmtpTemplateSenderName = Nothing
  , updateSmtpTemplateSenderEmail = Nothing
  , updateSmtpTemplateSenderId = Nothing
  }

-- ** UpdateWebhook
-- | UpdateWebhook
data UpdateWebhook = UpdateWebhook
  { updateWebhookUrl :: !(Maybe Text) -- ^ "url" - URL of the webhook
  , updateWebhookDescription :: !(Maybe Text) -- ^ "description" - Description of the webhook
  , updateWebhookEvents :: !(Maybe [E'Events]) -- ^ "events" - Events triggering the webhook. Possible values for Transactional type webhook – request, delivered, hardBounce, softBounce, blocked, spam, invalid, deferred, click, opened, uniqueOpened and unsubscribed and possible values for Marketing type webhook – spam, opened, click, hardBounce, softBounce, unsubscribed, listAddition and delivered
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateWebhook
instance A.FromJSON UpdateWebhook where
  parseJSON = A.withObject "UpdateWebhook" $ \o ->
    UpdateWebhook
      <$> (o .:? "url")
      <*> (o .:? "description")
      <*> (o .:? "events")

-- | ToJSON UpdateWebhook
instance A.ToJSON UpdateWebhook where
  toJSON UpdateWebhook {..} =
   _omitNulls
      [ "url" .= updateWebhookUrl
      , "description" .= updateWebhookDescription
      , "events" .= updateWebhookEvents
      ]


-- | Construct a value of type 'UpdateWebhook' (by applying it's required fields, if any)
mkUpdateWebhook
  :: UpdateWebhook
mkUpdateWebhook =
  UpdateWebhook
  { updateWebhookUrl = Nothing
  , updateWebhookDescription = Nothing
  , updateWebhookEvents = Nothing
  }

-- ** GetChildInfo
-- | GetChildInfo
data GetChildInfo = GetChildInfo
  { getChildInfoEmail :: !(Text) -- ^ /Required/ "email" - Login Email
  , getChildInfoFirstName :: !(Text) -- ^ /Required/ "firstName" - First Name
  , getChildInfoLastName :: !(Text) -- ^ /Required/ "lastName" - Last Name
  , getChildInfoCompanyName :: !(Text) -- ^ /Required/ "companyName" - Name of the company
  , getChildInfoCredits :: !(Maybe GetChildInfoCredits) -- ^ "credits"
  , getChildInfoStatistics :: !(Maybe GetChildInfoStatistics) -- ^ "statistics"
  , getChildInfoPassword :: !(Text) -- ^ /Required/ "password" - The encrypted password of child account
  , getChildInfoIps :: !(Maybe [Text]) -- ^ "ips" - IP(s) associated to a child account user
  , getChildInfoApiKeys :: !(Maybe GetChildInfoApiKeys) -- ^ "apiKeys"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChildInfo
instance A.FromJSON GetChildInfo where
  parseJSON = A.withObject "GetChildInfo" $ \o ->
    GetChildInfo
      <$> (o .:  "email")
      <*> (o .:  "firstName")
      <*> (o .:  "lastName")
      <*> (o .:  "companyName")
      <*> (o .:? "credits")
      <*> (o .:? "statistics")
      <*> (o .:  "password")
      <*> (o .:? "ips")
      <*> (o .:? "apiKeys")

-- | ToJSON GetChildInfo
instance A.ToJSON GetChildInfo where
  toJSON GetChildInfo {..} =
   _omitNulls
      [ "email" .= getChildInfoEmail
      , "firstName" .= getChildInfoFirstName
      , "lastName" .= getChildInfoLastName
      , "companyName" .= getChildInfoCompanyName
      , "credits" .= getChildInfoCredits
      , "statistics" .= getChildInfoStatistics
      , "password" .= getChildInfoPassword
      , "ips" .= getChildInfoIps
      , "apiKeys" .= getChildInfoApiKeys
      ]


-- | Construct a value of type 'GetChildInfo' (by applying it's required fields, if any)
mkGetChildInfo
  :: Text -- ^ 'getChildInfoEmail': Login Email
  -> Text -- ^ 'getChildInfoFirstName': First Name
  -> Text -- ^ 'getChildInfoLastName': Last Name
  -> Text -- ^ 'getChildInfoCompanyName': Name of the company
  -> Text -- ^ 'getChildInfoPassword': The encrypted password of child account
  -> GetChildInfo
mkGetChildInfo getChildInfoEmail getChildInfoFirstName getChildInfoLastName getChildInfoCompanyName getChildInfoPassword =
  GetChildInfo
  { getChildInfoEmail
  , getChildInfoFirstName
  , getChildInfoLastName
  , getChildInfoCompanyName
  , getChildInfoCredits = Nothing
  , getChildInfoStatistics = Nothing
  , getChildInfoPassword
  , getChildInfoIps = Nothing
  , getChildInfoApiKeys = Nothing
  }

-- ** GetExtendedCampaignOverview
-- | GetExtendedCampaignOverview
data GetExtendedCampaignOverview = GetExtendedCampaignOverview
  { getExtendedCampaignOverviewId :: !(Integer) -- ^ /Required/ "id" - ID of the campaign
  , getExtendedCampaignOverviewName :: !(Text) -- ^ /Required/ "name" - Name of the campaign
  , getExtendedCampaignOverviewSubject :: !(Maybe Text) -- ^ "subject" - Subject of the campaign. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;false&#x60;
  , getExtendedCampaignOverviewType :: !(E'Type) -- ^ /Required/ "type" - Type of campaign
  , getExtendedCampaignOverviewStatus :: !(E'Status3) -- ^ /Required/ "status" - Status of the campaign
  , getExtendedCampaignOverviewScheduledAt :: !(Maybe DateTime) -- ^ "scheduledAt" - UTC date-time on which campaign is scheduled (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getExtendedCampaignOverviewAbTesting :: !(Maybe Bool) -- ^ "abTesting" - Status of A/B Test for the campaign. abTesting &#x3D; false means it is disabled, &amp; abTesting &#x3D; true means it is enabled.
  , getExtendedCampaignOverviewSubjectA :: !(Maybe Text) -- ^ "subjectA" - Subject A of the ab-test campaign. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getExtendedCampaignOverviewSubjectB :: !(Maybe Text) -- ^ "subjectB" - Subject B of the ab-test campaign. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getExtendedCampaignOverviewSplitRule :: !(Maybe Int) -- ^ "splitRule" - The size of your ab-test groups. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getExtendedCampaignOverviewWinnerCriteria :: !(Maybe Text) -- ^ "winnerCriteria" - Criteria for the winning version. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getExtendedCampaignOverviewWinnerDelay :: !(Maybe Int) -- ^ "winnerDelay" - The duration of the test in hours at the end of which the winning version will be sent. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getExtendedCampaignOverviewSendAtBestTime :: !(Maybe Bool) -- ^ "sendAtBestTime" - It is true if you have chosen to send your campaign at best time, otherwise it is false
  , getExtendedCampaignOverviewTestSent :: !(Bool) -- ^ /Required/ "testSent" - Retrieved the status of test email sending. (true&#x3D;Test email has been sent  false&#x3D;Test email has not been sent)
  , getExtendedCampaignOverviewHeader :: !(Text) -- ^ /Required/ "header" - Header of the campaign
  , getExtendedCampaignOverviewFooter :: !(Text) -- ^ /Required/ "footer" - Footer of the campaign
  , getExtendedCampaignOverviewSender :: !(GetExtendedCampaignOverviewSender) -- ^ /Required/ "sender"
  , getExtendedCampaignOverviewReplyTo :: !(Text) -- ^ /Required/ "replyTo" - Email defined as the \&quot;Reply to\&quot; of the campaign
  , getExtendedCampaignOverviewToField :: !(Text) -- ^ /Required/ "toField" - Customisation of the \&quot;to\&quot; field of the campaign
  , getExtendedCampaignOverviewHtmlContent :: !(Text) -- ^ /Required/ "htmlContent" - HTML content of the campaign
  , getExtendedCampaignOverviewShareLink :: !(Maybe Text) -- ^ "shareLink" - Link to share the campaign on social medias
  , getExtendedCampaignOverviewTag :: !(Text) -- ^ /Required/ "tag" - Tag of the campaign
  , getExtendedCampaignOverviewCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Creation UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getExtendedCampaignOverviewModifiedAt :: !(DateTime) -- ^ /Required/ "modifiedAt" - UTC date-time of last modification of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getExtendedCampaignOverviewInlineImageActivation :: !(Maybe Bool) -- ^ "inlineImageActivation" - Status of inline image. inlineImageActivation &#x3D; false means image can’t be embedded, &amp; inlineImageActivation &#x3D; true means image can be embedded, in the email.
  , getExtendedCampaignOverviewMirrorActive :: !(Maybe Bool) -- ^ "mirrorActive" - Status of mirror links in campaign. mirrorActive &#x3D; false means mirror links are deactivated, &amp; mirrorActive &#x3D; true means mirror links are activated, in the campaign
  , getExtendedCampaignOverviewRecurring :: !(Maybe Bool) -- ^ "recurring" - FOR TRIGGER ONLY ! Type of trigger campaign.recurring &#x3D; false means contact can receive the same Trigger campaign only once, &amp; recurring &#x3D; true means contact can receive the same Trigger campaign several times
  , getExtendedCampaignOverviewSentDate :: !(Maybe DateTime) -- ^ "sentDate" - Sent UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ). Only available if &#39;status&#39; of the campaign is &#39;sent&#39;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedCampaignOverview
instance A.FromJSON GetExtendedCampaignOverview where
  parseJSON = A.withObject "GetExtendedCampaignOverview" $ \o ->
    GetExtendedCampaignOverview
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:? "subject")
      <*> (o .:  "type")
      <*> (o .:  "status")
      <*> (o .:? "scheduledAt")
      <*> (o .:? "abTesting")
      <*> (o .:? "subjectA")
      <*> (o .:? "subjectB")
      <*> (o .:? "splitRule")
      <*> (o .:? "winnerCriteria")
      <*> (o .:? "winnerDelay")
      <*> (o .:? "sendAtBestTime")
      <*> (o .:  "testSent")
      <*> (o .:  "header")
      <*> (o .:  "footer")
      <*> (o .:  "sender")
      <*> (o .:  "replyTo")
      <*> (o .:  "toField")
      <*> (o .:  "htmlContent")
      <*> (o .:? "shareLink")
      <*> (o .:  "tag")
      <*> (o .:  "createdAt")
      <*> (o .:  "modifiedAt")
      <*> (o .:? "inlineImageActivation")
      <*> (o .:? "mirrorActive")
      <*> (o .:? "recurring")
      <*> (o .:? "sentDate")

-- | ToJSON GetExtendedCampaignOverview
instance A.ToJSON GetExtendedCampaignOverview where
  toJSON GetExtendedCampaignOverview {..} =
   _omitNulls
      [ "id" .= getExtendedCampaignOverviewId
      , "name" .= getExtendedCampaignOverviewName
      , "subject" .= getExtendedCampaignOverviewSubject
      , "type" .= getExtendedCampaignOverviewType
      , "status" .= getExtendedCampaignOverviewStatus
      , "scheduledAt" .= getExtendedCampaignOverviewScheduledAt
      , "abTesting" .= getExtendedCampaignOverviewAbTesting
      , "subjectA" .= getExtendedCampaignOverviewSubjectA
      , "subjectB" .= getExtendedCampaignOverviewSubjectB
      , "splitRule" .= getExtendedCampaignOverviewSplitRule
      , "winnerCriteria" .= getExtendedCampaignOverviewWinnerCriteria
      , "winnerDelay" .= getExtendedCampaignOverviewWinnerDelay
      , "sendAtBestTime" .= getExtendedCampaignOverviewSendAtBestTime
      , "testSent" .= getExtendedCampaignOverviewTestSent
      , "header" .= getExtendedCampaignOverviewHeader
      , "footer" .= getExtendedCampaignOverviewFooter
      , "sender" .= getExtendedCampaignOverviewSender
      , "replyTo" .= getExtendedCampaignOverviewReplyTo
      , "toField" .= getExtendedCampaignOverviewToField
      , "htmlContent" .= getExtendedCampaignOverviewHtmlContent
      , "shareLink" .= getExtendedCampaignOverviewShareLink
      , "tag" .= getExtendedCampaignOverviewTag
      , "createdAt" .= getExtendedCampaignOverviewCreatedAt
      , "modifiedAt" .= getExtendedCampaignOverviewModifiedAt
      , "inlineImageActivation" .= getExtendedCampaignOverviewInlineImageActivation
      , "mirrorActive" .= getExtendedCampaignOverviewMirrorActive
      , "recurring" .= getExtendedCampaignOverviewRecurring
      , "sentDate" .= getExtendedCampaignOverviewSentDate
      ]


-- | Construct a value of type 'GetExtendedCampaignOverview' (by applying it's required fields, if any)
mkGetExtendedCampaignOverview
  :: Integer -- ^ 'getExtendedCampaignOverviewId': ID of the campaign
  -> Text -- ^ 'getExtendedCampaignOverviewName': Name of the campaign
  -> E'Type -- ^ 'getExtendedCampaignOverviewType': Type of campaign
  -> E'Status3 -- ^ 'getExtendedCampaignOverviewStatus': Status of the campaign
  -> Bool -- ^ 'getExtendedCampaignOverviewTestSent': Retrieved the status of test email sending. (true=Test email has been sent  false=Test email has not been sent)
  -> Text -- ^ 'getExtendedCampaignOverviewHeader': Header of the campaign
  -> Text -- ^ 'getExtendedCampaignOverviewFooter': Footer of the campaign
  -> GetExtendedCampaignOverviewSender -- ^ 'getExtendedCampaignOverviewSender' 
  -> Text -- ^ 'getExtendedCampaignOverviewReplyTo': Email defined as the \"Reply to\" of the campaign
  -> Text -- ^ 'getExtendedCampaignOverviewToField': Customisation of the \"to\" field of the campaign
  -> Text -- ^ 'getExtendedCampaignOverviewHtmlContent': HTML content of the campaign
  -> Text -- ^ 'getExtendedCampaignOverviewTag': Tag of the campaign
  -> DateTime -- ^ 'getExtendedCampaignOverviewCreatedAt': Creation UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> DateTime -- ^ 'getExtendedCampaignOverviewModifiedAt': UTC date-time of last modification of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> GetExtendedCampaignOverview
mkGetExtendedCampaignOverview getExtendedCampaignOverviewId getExtendedCampaignOverviewName getExtendedCampaignOverviewType getExtendedCampaignOverviewStatus getExtendedCampaignOverviewTestSent getExtendedCampaignOverviewHeader getExtendedCampaignOverviewFooter getExtendedCampaignOverviewSender getExtendedCampaignOverviewReplyTo getExtendedCampaignOverviewToField getExtendedCampaignOverviewHtmlContent getExtendedCampaignOverviewTag getExtendedCampaignOverviewCreatedAt getExtendedCampaignOverviewModifiedAt =
  GetExtendedCampaignOverview
  { getExtendedCampaignOverviewId
  , getExtendedCampaignOverviewName
  , getExtendedCampaignOverviewSubject = Nothing
  , getExtendedCampaignOverviewType
  , getExtendedCampaignOverviewStatus
  , getExtendedCampaignOverviewScheduledAt = Nothing
  , getExtendedCampaignOverviewAbTesting = Nothing
  , getExtendedCampaignOverviewSubjectA = Nothing
  , getExtendedCampaignOverviewSubjectB = Nothing
  , getExtendedCampaignOverviewSplitRule = Nothing
  , getExtendedCampaignOverviewWinnerCriteria = Nothing
  , getExtendedCampaignOverviewWinnerDelay = Nothing
  , getExtendedCampaignOverviewSendAtBestTime = Nothing
  , getExtendedCampaignOverviewTestSent
  , getExtendedCampaignOverviewHeader
  , getExtendedCampaignOverviewFooter
  , getExtendedCampaignOverviewSender
  , getExtendedCampaignOverviewReplyTo
  , getExtendedCampaignOverviewToField
  , getExtendedCampaignOverviewHtmlContent
  , getExtendedCampaignOverviewShareLink = Nothing
  , getExtendedCampaignOverviewTag
  , getExtendedCampaignOverviewCreatedAt
  , getExtendedCampaignOverviewModifiedAt
  , getExtendedCampaignOverviewInlineImageActivation = Nothing
  , getExtendedCampaignOverviewMirrorActive = Nothing
  , getExtendedCampaignOverviewRecurring = Nothing
  , getExtendedCampaignOverviewSentDate = Nothing
  }

-- ** GetExtendedClient
-- | GetExtendedClient
data GetExtendedClient = GetExtendedClient
  { getExtendedClientEmail :: !(Text) -- ^ /Required/ "email" - Login Email
  , getExtendedClientFirstName :: !(Text) -- ^ /Required/ "firstName" - First Name
  , getExtendedClientLastName :: !(Text) -- ^ /Required/ "lastName" - Last Name
  , getExtendedClientCompanyName :: !(Text) -- ^ /Required/ "companyName" - Name of the company
  , getExtendedClientAddress :: !(GetExtendedClientAddress) -- ^ /Required/ "address"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedClient
instance A.FromJSON GetExtendedClient where
  parseJSON = A.withObject "GetExtendedClient" $ \o ->
    GetExtendedClient
      <$> (o .:  "email")
      <*> (o .:  "firstName")
      <*> (o .:  "lastName")
      <*> (o .:  "companyName")
      <*> (o .:  "address")

-- | ToJSON GetExtendedClient
instance A.ToJSON GetExtendedClient where
  toJSON GetExtendedClient {..} =
   _omitNulls
      [ "email" .= getExtendedClientEmail
      , "firstName" .= getExtendedClientFirstName
      , "lastName" .= getExtendedClientLastName
      , "companyName" .= getExtendedClientCompanyName
      , "address" .= getExtendedClientAddress
      ]


-- | Construct a value of type 'GetExtendedClient' (by applying it's required fields, if any)
mkGetExtendedClient
  :: Text -- ^ 'getExtendedClientEmail': Login Email
  -> Text -- ^ 'getExtendedClientFirstName': First Name
  -> Text -- ^ 'getExtendedClientLastName': Last Name
  -> Text -- ^ 'getExtendedClientCompanyName': Name of the company
  -> GetExtendedClientAddress -- ^ 'getExtendedClientAddress' 
  -> GetExtendedClient
mkGetExtendedClient getExtendedClientEmail getExtendedClientFirstName getExtendedClientLastName getExtendedClientCompanyName getExtendedClientAddress =
  GetExtendedClient
  { getExtendedClientEmail
  , getExtendedClientFirstName
  , getExtendedClientLastName
  , getExtendedClientCompanyName
  , getExtendedClientAddress
  }

-- ** GetExtendedContactDetails
-- | GetExtendedContactDetails
data GetExtendedContactDetails = GetExtendedContactDetails
  { getExtendedContactDetailsEmail :: !(Text) -- ^ /Required/ "email" - Email address of the contact for which you requested the details
  , getExtendedContactDetailsId :: !(Integer) -- ^ /Required/ "id" - ID of the contact for which you requested the details
  , getExtendedContactDetailsEmailBlacklisted :: !(Bool) -- ^ /Required/ "emailBlacklisted" - Blacklist status for email campaigns (true&#x3D;blacklisted, false&#x3D;not blacklisted)
  , getExtendedContactDetailsSmsBlacklisted :: !(Bool) -- ^ /Required/ "smsBlacklisted" - Blacklist status for SMS campaigns (true&#x3D;blacklisted, false&#x3D;not blacklisted)
  , getExtendedContactDetailsCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Creation UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getExtendedContactDetailsModifiedAt :: !(DateTime) -- ^ /Required/ "modifiedAt" - Last modification UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getExtendedContactDetailsListIds :: !([Integer]) -- ^ /Required/ "listIds"
  , getExtendedContactDetailsListUnsubscribed :: !(Maybe [Integer]) -- ^ "listUnsubscribed"
  , getExtendedContactDetailsAttributes :: !(A.Value) -- ^ /Required/ "attributes" - Set of attributes of the contact
  , getExtendedContactDetailsStatistics :: !(GetExtendedContactDetailsStatistics) -- ^ /Required/ "statistics"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedContactDetails
instance A.FromJSON GetExtendedContactDetails where
  parseJSON = A.withObject "GetExtendedContactDetails" $ \o ->
    GetExtendedContactDetails
      <$> (o .:  "email")
      <*> (o .:  "id")
      <*> (o .:  "emailBlacklisted")
      <*> (o .:  "smsBlacklisted")
      <*> (o .:  "createdAt")
      <*> (o .:  "modifiedAt")
      <*> (o .:  "listIds")
      <*> (o .:? "listUnsubscribed")
      <*> (o .:  "attributes")
      <*> (o .:  "statistics")

-- | ToJSON GetExtendedContactDetails
instance A.ToJSON GetExtendedContactDetails where
  toJSON GetExtendedContactDetails {..} =
   _omitNulls
      [ "email" .= getExtendedContactDetailsEmail
      , "id" .= getExtendedContactDetailsId
      , "emailBlacklisted" .= getExtendedContactDetailsEmailBlacklisted
      , "smsBlacklisted" .= getExtendedContactDetailsSmsBlacklisted
      , "createdAt" .= getExtendedContactDetailsCreatedAt
      , "modifiedAt" .= getExtendedContactDetailsModifiedAt
      , "listIds" .= getExtendedContactDetailsListIds
      , "listUnsubscribed" .= getExtendedContactDetailsListUnsubscribed
      , "attributes" .= getExtendedContactDetailsAttributes
      , "statistics" .= getExtendedContactDetailsStatistics
      ]


-- | Construct a value of type 'GetExtendedContactDetails' (by applying it's required fields, if any)
mkGetExtendedContactDetails
  :: Text -- ^ 'getExtendedContactDetailsEmail': Email address of the contact for which you requested the details
  -> Integer -- ^ 'getExtendedContactDetailsId': ID of the contact for which you requested the details
  -> Bool -- ^ 'getExtendedContactDetailsEmailBlacklisted': Blacklist status for email campaigns (true=blacklisted, false=not blacklisted)
  -> Bool -- ^ 'getExtendedContactDetailsSmsBlacklisted': Blacklist status for SMS campaigns (true=blacklisted, false=not blacklisted)
  -> DateTime -- ^ 'getExtendedContactDetailsCreatedAt': Creation UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> DateTime -- ^ 'getExtendedContactDetailsModifiedAt': Last modification UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> [Integer] -- ^ 'getExtendedContactDetailsListIds' 
  -> A.Value -- ^ 'getExtendedContactDetailsAttributes': Set of attributes of the contact
  -> GetExtendedContactDetailsStatistics -- ^ 'getExtendedContactDetailsStatistics' 
  -> GetExtendedContactDetails
mkGetExtendedContactDetails getExtendedContactDetailsEmail getExtendedContactDetailsId getExtendedContactDetailsEmailBlacklisted getExtendedContactDetailsSmsBlacklisted getExtendedContactDetailsCreatedAt getExtendedContactDetailsModifiedAt getExtendedContactDetailsListIds getExtendedContactDetailsAttributes getExtendedContactDetailsStatistics =
  GetExtendedContactDetails
  { getExtendedContactDetailsEmail
  , getExtendedContactDetailsId
  , getExtendedContactDetailsEmailBlacklisted
  , getExtendedContactDetailsSmsBlacklisted
  , getExtendedContactDetailsCreatedAt
  , getExtendedContactDetailsModifiedAt
  , getExtendedContactDetailsListIds
  , getExtendedContactDetailsListUnsubscribed = Nothing
  , getExtendedContactDetailsAttributes
  , getExtendedContactDetailsStatistics
  }

-- ** GetExtendedList
-- | GetExtendedList
data GetExtendedList = GetExtendedList
  { getExtendedListId :: !(Integer) -- ^ /Required/ "id" - ID of the list
  , getExtendedListName :: !(Text) -- ^ /Required/ "name" - Name of the list
  , getExtendedListTotalBlacklisted :: !(Integer) -- ^ /Required/ "totalBlacklisted" - Number of blacklisted contacts in the list
  , getExtendedListTotalSubscribers :: !(Integer) -- ^ /Required/ "totalSubscribers" - Number of contacts in the list
  , getExtendedListFolderId :: !(Integer) -- ^ /Required/ "folderId" - ID of the folder
  , getExtendedListCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Creation UTC date-time of the list (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getExtendedListCampaignStats :: !(Maybe [GetExtendedListCampaignStats]) -- ^ "campaignStats"
  , getExtendedListDynamicList :: !(Maybe Bool) -- ^ "dynamicList" - Status telling if the list is dynamic or not (true&#x3D;dynamic, false&#x3D;not dynamic)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetExtendedList
instance A.FromJSON GetExtendedList where
  parseJSON = A.withObject "GetExtendedList" $ \o ->
    GetExtendedList
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "totalBlacklisted")
      <*> (o .:  "totalSubscribers")
      <*> (o .:  "folderId")
      <*> (o .:  "createdAt")
      <*> (o .:? "campaignStats")
      <*> (o .:? "dynamicList")

-- | ToJSON GetExtendedList
instance A.ToJSON GetExtendedList where
  toJSON GetExtendedList {..} =
   _omitNulls
      [ "id" .= getExtendedListId
      , "name" .= getExtendedListName
      , "totalBlacklisted" .= getExtendedListTotalBlacklisted
      , "totalSubscribers" .= getExtendedListTotalSubscribers
      , "folderId" .= getExtendedListFolderId
      , "createdAt" .= getExtendedListCreatedAt
      , "campaignStats" .= getExtendedListCampaignStats
      , "dynamicList" .= getExtendedListDynamicList
      ]


-- | Construct a value of type 'GetExtendedList' (by applying it's required fields, if any)
mkGetExtendedList
  :: Integer -- ^ 'getExtendedListId': ID of the list
  -> Text -- ^ 'getExtendedListName': Name of the list
  -> Integer -- ^ 'getExtendedListTotalBlacklisted': Number of blacklisted contacts in the list
  -> Integer -- ^ 'getExtendedListTotalSubscribers': Number of contacts in the list
  -> Integer -- ^ 'getExtendedListFolderId': ID of the folder
  -> DateTime -- ^ 'getExtendedListCreatedAt': Creation UTC date-time of the list (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> GetExtendedList
mkGetExtendedList getExtendedListId getExtendedListName getExtendedListTotalBlacklisted getExtendedListTotalSubscribers getExtendedListFolderId getExtendedListCreatedAt =
  GetExtendedList
  { getExtendedListId
  , getExtendedListName
  , getExtendedListTotalBlacklisted
  , getExtendedListTotalSubscribers
  , getExtendedListFolderId
  , getExtendedListCreatedAt
  , getExtendedListCampaignStats = Nothing
  , getExtendedListDynamicList = Nothing
  }

-- ** GetSmsCampaign
-- | GetSmsCampaign
data GetSmsCampaign = GetSmsCampaign
  { getSmsCampaignId :: !(Integer) -- ^ /Required/ "id" - ID of the SMS Campaign
  , getSmsCampaignName :: !(Text) -- ^ /Required/ "name" - Name of the SMS Campaign
  , getSmsCampaignStatus :: !(E'Status2) -- ^ /Required/ "status" - Status of the SMS Campaign
  , getSmsCampaignContent :: !(Text) -- ^ /Required/ "content" - Content of the SMS Campaign
  , getSmsCampaignScheduledAt :: !(DateTime) -- ^ /Required/ "scheduledAt" - UTC date-time on which SMS campaign is scheduled. Should be in YYYY-MM-DDTHH:mm:ss.SSSZ format
  , getSmsCampaignSender :: !(Text) -- ^ /Required/ "sender" - Sender of the SMS Campaign
  , getSmsCampaignCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Creation UTC date-time of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getSmsCampaignModifiedAt :: !(DateTime) -- ^ /Required/ "modifiedAt" - UTC date-time of last modification of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getSmsCampaignRecipients :: !(A.Value) -- ^ /Required/ "recipients"
  , getSmsCampaignStatistics :: !(A.Value) -- ^ /Required/ "statistics"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSmsCampaign
instance A.FromJSON GetSmsCampaign where
  parseJSON = A.withObject "GetSmsCampaign" $ \o ->
    GetSmsCampaign
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "status")
      <*> (o .:  "content")
      <*> (o .:  "scheduledAt")
      <*> (o .:  "sender")
      <*> (o .:  "createdAt")
      <*> (o .:  "modifiedAt")
      <*> (o .:  "recipients")
      <*> (o .:  "statistics")

-- | ToJSON GetSmsCampaign
instance A.ToJSON GetSmsCampaign where
  toJSON GetSmsCampaign {..} =
   _omitNulls
      [ "id" .= getSmsCampaignId
      , "name" .= getSmsCampaignName
      , "status" .= getSmsCampaignStatus
      , "content" .= getSmsCampaignContent
      , "scheduledAt" .= getSmsCampaignScheduledAt
      , "sender" .= getSmsCampaignSender
      , "createdAt" .= getSmsCampaignCreatedAt
      , "modifiedAt" .= getSmsCampaignModifiedAt
      , "recipients" .= getSmsCampaignRecipients
      , "statistics" .= getSmsCampaignStatistics
      ]


-- | Construct a value of type 'GetSmsCampaign' (by applying it's required fields, if any)
mkGetSmsCampaign
  :: Integer -- ^ 'getSmsCampaignId': ID of the SMS Campaign
  -> Text -- ^ 'getSmsCampaignName': Name of the SMS Campaign
  -> E'Status2 -- ^ 'getSmsCampaignStatus': Status of the SMS Campaign
  -> Text -- ^ 'getSmsCampaignContent': Content of the SMS Campaign
  -> DateTime -- ^ 'getSmsCampaignScheduledAt': UTC date-time on which SMS campaign is scheduled. Should be in YYYY-MM-DDTHH:mm:ss.SSSZ format
  -> Text -- ^ 'getSmsCampaignSender': Sender of the SMS Campaign
  -> DateTime -- ^ 'getSmsCampaignCreatedAt': Creation UTC date-time of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> DateTime -- ^ 'getSmsCampaignModifiedAt': UTC date-time of last modification of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> A.Value -- ^ 'getSmsCampaignRecipients' 
  -> A.Value -- ^ 'getSmsCampaignStatistics' 
  -> GetSmsCampaign
mkGetSmsCampaign getSmsCampaignId getSmsCampaignName getSmsCampaignStatus getSmsCampaignContent getSmsCampaignScheduledAt getSmsCampaignSender getSmsCampaignCreatedAt getSmsCampaignModifiedAt getSmsCampaignRecipients getSmsCampaignStatistics =
  GetSmsCampaign
  { getSmsCampaignId
  , getSmsCampaignName
  , getSmsCampaignStatus
  , getSmsCampaignContent
  , getSmsCampaignScheduledAt
  , getSmsCampaignSender
  , getSmsCampaignCreatedAt
  , getSmsCampaignModifiedAt
  , getSmsCampaignRecipients
  , getSmsCampaignStatistics
  }

-- ** GetAccount
-- | GetAccount
data GetAccount = GetAccount
  { getAccountEmail :: !(Text) -- ^ /Required/ "email" - Login Email
  , getAccountFirstName :: !(Text) -- ^ /Required/ "firstName" - First Name
  , getAccountLastName :: !(Text) -- ^ /Required/ "lastName" - Last Name
  , getAccountCompanyName :: !(Text) -- ^ /Required/ "companyName" - Name of the company
  , getAccountAddress :: !(GetExtendedClientAddress) -- ^ /Required/ "address"
  , getAccountPlan :: !([GetAccountPlan]) -- ^ /Required/ "plan" - Information about your plans and credits
  , getAccountRelay :: !(GetAccountRelay) -- ^ /Required/ "relay"
  , getAccountMarketingAutomation :: !(Maybe GetAccountMarketingAutomation) -- ^ "marketingAutomation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAccount
instance A.FromJSON GetAccount where
  parseJSON = A.withObject "GetAccount" $ \o ->
    GetAccount
      <$> (o .:  "email")
      <*> (o .:  "firstName")
      <*> (o .:  "lastName")
      <*> (o .:  "companyName")
      <*> (o .:  "address")
      <*> (o .:  "plan")
      <*> (o .:  "relay")
      <*> (o .:? "marketingAutomation")

-- | ToJSON GetAccount
instance A.ToJSON GetAccount where
  toJSON GetAccount {..} =
   _omitNulls
      [ "email" .= getAccountEmail
      , "firstName" .= getAccountFirstName
      , "lastName" .= getAccountLastName
      , "companyName" .= getAccountCompanyName
      , "address" .= getAccountAddress
      , "plan" .= getAccountPlan
      , "relay" .= getAccountRelay
      , "marketingAutomation" .= getAccountMarketingAutomation
      ]


-- | Construct a value of type 'GetAccount' (by applying it's required fields, if any)
mkGetAccount
  :: Text -- ^ 'getAccountEmail': Login Email
  -> Text -- ^ 'getAccountFirstName': First Name
  -> Text -- ^ 'getAccountLastName': Last Name
  -> Text -- ^ 'getAccountCompanyName': Name of the company
  -> GetExtendedClientAddress -- ^ 'getAccountAddress' 
  -> [GetAccountPlan] -- ^ 'getAccountPlan': Information about your plans and credits
  -> GetAccountRelay -- ^ 'getAccountRelay' 
  -> GetAccount
mkGetAccount getAccountEmail getAccountFirstName getAccountLastName getAccountCompanyName getAccountAddress getAccountPlan getAccountRelay =
  GetAccount
  { getAccountEmail
  , getAccountFirstName
  , getAccountLastName
  , getAccountCompanyName
  , getAccountAddress
  , getAccountPlan
  , getAccountRelay
  , getAccountMarketingAutomation = Nothing
  }

-- ** GetEmailCampaign
-- | GetEmailCampaign
data GetEmailCampaign = GetEmailCampaign
  { getEmailCampaignId :: !(Integer) -- ^ /Required/ "id" - ID of the campaign
  , getEmailCampaignName :: !(Text) -- ^ /Required/ "name" - Name of the campaign
  , getEmailCampaignSubject :: !(Maybe Text) -- ^ "subject" - Subject of the campaign. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;false&#x60;
  , getEmailCampaignType :: !(E'Type) -- ^ /Required/ "type" - Type of campaign
  , getEmailCampaignStatus :: !(E'Status3) -- ^ /Required/ "status" - Status of the campaign
  , getEmailCampaignScheduledAt :: !(Maybe DateTime) -- ^ "scheduledAt" - UTC date-time on which campaign is scheduled (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getEmailCampaignAbTesting :: !(Maybe Bool) -- ^ "abTesting" - Status of A/B Test for the campaign. abTesting &#x3D; false means it is disabled, &amp; abTesting &#x3D; true means it is enabled.
  , getEmailCampaignSubjectA :: !(Maybe Text) -- ^ "subjectA" - Subject A of the ab-test campaign. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getEmailCampaignSubjectB :: !(Maybe Text) -- ^ "subjectB" - Subject B of the ab-test campaign. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getEmailCampaignSplitRule :: !(Maybe Int) -- ^ "splitRule" - The size of your ab-test groups. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getEmailCampaignWinnerCriteria :: !(Maybe Text) -- ^ "winnerCriteria" - Criteria for the winning version. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getEmailCampaignWinnerDelay :: !(Maybe Int) -- ^ "winnerDelay" - The duration of the test in hours at the end of which the winning version will be sent. Only available if &#x60;abTesting&#x60; flag of the campaign is &#x60;true&#x60;
  , getEmailCampaignSendAtBestTime :: !(Maybe Bool) -- ^ "sendAtBestTime" - It is true if you have chosen to send your campaign at best time, otherwise it is false
  , getEmailCampaignTestSent :: !(Bool) -- ^ /Required/ "testSent" - Retrieved the status of test email sending. (true&#x3D;Test email has been sent  false&#x3D;Test email has not been sent)
  , getEmailCampaignHeader :: !(Text) -- ^ /Required/ "header" - Header of the campaign
  , getEmailCampaignFooter :: !(Text) -- ^ /Required/ "footer" - Footer of the campaign
  , getEmailCampaignSender :: !(GetExtendedCampaignOverviewSender) -- ^ /Required/ "sender"
  , getEmailCampaignReplyTo :: !(Text) -- ^ /Required/ "replyTo" - Email defined as the \&quot;Reply to\&quot; of the campaign
  , getEmailCampaignToField :: !(Text) -- ^ /Required/ "toField" - Customisation of the \&quot;to\&quot; field of the campaign
  , getEmailCampaignHtmlContent :: !(Text) -- ^ /Required/ "htmlContent" - HTML content of the campaign
  , getEmailCampaignShareLink :: !(Maybe Text) -- ^ "shareLink" - Link to share the campaign on social medias
  , getEmailCampaignTag :: !(Text) -- ^ /Required/ "tag" - Tag of the campaign
  , getEmailCampaignCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Creation UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getEmailCampaignModifiedAt :: !(DateTime) -- ^ /Required/ "modifiedAt" - UTC date-time of last modification of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  , getEmailCampaignInlineImageActivation :: !(Maybe Bool) -- ^ "inlineImageActivation" - Status of inline image. inlineImageActivation &#x3D; false means image can’t be embedded, &amp; inlineImageActivation &#x3D; true means image can be embedded, in the email.
  , getEmailCampaignMirrorActive :: !(Maybe Bool) -- ^ "mirrorActive" - Status of mirror links in campaign. mirrorActive &#x3D; false means mirror links are deactivated, &amp; mirrorActive &#x3D; true means mirror links are activated, in the campaign
  , getEmailCampaignRecurring :: !(Maybe Bool) -- ^ "recurring" - FOR TRIGGER ONLY ! Type of trigger campaign.recurring &#x3D; false means contact can receive the same Trigger campaign only once, &amp; recurring &#x3D; true means contact can receive the same Trigger campaign several times
  , getEmailCampaignSentDate :: !(Maybe DateTime) -- ^ "sentDate" - Sent UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ). Only available if &#39;status&#39; of the campaign is &#39;sent&#39;
  , getEmailCampaignRecipients :: !(A.Value) -- ^ /Required/ "recipients"
  , getEmailCampaignStatistics :: !(A.Value) -- ^ /Required/ "statistics"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetEmailCampaign
instance A.FromJSON GetEmailCampaign where
  parseJSON = A.withObject "GetEmailCampaign" $ \o ->
    GetEmailCampaign
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:? "subject")
      <*> (o .:  "type")
      <*> (o .:  "status")
      <*> (o .:? "scheduledAt")
      <*> (o .:? "abTesting")
      <*> (o .:? "subjectA")
      <*> (o .:? "subjectB")
      <*> (o .:? "splitRule")
      <*> (o .:? "winnerCriteria")
      <*> (o .:? "winnerDelay")
      <*> (o .:? "sendAtBestTime")
      <*> (o .:  "testSent")
      <*> (o .:  "header")
      <*> (o .:  "footer")
      <*> (o .:  "sender")
      <*> (o .:  "replyTo")
      <*> (o .:  "toField")
      <*> (o .:  "htmlContent")
      <*> (o .:? "shareLink")
      <*> (o .:  "tag")
      <*> (o .:  "createdAt")
      <*> (o .:  "modifiedAt")
      <*> (o .:? "inlineImageActivation")
      <*> (o .:? "mirrorActive")
      <*> (o .:? "recurring")
      <*> (o .:? "sentDate")
      <*> (o .:  "recipients")
      <*> (o .:  "statistics")

-- | ToJSON GetEmailCampaign
instance A.ToJSON GetEmailCampaign where
  toJSON GetEmailCampaign {..} =
   _omitNulls
      [ "id" .= getEmailCampaignId
      , "name" .= getEmailCampaignName
      , "subject" .= getEmailCampaignSubject
      , "type" .= getEmailCampaignType
      , "status" .= getEmailCampaignStatus
      , "scheduledAt" .= getEmailCampaignScheduledAt
      , "abTesting" .= getEmailCampaignAbTesting
      , "subjectA" .= getEmailCampaignSubjectA
      , "subjectB" .= getEmailCampaignSubjectB
      , "splitRule" .= getEmailCampaignSplitRule
      , "winnerCriteria" .= getEmailCampaignWinnerCriteria
      , "winnerDelay" .= getEmailCampaignWinnerDelay
      , "sendAtBestTime" .= getEmailCampaignSendAtBestTime
      , "testSent" .= getEmailCampaignTestSent
      , "header" .= getEmailCampaignHeader
      , "footer" .= getEmailCampaignFooter
      , "sender" .= getEmailCampaignSender
      , "replyTo" .= getEmailCampaignReplyTo
      , "toField" .= getEmailCampaignToField
      , "htmlContent" .= getEmailCampaignHtmlContent
      , "shareLink" .= getEmailCampaignShareLink
      , "tag" .= getEmailCampaignTag
      , "createdAt" .= getEmailCampaignCreatedAt
      , "modifiedAt" .= getEmailCampaignModifiedAt
      , "inlineImageActivation" .= getEmailCampaignInlineImageActivation
      , "mirrorActive" .= getEmailCampaignMirrorActive
      , "recurring" .= getEmailCampaignRecurring
      , "sentDate" .= getEmailCampaignSentDate
      , "recipients" .= getEmailCampaignRecipients
      , "statistics" .= getEmailCampaignStatistics
      ]


-- | Construct a value of type 'GetEmailCampaign' (by applying it's required fields, if any)
mkGetEmailCampaign
  :: Integer -- ^ 'getEmailCampaignId': ID of the campaign
  -> Text -- ^ 'getEmailCampaignName': Name of the campaign
  -> E'Type -- ^ 'getEmailCampaignType': Type of campaign
  -> E'Status3 -- ^ 'getEmailCampaignStatus': Status of the campaign
  -> Bool -- ^ 'getEmailCampaignTestSent': Retrieved the status of test email sending. (true=Test email has been sent  false=Test email has not been sent)
  -> Text -- ^ 'getEmailCampaignHeader': Header of the campaign
  -> Text -- ^ 'getEmailCampaignFooter': Footer of the campaign
  -> GetExtendedCampaignOverviewSender -- ^ 'getEmailCampaignSender' 
  -> Text -- ^ 'getEmailCampaignReplyTo': Email defined as the \"Reply to\" of the campaign
  -> Text -- ^ 'getEmailCampaignToField': Customisation of the \"to\" field of the campaign
  -> Text -- ^ 'getEmailCampaignHtmlContent': HTML content of the campaign
  -> Text -- ^ 'getEmailCampaignTag': Tag of the campaign
  -> DateTime -- ^ 'getEmailCampaignCreatedAt': Creation UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> DateTime -- ^ 'getEmailCampaignModifiedAt': UTC date-time of last modification of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
  -> A.Value -- ^ 'getEmailCampaignRecipients' 
  -> A.Value -- ^ 'getEmailCampaignStatistics' 
  -> GetEmailCampaign
mkGetEmailCampaign getEmailCampaignId getEmailCampaignName getEmailCampaignType getEmailCampaignStatus getEmailCampaignTestSent getEmailCampaignHeader getEmailCampaignFooter getEmailCampaignSender getEmailCampaignReplyTo getEmailCampaignToField getEmailCampaignHtmlContent getEmailCampaignTag getEmailCampaignCreatedAt getEmailCampaignModifiedAt getEmailCampaignRecipients getEmailCampaignStatistics =
  GetEmailCampaign
  { getEmailCampaignId
  , getEmailCampaignName
  , getEmailCampaignSubject = Nothing
  , getEmailCampaignType
  , getEmailCampaignStatus
  , getEmailCampaignScheduledAt = Nothing
  , getEmailCampaignAbTesting = Nothing
  , getEmailCampaignSubjectA = Nothing
  , getEmailCampaignSubjectB = Nothing
  , getEmailCampaignSplitRule = Nothing
  , getEmailCampaignWinnerCriteria = Nothing
  , getEmailCampaignWinnerDelay = Nothing
  , getEmailCampaignSendAtBestTime = Nothing
  , getEmailCampaignTestSent
  , getEmailCampaignHeader
  , getEmailCampaignFooter
  , getEmailCampaignSender
  , getEmailCampaignReplyTo
  , getEmailCampaignToField
  , getEmailCampaignHtmlContent
  , getEmailCampaignShareLink = Nothing
  , getEmailCampaignTag
  , getEmailCampaignCreatedAt
  , getEmailCampaignModifiedAt
  , getEmailCampaignInlineImageActivation = Nothing
  , getEmailCampaignMirrorActive = Nothing
  , getEmailCampaignRecurring = Nothing
  , getEmailCampaignSentDate = Nothing
  , getEmailCampaignRecipients
  , getEmailCampaignStatistics
  }


-- * Enums


-- ** E'AttributeCategory

-- | Enum of 'Text'
data E'AttributeCategory
  = E'AttributeCategory'Category -- ^ @"category"@
  | E'AttributeCategory'Calculated -- ^ @"calculated"@
  | E'AttributeCategory'Global -- ^ @"global"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AttributeCategory where toJSON = A.toJSON . fromE'AttributeCategory
instance A.FromJSON E'AttributeCategory where parseJSON o = P.either P.fail (pure . P.id) . toE'AttributeCategory =<< A.parseJSON o
instance WH.ToHttpApiData E'AttributeCategory where toQueryParam = WH.toQueryParam . fromE'AttributeCategory
instance WH.FromHttpApiData E'AttributeCategory where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AttributeCategory
instance MimeRender MimeMultipartFormData E'AttributeCategory where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AttributeCategory' enum
fromE'AttributeCategory :: E'AttributeCategory -> Text
fromE'AttributeCategory = \case
  E'AttributeCategory'Category -> "category"
  E'AttributeCategory'Calculated -> "calculated"
  E'AttributeCategory'Global -> "global"

-- | parse 'E'AttributeCategory' enum
toE'AttributeCategory :: Text -> P.Either String E'AttributeCategory
toE'AttributeCategory = \case
  "category" -> P.Right E'AttributeCategory'Category
  "calculated" -> P.Right E'AttributeCategory'Calculated
  "global" -> P.Right E'AttributeCategory'Global
  s -> P.Left $ "toE'AttributeCategory: enum parse failure: " P.++ P.show s


-- ** E'Category

-- | Enum of 'Text' . 
-- Category of the attribute
data E'Category
  = E'Category'Normal -- ^ @"normal"@
  | E'Category'Transactional -- ^ @"transactional"@
  | E'Category'Category -- ^ @"category"@
  | E'Category'Calculated -- ^ @"calculated"@
  | E'Category'Global -- ^ @"global"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Category where toJSON = A.toJSON . fromE'Category
instance A.FromJSON E'Category where parseJSON o = P.either P.fail (pure . P.id) . toE'Category =<< A.parseJSON o
instance WH.ToHttpApiData E'Category where toQueryParam = WH.toQueryParam . fromE'Category
instance WH.FromHttpApiData E'Category where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Category
instance MimeRender MimeMultipartFormData E'Category where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Category' enum
fromE'Category :: E'Category -> Text
fromE'Category = \case
  E'Category'Normal -> "normal"
  E'Category'Transactional -> "transactional"
  E'Category'Category -> "category"
  E'Category'Calculated -> "calculated"
  E'Category'Global -> "global"

-- | parse 'E'Category' enum
toE'Category :: Text -> P.Either String E'Category
toE'Category = \case
  "normal" -> P.Right E'Category'Normal
  "transactional" -> P.Right E'Category'Transactional
  "category" -> P.Right E'Category'Category
  "calculated" -> P.Right E'Category'Calculated
  "global" -> P.Right E'Category'Global
  s -> P.Left $ "toE'Category: enum parse failure: " P.++ P.show s


-- ** E'Code

-- | Enum of 'Text' . 
-- Error code displayed in case of a failure
data E'Code
  = E'Code'Invalid_parameter -- ^ @"invalid_parameter"@
  | E'Code'Missing_parameter -- ^ @"missing_parameter"@
  | E'Code'Out_of_range -- ^ @"out_of_range"@
  | E'Code'Campaign_processing -- ^ @"campaign_processing"@
  | E'Code'Campaign_sent -- ^ @"campaign_sent"@
  | E'Code'Document_not_found -- ^ @"document_not_found"@
  | E'Code'Reseller_permission_denied -- ^ @"reseller_permission_denied"@
  | E'Code'Not_enough_credits -- ^ @"not_enough_credits"@
  | E'Code'Permission_denied -- ^ @"permission_denied"@
  | E'Code'Duplicate_parameter -- ^ @"duplicate_parameter"@
  | E'Code'Duplicate_request -- ^ @"duplicate_request"@
  | E'Code'Method_not_allowed -- ^ @"method_not_allowed"@
  | E'Code'Unauthorized -- ^ @"unauthorized"@
  | E'Code'Account_under_validation -- ^ @"account_under_validation"@
  | E'Code'Not_acceptable -- ^ @"not_acceptable"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Code where toJSON = A.toJSON . fromE'Code
instance A.FromJSON E'Code where parseJSON o = P.either P.fail (pure . P.id) . toE'Code =<< A.parseJSON o
instance WH.ToHttpApiData E'Code where toQueryParam = WH.toQueryParam . fromE'Code
instance WH.FromHttpApiData E'Code where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Code
instance MimeRender MimeMultipartFormData E'Code where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Code' enum
fromE'Code :: E'Code -> Text
fromE'Code = \case
  E'Code'Invalid_parameter -> "invalid_parameter"
  E'Code'Missing_parameter -> "missing_parameter"
  E'Code'Out_of_range -> "out_of_range"
  E'Code'Campaign_processing -> "campaign_processing"
  E'Code'Campaign_sent -> "campaign_sent"
  E'Code'Document_not_found -> "document_not_found"
  E'Code'Reseller_permission_denied -> "reseller_permission_denied"
  E'Code'Not_enough_credits -> "not_enough_credits"
  E'Code'Permission_denied -> "permission_denied"
  E'Code'Duplicate_parameter -> "duplicate_parameter"
  E'Code'Duplicate_request -> "duplicate_request"
  E'Code'Method_not_allowed -> "method_not_allowed"
  E'Code'Unauthorized -> "unauthorized"
  E'Code'Account_under_validation -> "account_under_validation"
  E'Code'Not_acceptable -> "not_acceptable"

-- | parse 'E'Code' enum
toE'Code :: Text -> P.Either String E'Code
toE'Code = \case
  "invalid_parameter" -> P.Right E'Code'Invalid_parameter
  "missing_parameter" -> P.Right E'Code'Missing_parameter
  "out_of_range" -> P.Right E'Code'Out_of_range
  "campaign_processing" -> P.Right E'Code'Campaign_processing
  "campaign_sent" -> P.Right E'Code'Campaign_sent
  "document_not_found" -> P.Right E'Code'Document_not_found
  "reseller_permission_denied" -> P.Right E'Code'Reseller_permission_denied
  "not_enough_credits" -> P.Right E'Code'Not_enough_credits
  "permission_denied" -> P.Right E'Code'Permission_denied
  "duplicate_parameter" -> P.Right E'Code'Duplicate_parameter
  "duplicate_request" -> P.Right E'Code'Duplicate_request
  "method_not_allowed" -> P.Right E'Code'Method_not_allowed
  "unauthorized" -> P.Right E'Code'Unauthorized
  "account_under_validation" -> P.Right E'Code'Account_under_validation
  "not_acceptable" -> P.Right E'Code'Not_acceptable
  s -> P.Left $ "toE'Code: enum parse failure: " P.++ P.show s


-- ** E'Code2

-- | Enum of 'Text' . 
-- Reason code for blocking / unsubscribing (This code is safe for comparison)
data E'Code2
  = E'Code2'UnsubscribedViaMA -- ^ @"unsubscribedViaMA"@
  | E'Code2'UnsubscribedViaEmail -- ^ @"unsubscribedViaEmail"@
  | E'Code2'AdminBlocked -- ^ @"adminBlocked"@
  | E'Code2'UnsubscribedViaApi -- ^ @"unsubscribedViaApi"@
  | E'Code2'HardBounce -- ^ @"hardBounce"@
  | E'Code2'ContactFlaggedAsSpam -- ^ @"contactFlaggedAsSpam"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Code2 where toJSON = A.toJSON . fromE'Code2
instance A.FromJSON E'Code2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Code2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Code2 where toQueryParam = WH.toQueryParam . fromE'Code2
instance WH.FromHttpApiData E'Code2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Code2
instance MimeRender MimeMultipartFormData E'Code2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Code2' enum
fromE'Code2 :: E'Code2 -> Text
fromE'Code2 = \case
  E'Code2'UnsubscribedViaMA -> "unsubscribedViaMA"
  E'Code2'UnsubscribedViaEmail -> "unsubscribedViaEmail"
  E'Code2'AdminBlocked -> "adminBlocked"
  E'Code2'UnsubscribedViaApi -> "unsubscribedViaApi"
  E'Code2'HardBounce -> "hardBounce"
  E'Code2'ContactFlaggedAsSpam -> "contactFlaggedAsSpam"

-- | parse 'E'Code2' enum
toE'Code2 :: Text -> P.Either String E'Code2
toE'Code2 = \case
  "unsubscribedViaMA" -> P.Right E'Code2'UnsubscribedViaMA
  "unsubscribedViaEmail" -> P.Right E'Code2'UnsubscribedViaEmail
  "adminBlocked" -> P.Right E'Code2'AdminBlocked
  "unsubscribedViaApi" -> P.Right E'Code2'UnsubscribedViaApi
  "hardBounce" -> P.Right E'Code2'HardBounce
  "contactFlaggedAsSpam" -> P.Right E'Code2'ContactFlaggedAsSpam
  s -> P.Left $ "toE'Code2: enum parse failure: " P.++ P.show s


-- ** E'ContentType

-- | Enum of 'Text' . 
-- Type of the message body
data E'ContentType
  = E'ContentType'Text -- ^ @"text"@
  | E'ContentType'Html -- ^ @"html"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ContentType where toJSON = A.toJSON . fromE'ContentType
instance A.FromJSON E'ContentType where parseJSON o = P.either P.fail (pure . P.id) . toE'ContentType =<< A.parseJSON o
instance WH.ToHttpApiData E'ContentType where toQueryParam = WH.toQueryParam . fromE'ContentType
instance WH.FromHttpApiData E'ContentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ContentType
instance MimeRender MimeMultipartFormData E'ContentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ContentType' enum
fromE'ContentType :: E'ContentType -> Text
fromE'ContentType = \case
  E'ContentType'Text -> "text"
  E'ContentType'Html -> "html"

-- | parse 'E'ContentType' enum
toE'ContentType :: Text -> P.Either String E'ContentType
toE'ContentType = \case
  "text" -> P.Right E'ContentType'Text
  "html" -> P.Right E'ContentType'Html
  s -> P.Left $ "toE'ContentType: enum parse failure: " P.++ P.show s


-- ** E'CreditsType

-- | Enum of 'Text' . 
-- This is the type of the credit, \"Send Limit\" is one of the possible types of credit of a user. \"Send Limit\" implies the total number of emails you can send to the subscribers in your account.
data E'CreditsType
  = E'CreditsType'SendLimit -- ^ @"sendLimit"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'CreditsType where toJSON = A.toJSON . fromE'CreditsType
instance A.FromJSON E'CreditsType where parseJSON o = P.either P.fail (pure . P.id) . toE'CreditsType =<< A.parseJSON o
instance WH.ToHttpApiData E'CreditsType where toQueryParam = WH.toQueryParam . fromE'CreditsType
instance WH.FromHttpApiData E'CreditsType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'CreditsType
instance MimeRender MimeMultipartFormData E'CreditsType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'CreditsType' enum
fromE'CreditsType :: E'CreditsType -> Text
fromE'CreditsType = \case
  E'CreditsType'SendLimit -> "sendLimit"

-- | parse 'E'CreditsType' enum
toE'CreditsType :: Text -> P.Either String E'CreditsType
toE'CreditsType = \case
  "sendLimit" -> P.Right E'CreditsType'SendLimit
  s -> P.Left $ "toE'CreditsType: enum parse failure: " P.++ P.show s


-- ** E'Event

-- | Enum of 'Text' . 
-- Event which occurred
data E'Event
  = E'Event'Bounces -- ^ @"bounces"@
  | E'Event'HardBounces -- ^ @"hardBounces"@
  | E'Event'SoftBounces -- ^ @"softBounces"@
  | E'Event'Delivered -- ^ @"delivered"@
  | E'Event'Spam -- ^ @"spam"@
  | E'Event'Requests -- ^ @"requests"@
  | E'Event'Opened -- ^ @"opened"@
  | E'Event'Clicks -- ^ @"clicks"@
  | E'Event'Invalid -- ^ @"invalid"@
  | E'Event'Deferred -- ^ @"deferred"@
  | E'Event'Blocked -- ^ @"blocked"@
  | E'Event'Unsubscribed -- ^ @"unsubscribed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Event where toJSON = A.toJSON . fromE'Event
instance A.FromJSON E'Event where parseJSON o = P.either P.fail (pure . P.id) . toE'Event =<< A.parseJSON o
instance WH.ToHttpApiData E'Event where toQueryParam = WH.toQueryParam . fromE'Event
instance WH.FromHttpApiData E'Event where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Event
instance MimeRender MimeMultipartFormData E'Event where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Event' enum
fromE'Event :: E'Event -> Text
fromE'Event = \case
  E'Event'Bounces -> "bounces"
  E'Event'HardBounces -> "hardBounces"
  E'Event'SoftBounces -> "softBounces"
  E'Event'Delivered -> "delivered"
  E'Event'Spam -> "spam"
  E'Event'Requests -> "requests"
  E'Event'Opened -> "opened"
  E'Event'Clicks -> "clicks"
  E'Event'Invalid -> "invalid"
  E'Event'Deferred -> "deferred"
  E'Event'Blocked -> "blocked"
  E'Event'Unsubscribed -> "unsubscribed"

-- | parse 'E'Event' enum
toE'Event :: Text -> P.Either String E'Event
toE'Event = \case
  "bounces" -> P.Right E'Event'Bounces
  "hardBounces" -> P.Right E'Event'HardBounces
  "softBounces" -> P.Right E'Event'SoftBounces
  "delivered" -> P.Right E'Event'Delivered
  "spam" -> P.Right E'Event'Spam
  "requests" -> P.Right E'Event'Requests
  "opened" -> P.Right E'Event'Opened
  "clicks" -> P.Right E'Event'Clicks
  "invalid" -> P.Right E'Event'Invalid
  "deferred" -> P.Right E'Event'Deferred
  "blocked" -> P.Right E'Event'Blocked
  "unsubscribed" -> P.Right E'Event'Unsubscribed
  s -> P.Left $ "toE'Event: enum parse failure: " P.++ P.show s


-- ** E'Event2

-- | Enum of 'Text' . 
-- Event which occurred
data E'Event2
  = E'Event2'Bounces -- ^ @"bounces"@
  | E'Event2'HardBounces -- ^ @"hardBounces"@
  | E'Event2'SoftBounces -- ^ @"softBounces"@
  | E'Event2'Delivered -- ^ @"delivered"@
  | E'Event2'Sent -- ^ @"sent"@
  | E'Event2'Accepted -- ^ @"accepted"@
  | E'Event2'Unsubscription -- ^ @"unsubscription"@
  | E'Event2'Replies -- ^ @"replies"@
  | E'Event2'Blocked -- ^ @"blocked"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Event2 where toJSON = A.toJSON . fromE'Event2
instance A.FromJSON E'Event2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Event2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Event2 where toQueryParam = WH.toQueryParam . fromE'Event2
instance WH.FromHttpApiData E'Event2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Event2
instance MimeRender MimeMultipartFormData E'Event2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Event2' enum
fromE'Event2 :: E'Event2 -> Text
fromE'Event2 = \case
  E'Event2'Bounces -> "bounces"
  E'Event2'HardBounces -> "hardBounces"
  E'Event2'SoftBounces -> "softBounces"
  E'Event2'Delivered -> "delivered"
  E'Event2'Sent -> "sent"
  E'Event2'Accepted -> "accepted"
  E'Event2'Unsubscription -> "unsubscription"
  E'Event2'Replies -> "replies"
  E'Event2'Blocked -> "blocked"

-- | parse 'E'Event2' enum
toE'Event2 :: Text -> P.Either String E'Event2
toE'Event2 = \case
  "bounces" -> P.Right E'Event2'Bounces
  "hardBounces" -> P.Right E'Event2'HardBounces
  "softBounces" -> P.Right E'Event2'SoftBounces
  "delivered" -> P.Right E'Event2'Delivered
  "sent" -> P.Right E'Event2'Sent
  "accepted" -> P.Right E'Event2'Accepted
  "unsubscription" -> P.Right E'Event2'Unsubscription
  "replies" -> P.Right E'Event2'Replies
  "blocked" -> P.Right E'Event2'Blocked
  s -> P.Left $ "toE'Event2: enum parse failure: " P.++ P.show s


-- ** E'Events

-- | Enum of 'Text'
data E'Events
  = E'Events'HardBounce -- ^ @"hardBounce"@
  | E'Events'SoftBounce -- ^ @"softBounce"@
  | E'Events'Blocked -- ^ @"blocked"@
  | E'Events'Spam -- ^ @"spam"@
  | E'Events'Delivered -- ^ @"delivered"@
  | E'Events'Request -- ^ @"request"@
  | E'Events'Click -- ^ @"click"@
  | E'Events'Invalid -- ^ @"invalid"@
  | E'Events'Deferred -- ^ @"deferred"@
  | E'Events'Opened -- ^ @"opened"@
  | E'Events'UniqueOpened -- ^ @"uniqueOpened"@
  | E'Events'Unsubscribed -- ^ @"unsubscribed"@
  | E'Events'ListAddition -- ^ @"listAddition"@
  | E'Events'ContactUpdated -- ^ @"contactUpdated"@
  | E'Events'ContactDeleted -- ^ @"contactDeleted"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Events where toJSON = A.toJSON . fromE'Events
instance A.FromJSON E'Events where parseJSON o = P.either P.fail (pure . P.id) . toE'Events =<< A.parseJSON o
instance WH.ToHttpApiData E'Events where toQueryParam = WH.toQueryParam . fromE'Events
instance WH.FromHttpApiData E'Events where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Events
instance MimeRender MimeMultipartFormData E'Events where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Events' enum
fromE'Events :: E'Events -> Text
fromE'Events = \case
  E'Events'HardBounce -> "hardBounce"
  E'Events'SoftBounce -> "softBounce"
  E'Events'Blocked -> "blocked"
  E'Events'Spam -> "spam"
  E'Events'Delivered -> "delivered"
  E'Events'Request -> "request"
  E'Events'Click -> "click"
  E'Events'Invalid -> "invalid"
  E'Events'Deferred -> "deferred"
  E'Events'Opened -> "opened"
  E'Events'UniqueOpened -> "uniqueOpened"
  E'Events'Unsubscribed -> "unsubscribed"
  E'Events'ListAddition -> "listAddition"
  E'Events'ContactUpdated -> "contactUpdated"
  E'Events'ContactDeleted -> "contactDeleted"

-- | parse 'E'Events' enum
toE'Events :: Text -> P.Either String E'Events
toE'Events = \case
  "hardBounce" -> P.Right E'Events'HardBounce
  "softBounce" -> P.Right E'Events'SoftBounce
  "blocked" -> P.Right E'Events'Blocked
  "spam" -> P.Right E'Events'Spam
  "delivered" -> P.Right E'Events'Delivered
  "request" -> P.Right E'Events'Request
  "click" -> P.Right E'Events'Click
  "invalid" -> P.Right E'Events'Invalid
  "deferred" -> P.Right E'Events'Deferred
  "opened" -> P.Right E'Events'Opened
  "uniqueOpened" -> P.Right E'Events'UniqueOpened
  "unsubscribed" -> P.Right E'Events'Unsubscribed
  "listAddition" -> P.Right E'Events'ListAddition
  "contactUpdated" -> P.Right E'Events'ContactUpdated
  "contactDeleted" -> P.Right E'Events'ContactDeleted
  s -> P.Left $ "toE'Events: enum parse failure: " P.++ P.show s


-- ** E'Language

-- | Enum of 'Text' . 
-- Language of email content for campaign report sending.
data E'Language
  = E'Language'Fr -- ^ @"fr"@
  | E'Language'Es -- ^ @"es"@
  | E'Language'Pt -- ^ @"pt"@
  | E'Language'It -- ^ @"it"@
  | E'Language'De -- ^ @"de"@
  | E'Language'En -- ^ @"en"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Language where toJSON = A.toJSON . fromE'Language
instance A.FromJSON E'Language where parseJSON o = P.either P.fail (pure . P.id) . toE'Language =<< A.parseJSON o
instance WH.ToHttpApiData E'Language where toQueryParam = WH.toQueryParam . fromE'Language
instance WH.FromHttpApiData E'Language where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Language
instance MimeRender MimeMultipartFormData E'Language where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Language' enum
fromE'Language :: E'Language -> Text
fromE'Language = \case
  E'Language'Fr -> "fr"
  E'Language'Es -> "es"
  E'Language'Pt -> "pt"
  E'Language'It -> "it"
  E'Language'De -> "de"
  E'Language'En -> "en"

-- | parse 'E'Language' enum
toE'Language :: Text -> P.Either String E'Language
toE'Language = \case
  "fr" -> P.Right E'Language'Fr
  "es" -> P.Right E'Language'Es
  "pt" -> P.Right E'Language'Pt
  "it" -> P.Right E'Language'It
  "de" -> P.Right E'Language'De
  "en" -> P.Right E'Language'En
  s -> P.Left $ "toE'Language: enum parse failure: " P.++ P.show s


-- ** E'RecipientsType

-- | Enum of 'Text' . 
-- Type of recipients to export for a campaign
data E'RecipientsType
  = E'RecipientsType'All -- ^ @"all"@
  | E'RecipientsType'NonClickers -- ^ @"nonClickers"@
  | E'RecipientsType'NonOpeners -- ^ @"nonOpeners"@
  | E'RecipientsType'Clickers -- ^ @"clickers"@
  | E'RecipientsType'Openers -- ^ @"openers"@
  | E'RecipientsType'SoftBounces -- ^ @"softBounces"@
  | E'RecipientsType'HardBounces -- ^ @"hardBounces"@
  | E'RecipientsType'Unsubscribed -- ^ @"unsubscribed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'RecipientsType where toJSON = A.toJSON . fromE'RecipientsType
instance A.FromJSON E'RecipientsType where parseJSON o = P.either P.fail (pure . P.id) . toE'RecipientsType =<< A.parseJSON o
instance WH.ToHttpApiData E'RecipientsType where toQueryParam = WH.toQueryParam . fromE'RecipientsType
instance WH.FromHttpApiData E'RecipientsType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'RecipientsType
instance MimeRender MimeMultipartFormData E'RecipientsType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'RecipientsType' enum
fromE'RecipientsType :: E'RecipientsType -> Text
fromE'RecipientsType = \case
  E'RecipientsType'All -> "all"
  E'RecipientsType'NonClickers -> "nonClickers"
  E'RecipientsType'NonOpeners -> "nonOpeners"
  E'RecipientsType'Clickers -> "clickers"
  E'RecipientsType'Openers -> "openers"
  E'RecipientsType'SoftBounces -> "softBounces"
  E'RecipientsType'HardBounces -> "hardBounces"
  E'RecipientsType'Unsubscribed -> "unsubscribed"

-- | parse 'E'RecipientsType' enum
toE'RecipientsType :: Text -> P.Either String E'RecipientsType
toE'RecipientsType = \case
  "all" -> P.Right E'RecipientsType'All
  "nonClickers" -> P.Right E'RecipientsType'NonClickers
  "nonOpeners" -> P.Right E'RecipientsType'NonOpeners
  "clickers" -> P.Right E'RecipientsType'Clickers
  "openers" -> P.Right E'RecipientsType'Openers
  "softBounces" -> P.Right E'RecipientsType'SoftBounces
  "hardBounces" -> P.Right E'RecipientsType'HardBounces
  "unsubscribed" -> P.Right E'RecipientsType'Unsubscribed
  s -> P.Left $ "toE'RecipientsType: enum parse failure: " P.++ P.show s


-- ** E'RecipientsType2

-- | Enum of 'Text' . 
-- Filter the recipients based on how they interacted with the campaign
data E'RecipientsType2
  = E'RecipientsType2'All -- ^ @"all"@
  | E'RecipientsType2'Delivered -- ^ @"delivered"@
  | E'RecipientsType2'Answered -- ^ @"answered"@
  | E'RecipientsType2'SoftBounces -- ^ @"softBounces"@
  | E'RecipientsType2'HardBounces -- ^ @"hardBounces"@
  | E'RecipientsType2'Unsubscribed -- ^ @"unsubscribed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'RecipientsType2 where toJSON = A.toJSON . fromE'RecipientsType2
instance A.FromJSON E'RecipientsType2 where parseJSON o = P.either P.fail (pure . P.id) . toE'RecipientsType2 =<< A.parseJSON o
instance WH.ToHttpApiData E'RecipientsType2 where toQueryParam = WH.toQueryParam . fromE'RecipientsType2
instance WH.FromHttpApiData E'RecipientsType2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'RecipientsType2
instance MimeRender MimeMultipartFormData E'RecipientsType2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'RecipientsType2' enum
fromE'RecipientsType2 :: E'RecipientsType2 -> Text
fromE'RecipientsType2 = \case
  E'RecipientsType2'All -> "all"
  E'RecipientsType2'Delivered -> "delivered"
  E'RecipientsType2'Answered -> "answered"
  E'RecipientsType2'SoftBounces -> "softBounces"
  E'RecipientsType2'HardBounces -> "hardBounces"
  E'RecipientsType2'Unsubscribed -> "unsubscribed"

-- | parse 'E'RecipientsType2' enum
toE'RecipientsType2 :: Text -> P.Either String E'RecipientsType2
toE'RecipientsType2 = \case
  "all" -> P.Right E'RecipientsType2'All
  "delivered" -> P.Right E'RecipientsType2'Delivered
  "answered" -> P.Right E'RecipientsType2'Answered
  "softBounces" -> P.Right E'RecipientsType2'SoftBounces
  "hardBounces" -> P.Right E'RecipientsType2'HardBounces
  "unsubscribed" -> P.Right E'RecipientsType2'Unsubscribed
  s -> P.Left $ "toE'RecipientsType2: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' . 
-- Status of the process
data E'Status
  = E'Status'Queued -- ^ @"queued"@
  | E'Status'In_process -- ^ @"in_process"@
  | E'Status'Completed -- ^ @"completed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'Queued -> "queued"
  E'Status'In_process -> "in_process"
  E'Status'Completed -> "completed"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "queued" -> P.Right E'Status'Queued
  "in_process" -> P.Right E'Status'In_process
  "completed" -> P.Right E'Status'Completed
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'Status2

-- | Enum of 'Text' . 
-- Status of the SMS Campaign
data E'Status2
  = E'Status2'Draft -- ^ @"draft"@
  | E'Status2'Sent -- ^ @"sent"@
  | E'Status2'Archive -- ^ @"archive"@
  | E'Status2'Queued -- ^ @"queued"@
  | E'Status2'Suspended -- ^ @"suspended"@
  | E'Status2'InProcess -- ^ @"inProcess"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status2 where toJSON = A.toJSON . fromE'Status2
instance A.FromJSON E'Status2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status2 where toQueryParam = WH.toQueryParam . fromE'Status2
instance WH.FromHttpApiData E'Status2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status2
instance MimeRender MimeMultipartFormData E'Status2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status2' enum
fromE'Status2 :: E'Status2 -> Text
fromE'Status2 = \case
  E'Status2'Draft -> "draft"
  E'Status2'Sent -> "sent"
  E'Status2'Archive -> "archive"
  E'Status2'Queued -> "queued"
  E'Status2'Suspended -> "suspended"
  E'Status2'InProcess -> "inProcess"

-- | parse 'E'Status2' enum
toE'Status2 :: Text -> P.Either String E'Status2
toE'Status2 = \case
  "draft" -> P.Right E'Status2'Draft
  "sent" -> P.Right E'Status2'Sent
  "archive" -> P.Right E'Status2'Archive
  "queued" -> P.Right E'Status2'Queued
  "suspended" -> P.Right E'Status2'Suspended
  "inProcess" -> P.Right E'Status2'InProcess
  s -> P.Left $ "toE'Status2: enum parse failure: " P.++ P.show s


-- ** E'Status3

-- | Enum of 'Text' . 
-- Status of the campaign
data E'Status3
  = E'Status3'Draft -- ^ @"draft"@
  | E'Status3'Sent -- ^ @"sent"@
  | E'Status3'Archive -- ^ @"archive"@
  | E'Status3'Queued -- ^ @"queued"@
  | E'Status3'Suspended -- ^ @"suspended"@
  | E'Status3'In_process -- ^ @"in_process"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status3 where toJSON = A.toJSON . fromE'Status3
instance A.FromJSON E'Status3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status3 where toQueryParam = WH.toQueryParam . fromE'Status3
instance WH.FromHttpApiData E'Status3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status3
instance MimeRender MimeMultipartFormData E'Status3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status3' enum
fromE'Status3 :: E'Status3 -> Text
fromE'Status3 = \case
  E'Status3'Draft -> "draft"
  E'Status3'Sent -> "sent"
  E'Status3'Archive -> "archive"
  E'Status3'Queued -> "queued"
  E'Status3'Suspended -> "suspended"
  E'Status3'In_process -> "in_process"

-- | parse 'E'Status3' enum
toE'Status3 :: Text -> P.Either String E'Status3
toE'Status3 = \case
  "draft" -> P.Right E'Status3'Draft
  "sent" -> P.Right E'Status3'Sent
  "archive" -> P.Right E'Status3'Archive
  "queued" -> P.Right E'Status3'Queued
  "suspended" -> P.Right E'Status3'Suspended
  "in_process" -> P.Right E'Status3'In_process
  s -> P.Left $ "toE'Status3: enum parse failure: " P.++ P.show s


-- ** E'Status4

-- | Enum of 'Text' . 
-- Note:- replicateTemplate status will be available only for template type campaigns.
data E'Status4
  = E'Status4'Suspended -- ^ @"suspended"@
  | E'Status4'Archive -- ^ @"archive"@
  | E'Status4'Darchive -- ^ @"darchive"@
  | E'Status4'Sent -- ^ @"sent"@
  | E'Status4'Queued -- ^ @"queued"@
  | E'Status4'Replicate -- ^ @"replicate"@
  | E'Status4'ReplicateTemplate -- ^ @"replicateTemplate"@
  | E'Status4'Draft -- ^ @"draft"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status4 where toJSON = A.toJSON . fromE'Status4
instance A.FromJSON E'Status4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status4 where toQueryParam = WH.toQueryParam . fromE'Status4
instance WH.FromHttpApiData E'Status4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status4
instance MimeRender MimeMultipartFormData E'Status4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status4' enum
fromE'Status4 :: E'Status4 -> Text
fromE'Status4 = \case
  E'Status4'Suspended -> "suspended"
  E'Status4'Archive -> "archive"
  E'Status4'Darchive -> "darchive"
  E'Status4'Sent -> "sent"
  E'Status4'Queued -> "queued"
  E'Status4'Replicate -> "replicate"
  E'Status4'ReplicateTemplate -> "replicateTemplate"
  E'Status4'Draft -> "draft"

-- | parse 'E'Status4' enum
toE'Status4 :: Text -> P.Either String E'Status4
toE'Status4 = \case
  "suspended" -> P.Right E'Status4'Suspended
  "archive" -> P.Right E'Status4'Archive
  "darchive" -> P.Right E'Status4'Darchive
  "sent" -> P.Right E'Status4'Sent
  "queued" -> P.Right E'Status4'Queued
  "replicate" -> P.Right E'Status4'Replicate
  "replicateTemplate" -> P.Right E'Status4'ReplicateTemplate
  "draft" -> P.Right E'Status4'Draft
  s -> P.Left $ "toE'Status4: enum parse failure: " P.++ P.show s


-- ** E'Status5

-- | Enum of 'Text'
data E'Status5
  = E'Status5'Suspended -- ^ @"suspended"@
  | E'Status5'Archive -- ^ @"archive"@
  | E'Status5'Sent -- ^ @"sent"@
  | E'Status5'Queued -- ^ @"queued"@
  | E'Status5'Draft -- ^ @"draft"@
  | E'Status5'InProcess -- ^ @"inProcess"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status5 where toJSON = A.toJSON . fromE'Status5
instance A.FromJSON E'Status5 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status5 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status5 where toQueryParam = WH.toQueryParam . fromE'Status5
instance WH.FromHttpApiData E'Status5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status5
instance MimeRender MimeMultipartFormData E'Status5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status5' enum
fromE'Status5 :: E'Status5 -> Text
fromE'Status5 = \case
  E'Status5'Suspended -> "suspended"
  E'Status5'Archive -> "archive"
  E'Status5'Sent -> "sent"
  E'Status5'Queued -> "queued"
  E'Status5'Draft -> "draft"
  E'Status5'InProcess -> "inProcess"

-- | parse 'E'Status5' enum
toE'Status5 :: Text -> P.Either String E'Status5
toE'Status5 = \case
  "suspended" -> P.Right E'Status5'Suspended
  "archive" -> P.Right E'Status5'Archive
  "sent" -> P.Right E'Status5'Sent
  "queued" -> P.Right E'Status5'Queued
  "draft" -> P.Right E'Status5'Draft
  "inProcess" -> P.Right E'Status5'InProcess
  s -> P.Left $ "toE'Status5: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text' . 
-- Type of campaign
data E'Type
  = E'Type'Classic -- ^ @"classic"@
  | E'Type'Trigger -- ^ @"trigger"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Classic -> "classic"
  E'Type'Trigger -> "trigger"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "classic" -> P.Right E'Type'Classic
  "trigger" -> P.Right E'Type'Trigger
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text' . 
-- Type of webhook (marketing or transac)
data E'Type2
  = E'Type2'Marketing -- ^ @"marketing"@
  | E'Type2'Transac -- ^ @"transac"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Marketing -> "marketing"
  E'Type2'Transac -> "transac"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "marketing" -> P.Right E'Type2'Marketing
  "transac" -> P.Right E'Type2'Transac
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text' . 
-- Type of the webhook
data E'Type3
  = E'Type3'Transactional -- ^ @"transactional"@
  | E'Type3'Marketing -- ^ @"marketing"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'Transactional -> "transactional"
  E'Type3'Marketing -> "marketing"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "transactional" -> P.Right E'Type3'Transactional
  "marketing" -> P.Right E'Type3'Marketing
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s


-- ** E'Type4

-- | Enum of 'Text' . 
-- Type of the attribute. Use only if the attribute's category is 'normal', 'category' or 'transactional' ( type 'boolean' is only available if the category is 'normal' attribute, type 'id' is only available if the category is 'transactional' attribute & type 'category' is only available if the category is 'category' attribute )
data E'Type4
  = E'Type4'Text -- ^ @"text"@
  | E'Type4'Date -- ^ @"date"@
  | E'Type4'Float -- ^ @"float"@
  | E'Type4'Boolean -- ^ @"boolean"@
  | E'Type4'Id -- ^ @"id"@
  | E'Type4'Category -- ^ @"category"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type4 where toJSON = A.toJSON . fromE'Type4
instance A.FromJSON E'Type4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type4 where toQueryParam = WH.toQueryParam . fromE'Type4
instance WH.FromHttpApiData E'Type4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type4
instance MimeRender MimeMultipartFormData E'Type4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type4' enum
fromE'Type4 :: E'Type4 -> Text
fromE'Type4 = \case
  E'Type4'Text -> "text"
  E'Type4'Date -> "date"
  E'Type4'Float -> "float"
  E'Type4'Boolean -> "boolean"
  E'Type4'Id -> "id"
  E'Type4'Category -> "category"

-- | parse 'E'Type4' enum
toE'Type4 :: Text -> P.Either String E'Type4
toE'Type4 = \case
  "text" -> P.Right E'Type4'Text
  "date" -> P.Right E'Type4'Date
  "float" -> P.Right E'Type4'Float
  "boolean" -> P.Right E'Type4'Boolean
  "id" -> P.Right E'Type4'Id
  "category" -> P.Right E'Type4'Category
  s -> P.Left $ "toE'Type4: enum parse failure: " P.++ P.show s


-- ** E'Type5

-- | Enum of 'Text' . 
-- Displays the plan type of the user
data E'Type5
  = E'Type5'PayAsYouGo -- ^ @"payAsYouGo"@
  | E'Type5'Free -- ^ @"free"@
  | E'Type5'Subscription -- ^ @"subscription"@
  | E'Type5'Sms -- ^ @"sms"@
  | E'Type5'Reseller -- ^ @"reseller"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type5 where toJSON = A.toJSON . fromE'Type5
instance A.FromJSON E'Type5 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type5 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type5 where toQueryParam = WH.toQueryParam . fromE'Type5
instance WH.FromHttpApiData E'Type5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type5
instance MimeRender MimeMultipartFormData E'Type5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type5' enum
fromE'Type5 :: E'Type5 -> Text
fromE'Type5 = \case
  E'Type5'PayAsYouGo -> "payAsYouGo"
  E'Type5'Free -> "free"
  E'Type5'Subscription -> "subscription"
  E'Type5'Sms -> "sms"
  E'Type5'Reseller -> "reseller"

-- | parse 'E'Type5' enum
toE'Type5 :: Text -> P.Either String E'Type5
toE'Type5 = \case
  "payAsYouGo" -> P.Right E'Type5'PayAsYouGo
  "free" -> P.Right E'Type5'Free
  "subscription" -> P.Right E'Type5'Subscription
  "sms" -> P.Right E'Type5'Sms
  "reseller" -> P.Right E'Type5'Reseller
  s -> P.Left $ "toE'Type5: enum parse failure: " P.++ P.show s


-- ** E'Type6

-- | Enum of 'Text' . 
-- Type of the attribute
data E'Type6
  = E'Type6'Text -- ^ @"text"@
  | E'Type6'Date -- ^ @"date"@
  | E'Type6'Float -- ^ @"float"@
  | E'Type6'Id -- ^ @"id"@
  | E'Type6'Boolean -- ^ @"boolean"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type6 where toJSON = A.toJSON . fromE'Type6
instance A.FromJSON E'Type6 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type6 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type6 where toQueryParam = WH.toQueryParam . fromE'Type6
instance WH.FromHttpApiData E'Type6 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type6
instance MimeRender MimeMultipartFormData E'Type6 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type6' enum
fromE'Type6 :: E'Type6 -> Text
fromE'Type6 = \case
  E'Type6'Text -> "text"
  E'Type6'Date -> "date"
  E'Type6'Float -> "float"
  E'Type6'Id -> "id"
  E'Type6'Boolean -> "boolean"

-- | parse 'E'Type6' enum
toE'Type6 :: Text -> P.Either String E'Type6
toE'Type6 = \case
  "text" -> P.Right E'Type6'Text
  "date" -> P.Right E'Type6'Date
  "float" -> P.Right E'Type6'Float
  "id" -> P.Right E'Type6'Id
  "boolean" -> P.Right E'Type6'Boolean
  s -> P.Left $ "toE'Type6: enum parse failure: " P.++ P.show s


-- ** E'Type7

-- | Enum of 'Text'
data E'Type7
  = E'Type7'Marketing -- ^ @"marketing"@
  | E'Type7'Transactional -- ^ @"transactional"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type7 where toJSON = A.toJSON . fromE'Type7
instance A.FromJSON E'Type7 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type7 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type7 where toQueryParam = WH.toQueryParam . fromE'Type7
instance WH.FromHttpApiData E'Type7 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type7
instance MimeRender MimeMultipartFormData E'Type7 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type7' enum
fromE'Type7 :: E'Type7 -> Text
fromE'Type7 = \case
  E'Type7'Marketing -> "marketing"
  E'Type7'Transactional -> "transactional"

-- | parse 'E'Type7' enum
toE'Type7 :: Text -> P.Either String E'Type7
toE'Type7 = \case
  "marketing" -> P.Right E'Type7'Marketing
  "transactional" -> P.Right E'Type7'Transactional
  s -> P.Left $ "toE'Type7: enum parse failure: " P.++ P.show s


-- ** E'WinnerCriteria

-- | Enum of 'Text' . 
-- Choose the metrics that will determinate the winning version. Mandatory if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerCriteria' is ignored if passed
data E'WinnerCriteria
  = E'WinnerCriteria'Open -- ^ @"open"@
  | E'WinnerCriteria'Click -- ^ @"click"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'WinnerCriteria where toJSON = A.toJSON . fromE'WinnerCriteria
instance A.FromJSON E'WinnerCriteria where parseJSON o = P.either P.fail (pure . P.id) . toE'WinnerCriteria =<< A.parseJSON o
instance WH.ToHttpApiData E'WinnerCriteria where toQueryParam = WH.toQueryParam . fromE'WinnerCriteria
instance WH.FromHttpApiData E'WinnerCriteria where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'WinnerCriteria
instance MimeRender MimeMultipartFormData E'WinnerCriteria where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'WinnerCriteria' enum
fromE'WinnerCriteria :: E'WinnerCriteria -> Text
fromE'WinnerCriteria = \case
  E'WinnerCriteria'Open -> "open"
  E'WinnerCriteria'Click -> "click"

-- | parse 'E'WinnerCriteria' enum
toE'WinnerCriteria :: Text -> P.Either String E'WinnerCriteria
toE'WinnerCriteria = \case
  "open" -> P.Right E'WinnerCriteria'Open
  "click" -> P.Right E'WinnerCriteria'Click
  s -> P.Left $ "toE'WinnerCriteria: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("api-key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

