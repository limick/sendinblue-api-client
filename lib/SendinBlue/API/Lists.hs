{-
   SendinBlue API

   SendinBlue provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/sendinblue  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  | 

   OpenAPI Version: 3.0.1
   SendinBlue API API version: 3.0.0
   Contact: contact@sendinblue.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : SendinBlue.API.Lists
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module SendinBlue.API.Lists where

import SendinBlue.Core
import SendinBlue.MimeTypes
import SendinBlue.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Lists

-- *** addContactToList1

-- | @POST \/contacts\/lists\/{listId}\/contacts\/add@
-- 
-- Add existing contacts to a list
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
addContactToList1 
  :: (Consumes AddContactToList1 MimeJSON, MimeRender MimeJSON AddContactToList)
  => AddContactToList -- ^ "contactEmails" -  Emails addresses of the contacts
  -> ListId -- ^ "listId" -  Id of the list
  -> SendinBlueRequest AddContactToList1 MimeJSON PostContactInfo MimeJSON
addContactToList1 contactEmails (ListId listId) =
  _mkRequest "POST" ["/contacts/lists/",toPath listId,"/contacts/add"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)
    `setBodyParam` contactEmails

data AddContactToList1 

-- | /Body Param/ "contactEmails" - Emails addresses of the contacts
instance HasBodyParam AddContactToList1 AddContactToList 

-- | @application/json@
instance Consumes AddContactToList1 MimeJSON

-- | @application/json@
instance Produces AddContactToList1 MimeJSON


-- *** createList1

-- | @POST \/contacts\/lists@
-- 
-- Create a list
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
createList1 
  :: (Consumes CreateList1 MimeJSON, MimeRender MimeJSON CreateList)
  => CreateList -- ^ "createList" -  Values to create a list
  -> SendinBlueRequest CreateList1 MimeJSON CreateModel MimeJSON
createList1 createList =
  _mkRequest "POST" ["/contacts/lists"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)
    `setBodyParam` createList

data CreateList1 

-- | /Body Param/ "createList" - Values to create a list
instance HasBodyParam CreateList1 CreateList 

-- | @application/json@
instance Consumes CreateList1 MimeJSON

-- | @application/json@
instance Produces CreateList1 MimeJSON


-- *** deleteList0

-- | @DELETE \/contacts\/lists\/{listId}@
-- 
-- Delete a list
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
-- Note: Has 'Produces' instances, but no response schema
-- 
deleteList0 
  :: ListId -- ^ "listId" -  Id of the list
  -> SendinBlueRequest DeleteList0 MimeNoContent res MimeJSON
deleteList0 (ListId listId) =
  _mkRequest "DELETE" ["/contacts/lists/",toPath listId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data DeleteList0  
-- | @application/json@
instance Produces DeleteList0 MimeJSON


-- *** getContactsFromList0

-- | @GET \/contacts\/lists\/{listId}\/contacts@
-- 
-- Get contacts in a list
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getContactsFromList0 
  :: ListId -- ^ "listId" -  Id of the list
  -> SendinBlueRequest GetContactsFromList0 MimeNoContent GetContacts MimeJSON
getContactsFromList0 (ListId listId) =
  _mkRequest "GET" ["/contacts/lists/",toPath listId,"/contacts"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetContactsFromList0  

-- | /Optional Param/ "modifiedSince" - Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
instance HasOptionalParam GetContactsFromList0 ModifiedSince where
  applyOptionalParam req (ModifiedSince xs) =
    req `addQuery` toQuery ("modifiedSince", Just xs)

-- | /Optional Param/ "limit" - Number of documents per page
instance HasOptionalParam GetContactsFromList0 Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "offset" - Index of the first document of the page
instance HasOptionalParam GetContactsFromList0 Offset where
  applyOptionalParam req (Offset xs) =
    req `addQuery` toQuery ("offset", Just xs)

-- | /Optional Param/ "sort" - Sort the results in the ascending/descending order of record creation
instance HasOptionalParam GetContactsFromList0 Sort where
  applyOptionalParam req (Sort xs) =
    req `addQuery` toQuery ("sort", Just xs)
-- | @application/json@
instance Produces GetContactsFromList0 MimeJSON


-- *** getFolderLists2

-- | @GET \/contacts\/folders\/{folderId}\/lists@
-- 
-- Get lists in a folder
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getFolderLists2 
  :: FolderId -- ^ "folderId" -  Id of the folder
  -> SendinBlueRequest GetFolderLists2 MimeNoContent GetFolderLists MimeJSON
getFolderLists2 (FolderId folderId) =
  _mkRequest "GET" ["/contacts/folders/",toPath folderId,"/lists"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetFolderLists2  

-- | /Optional Param/ "limit" - Number of documents per page
instance HasOptionalParam GetFolderLists2 Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "offset" - Index of the first document of the page
instance HasOptionalParam GetFolderLists2 Offset where
  applyOptionalParam req (Offset xs) =
    req `addQuery` toQuery ("offset", Just xs)

-- | /Optional Param/ "sort" - Sort the results in the ascending/descending order of record creation
instance HasOptionalParam GetFolderLists2 Sort where
  applyOptionalParam req (Sort xs) =
    req `addQuery` toQuery ("sort", Just xs)
-- | @application/json@
instance Produces GetFolderLists2 MimeJSON


-- *** getList1

-- | @GET \/contacts\/lists\/{listId}@
-- 
-- Get a list's details
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getList1 
  :: ListId -- ^ "listId" -  Id of the list
  -> SendinBlueRequest GetList1 MimeNoContent GetExtendedList MimeJSON
getList1 (ListId listId) =
  _mkRequest "GET" ["/contacts/lists/",toPath listId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetList1  
-- | @application/json@
instance Produces GetList1 MimeJSON


-- *** getLists1

-- | @GET \/contacts\/lists@
-- 
-- Get all the lists
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getLists1 
  :: SendinBlueRequest GetLists1 MimeNoContent GetLists MimeJSON
getLists1 =
  _mkRequest "GET" ["/contacts/lists"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetLists1  

-- | /Optional Param/ "limit" - Number of documents per page
instance HasOptionalParam GetLists1 Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "offset" - Index of the first document of the page
instance HasOptionalParam GetLists1 Offset where
  applyOptionalParam req (Offset xs) =
    req `addQuery` toQuery ("offset", Just xs)

-- | /Optional Param/ "sort" - Sort the results in the ascending/descending order of record creation
instance HasOptionalParam GetLists1 Sort where
  applyOptionalParam req (Sort xs) =
    req `addQuery` toQuery ("sort", Just xs)
-- | @application/json@
instance Produces GetLists1 MimeJSON


-- *** removeContactFromList1

-- | @POST \/contacts\/lists\/{listId}\/contacts\/remove@
-- 
-- Delete a contact from a list
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
removeContactFromList1 
  :: (Consumes RemoveContactFromList1 MimeJSON, MimeRender MimeJSON RemoveContactFromList)
  => RemoveContactFromList -- ^ "contactEmails" -  Emails adresses of the contact
  -> ListId -- ^ "listId" -  Id of the list
  -> SendinBlueRequest RemoveContactFromList1 MimeJSON PostContactInfo MimeJSON
removeContactFromList1 contactEmails (ListId listId) =
  _mkRequest "POST" ["/contacts/lists/",toPath listId,"/contacts/remove"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)
    `setBodyParam` contactEmails

data RemoveContactFromList1 

-- | /Body Param/ "contactEmails" - Emails adresses of the contact
instance HasBodyParam RemoveContactFromList1 RemoveContactFromList 

-- | @application/json@
instance Consumes RemoveContactFromList1 MimeJSON

-- | @application/json@
instance Produces RemoveContactFromList1 MimeJSON


-- *** updateList1

-- | @PUT \/contacts\/lists\/{listId}@
-- 
-- Update a list
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
-- Note: Has 'Produces' instances, but no response schema
-- 
updateList1 
  :: (Consumes UpdateList1 MimeJSON, MimeRender MimeJSON UpdateList)
  => UpdateList -- ^ "updateList" -  Values to update a list
  -> ListId -- ^ "listId" -  Id of the list
  -> SendinBlueRequest UpdateList1 MimeJSON res MimeJSON
updateList1 updateList (ListId listId) =
  _mkRequest "PUT" ["/contacts/lists/",toPath listId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)
    `setBodyParam` updateList

data UpdateList1 

-- | /Body Param/ "updateList" - Values to update a list
instance HasBodyParam UpdateList1 UpdateList 

-- | @application/json@
instance Consumes UpdateList1 MimeJSON

-- | @application/json@
instance Produces UpdateList1 MimeJSON

