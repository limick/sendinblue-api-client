{-
   SendinBlue API

   SendinBlue provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/sendinblue  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  | 

   OpenAPI spec version: 2.0
   SendinBlue API API version: 3.0.0
   Contact: contact@sendinblue.com
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : SendinBlue.API.Senders
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module SendinBlue.API.Senders where

import SendinBlue.Core
import SendinBlue.MimeTypes
import SendinBlue.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Senders

-- *** createSender0

-- | @POST \/senders@
-- 
-- Create a new sender
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
createSender0 
  :: (Consumes CreateSender0 MimeJSON)
  => SendinBlueRequest CreateSender0 MimeJSON CreateSenderModel MimeJSON
createSender0 =
  _mkRequest "POST" ["/senders"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data CreateSender0 

-- | /Body Param/ "sender" - sender's name
instance HasBodyParam CreateSender0 CreateSender 

-- | @application/json@
instance Consumes CreateSender0 MimeJSON

-- | @application/json@
instance Produces CreateSender0 MimeJSON


-- *** deleteSender

-- | @DELETE \/senders\/{senderId}@
-- 
-- Delete a sender
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
-- Note: Has 'Produces' instances, but no response schema
-- 
deleteSender 
  :: SenderId -- ^ "senderId" -  Id of the sender
  -> SendinBlueRequest DeleteSender MimeNoContent res MimeJSON
deleteSender (SenderId senderId) =
  _mkRequest "DELETE" ["/senders/",toPath senderId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data DeleteSender  

-- | @application/json@
instance Consumes DeleteSender MimeJSON

-- | @application/json@
instance Produces DeleteSender MimeJSON


-- *** getIps0

-- | @GET \/senders\/ips@
-- 
-- Return all the dedicated IPs for your account
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getIps0 
  :: SendinBlueRequest GetIps0 MimeNoContent GetIps MimeJSON
getIps0 =
  _mkRequest "GET" ["/senders/ips"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetIps0  

-- | @application/json@
instance Consumes GetIps0 MimeJSON

-- | @application/json@
instance Produces GetIps0 MimeJSON


-- *** getIpsFromSender0

-- | @GET \/senders\/{senderId}\/ips@
-- 
-- Return all the dedicated IPs for a sender
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getIpsFromSender0 
  :: SenderId -- ^ "senderId" -  Id of the sender
  -> SendinBlueRequest GetIpsFromSender0 MimeNoContent GetIpsFromSender MimeJSON
getIpsFromSender0 (SenderId senderId) =
  _mkRequest "GET" ["/senders/",toPath senderId,"/ips"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetIpsFromSender0  

-- | @application/json@
instance Consumes GetIpsFromSender0 MimeJSON

-- | @application/json@
instance Produces GetIpsFromSender0 MimeJSON


-- *** getSenders

-- | @GET \/senders@
-- 
-- Get the list of all your senders
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getSenders 
  :: SendinBlueRequest GetSenders MimeNoContent GetSendersList MimeJSON
getSenders =
  _mkRequest "GET" ["/senders"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetSenders  

-- | /Optional Param/ "ip" - Filter your senders for a specific ip (available for dedicated IP usage only)
instance HasOptionalParam GetSenders Ip where
  applyOptionalParam req (Ip xs) =
    req `setQuery` toQuery ("ip", Just xs)

-- | /Optional Param/ "domain" - Filter your senders for a specific domain
instance HasOptionalParam GetSenders Domain where
  applyOptionalParam req (Domain xs) =
    req `setQuery` toQuery ("domain", Just xs)

-- | @application/json@
instance Consumes GetSenders MimeJSON

-- | @application/json@
instance Produces GetSenders MimeJSON


-- *** updateSender0

-- | @PUT \/senders\/{senderId}@
-- 
-- Update a sender
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
-- Note: Has 'Produces' instances, but no response schema
-- 
updateSender0 
  :: (Consumes UpdateSender0 MimeJSON)
  => SenderId -- ^ "senderId" -  Id of the sender
  -> SendinBlueRequest UpdateSender0 MimeJSON res MimeJSON
updateSender0 (SenderId senderId) =
  _mkRequest "PUT" ["/senders/",toPath senderId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data UpdateSender0 

-- | /Body Param/ "sender" - sender's name
instance HasBodyParam UpdateSender0 UpdateSender 

-- | @application/json@
instance Consumes UpdateSender0 MimeJSON

-- | @application/json@
instance Produces UpdateSender0 MimeJSON

