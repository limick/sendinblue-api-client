{-
   SendinBlue API

   SendinBlue provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/sendinblue  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  | 

   OpenAPI Version: 3.0.1
   SendinBlue API API version: 3.0.0
   Contact: contact@sendinblue.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : SendinBlue.API.SMTP
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module SendinBlue.API.SMTP where

import SendinBlue.Core
import SendinBlue.MimeTypes
import SendinBlue.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** SMTP

-- *** blockNewDomain

-- | @POST \/smtp\/blockedDomains@
-- 
-- Add a new domain to the list of blocked domains
-- 
-- Blocks a new domain in order to avoid messages being sent to the same
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
blockNewDomain
  :: (Consumes BlockNewDomain MimeJSON, MimeRender MimeJSON BlockDomain)
  => BlockDomain -- ^ "blockDomain"
  -> SendinBlueRequest BlockNewDomain MimeJSON NoContent MimeNoContent
blockNewDomain blockDomain =
  _mkRequest "POST" ["/smtp/blockedDomains"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)
    `setBodyParam` blockDomain

data BlockNewDomain 
instance HasBodyParam BlockNewDomain BlockDomain 

-- | @application/json@
instance Consumes BlockNewDomain MimeJSON

instance Produces BlockNewDomain MimeNoContent


-- *** createSmtpTemplate0

-- | @POST \/smtp\/templates@
-- 
-- Create an email template
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
createSmtpTemplate0
  :: (Consumes CreateSmtpTemplate0 MimeJSON, MimeRender MimeJSON CreateSmtpTemplate)
  => CreateSmtpTemplate -- ^ "smtpTemplate" -  values to update in transactional email template
  -> SendinBlueRequest CreateSmtpTemplate0 MimeJSON CreateModel MimeJSON
createSmtpTemplate0 smtpTemplate =
  _mkRequest "POST" ["/smtp/templates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)
    `setBodyParam` smtpTemplate

data CreateSmtpTemplate0 

-- | /Body Param/ "smtpTemplate" - values to update in transactional email template
instance HasBodyParam CreateSmtpTemplate0 CreateSmtpTemplate 

-- | @application/json@
instance Consumes CreateSmtpTemplate0 MimeJSON

-- | @application/json@
instance Produces CreateSmtpTemplate0 MimeJSON


-- *** deleteBlockedDomain

-- | @DELETE \/smtp\/blockedDomains\/{domain}@
-- 
-- Unblock an existing domain from the list of blocked domains
-- 
-- Unblocks an existing domain from the list of blocked domains
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
deleteBlockedDomain
  :: Domain -- ^ "domain" -  The name of the domain to be deleted
  -> SendinBlueRequest DeleteBlockedDomain MimeNoContent NoContent MimeNoContent
deleteBlockedDomain (Domain domain) =
  _mkRequest "DELETE" ["/smtp/blockedDomains/",toPath domain]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data DeleteBlockedDomain  
instance Produces DeleteBlockedDomain MimeNoContent


-- *** deleteHardbounces0

-- | @POST \/smtp\/deleteHardbounces@
-- 
-- Delete hardbounces
-- 
-- Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
deleteHardbounces0
  :: (Consumes DeleteHardbounces0 MimeJSON)
  => SendinBlueRequest DeleteHardbounces0 MimeJSON NoContent MimeNoContent
deleteHardbounces0 =
  _mkRequest "POST" ["/smtp/deleteHardbounces"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data DeleteHardbounces0 

-- | /Body Param/ "deleteHardbounces" - values to delete hardbounces
instance HasBodyParam DeleteHardbounces0 DeleteHardbounces 

-- | @application/json@
instance Consumes DeleteHardbounces0 MimeJSON

instance Produces DeleteHardbounces0 MimeNoContent


-- *** deleteSmtpTemplate

-- | @DELETE \/smtp\/templates\/{templateId}@
-- 
-- Delete an inactive email template
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
deleteSmtpTemplate
  :: TemplateId -- ^ "templateId" -  id of the template
  -> SendinBlueRequest DeleteSmtpTemplate MimeNoContent NoContent MimeNoContent
deleteSmtpTemplate (TemplateId templateId) =
  _mkRequest "DELETE" ["/smtp/templates/",toPath templateId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data DeleteSmtpTemplate  
instance Produces DeleteSmtpTemplate MimeNoContent


-- *** getAggregatedSmtpReport

-- | @GET \/smtp\/statistics\/aggregatedReport@
-- 
-- Get your transactional email activity aggregated over a period of time
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getAggregatedSmtpReport
  :: SendinBlueRequest GetAggregatedSmtpReport MimeNoContent GetAggregatedReport MimeJSON
getAggregatedSmtpReport =
  _mkRequest "GET" ["/smtp/statistics/aggregatedReport"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetAggregatedSmtpReport  

-- | /Optional Param/ "startDate" - Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate
instance HasOptionalParam GetAggregatedSmtpReport StartDateText where
  applyOptionalParam req (StartDateText xs) =
    req `addQuery` toQuery ("startDate", Just xs)

-- | /Optional Param/ "endDate" - Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate
instance HasOptionalParam GetAggregatedSmtpReport EndDateText where
  applyOptionalParam req (EndDateText xs) =
    req `addQuery` toQuery ("endDate", Just xs)

-- | /Optional Param/ "days" - Number of days in the past including today (positive integer). Not compatible with 'startDate' and 'endDate'
instance HasOptionalParam GetAggregatedSmtpReport Days where
  applyOptionalParam req (Days xs) =
    req `addQuery` toQuery ("days", Just xs)

-- | /Optional Param/ "tag" - Tag of the emails
instance HasOptionalParam GetAggregatedSmtpReport Tag where
  applyOptionalParam req (Tag xs) =
    req `addQuery` toQuery ("tag", Just xs)
-- | @application/json@
instance Produces GetAggregatedSmtpReport MimeJSON


-- *** getBlockedDomains0

-- | @GET \/smtp\/blockedDomains@
-- 
-- Get the list of blocked domains
-- 
-- Get the list of blocked domains
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getBlockedDomains0
  :: SendinBlueRequest GetBlockedDomains0 MimeNoContent GetBlockedDomains MimeJSON
getBlockedDomains0 =
  _mkRequest "GET" ["/smtp/blockedDomains"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetBlockedDomains0  
-- | @application/json@
instance Produces GetBlockedDomains0 MimeJSON


-- *** getEmailEventReport0

-- | @GET \/smtp\/statistics\/events@
-- 
-- Get all your transactional email activity (unaggregated events)
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getEmailEventReport0
  :: SendinBlueRequest GetEmailEventReport0 MimeNoContent GetEmailEventReport MimeJSON
getEmailEventReport0 =
  _mkRequest "GET" ["/smtp/statistics/events"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetEmailEventReport0  

-- | /Optional Param/ "limit" - Number limitation for the result returned
instance HasOptionalParam GetEmailEventReport0 Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "offset" - Beginning point in the list to retrieve from.
instance HasOptionalParam GetEmailEventReport0 Offset where
  applyOptionalParam req (Offset xs) =
    req `addQuery` toQuery ("offset", Just xs)

-- | /Optional Param/ "startDate" - Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate
instance HasOptionalParam GetEmailEventReport0 StartDateText where
  applyOptionalParam req (StartDateText xs) =
    req `addQuery` toQuery ("startDate", Just xs)

-- | /Optional Param/ "endDate" - Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate
instance HasOptionalParam GetEmailEventReport0 EndDateText where
  applyOptionalParam req (EndDateText xs) =
    req `addQuery` toQuery ("endDate", Just xs)

-- | /Optional Param/ "days" - Number of days in the past including today (positive integer). Not compatible with 'startDate' and 'endDate'
instance HasOptionalParam GetEmailEventReport0 Days where
  applyOptionalParam req (Days xs) =
    req `addQuery` toQuery ("days", Just xs)

-- | /Optional Param/ "email" - Filter the report for a specific email addresses
instance HasOptionalParam GetEmailEventReport0 Email where
  applyOptionalParam req (Email xs) =
    req `addQuery` toQuery ("email", Just xs)

-- | /Optional Param/ "event" - Filter the report for a specific event type
instance HasOptionalParam GetEmailEventReport0 Event where
  applyOptionalParam req (Event xs) =
    req `addQuery` toQuery ("event", Just xs)

-- | /Optional Param/ "tags" - Filter the report for tags (serialized and urlencoded array)
instance HasOptionalParam GetEmailEventReport0 Tags where
  applyOptionalParam req (Tags xs) =
    req `addQuery` toQuery ("tags", Just xs)

-- | /Optional Param/ "messageId" - Filter on a specific message id
instance HasOptionalParam GetEmailEventReport0 MessageId where
  applyOptionalParam req (MessageId xs) =
    req `addQuery` toQuery ("messageId", Just xs)

-- | /Optional Param/ "templateId" - Filter on a specific template id
instance HasOptionalParam GetEmailEventReport0 TemplateId where
  applyOptionalParam req (TemplateId xs) =
    req `addQuery` toQuery ("templateId", Just xs)
-- | @application/json@
instance Produces GetEmailEventReport0 MimeJSON


-- *** getSmtpReport

-- | @GET \/smtp\/statistics\/reports@
-- 
-- Get your transactional email activity aggregated per day
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getSmtpReport
  :: SendinBlueRequest GetSmtpReport MimeNoContent GetReports MimeJSON
getSmtpReport =
  _mkRequest "GET" ["/smtp/statistics/reports"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetSmtpReport  

-- | /Optional Param/ "limit" - Number of documents returned per page
instance HasOptionalParam GetSmtpReport Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "offset" - Index of the first document on the page
instance HasOptionalParam GetSmtpReport Offset where
  applyOptionalParam req (Offset xs) =
    req `addQuery` toQuery ("offset", Just xs)

-- | /Optional Param/ "startDate" - Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD)
instance HasOptionalParam GetSmtpReport StartDateText where
  applyOptionalParam req (StartDateText xs) =
    req `addQuery` toQuery ("startDate", Just xs)

-- | /Optional Param/ "endDate" - Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD)
instance HasOptionalParam GetSmtpReport EndDateText where
  applyOptionalParam req (EndDateText xs) =
    req `addQuery` toQuery ("endDate", Just xs)

-- | /Optional Param/ "days" - Number of days in the past including today (positive integer). Not compatible with 'startDate' and 'endDate'
instance HasOptionalParam GetSmtpReport Days where
  applyOptionalParam req (Days xs) =
    req `addQuery` toQuery ("days", Just xs)

-- | /Optional Param/ "tag" - Tag of the emails
instance HasOptionalParam GetSmtpReport Tag where
  applyOptionalParam req (Tag xs) =
    req `addQuery` toQuery ("tag", Just xs)
-- | @application/json@
instance Produces GetSmtpReport MimeJSON


-- *** getSmtpTemplate

-- | @GET \/smtp\/templates\/{templateId}@
-- 
-- Returns the template information
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getSmtpTemplate
  :: TemplateId -- ^ "templateId" -  id of the template
  -> SendinBlueRequest GetSmtpTemplate MimeNoContent GetSmtpTemplateOverview MimeJSON
getSmtpTemplate (TemplateId templateId) =
  _mkRequest "GET" ["/smtp/templates/",toPath templateId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetSmtpTemplate  
-- | @application/json@
instance Produces GetSmtpTemplate MimeJSON


-- *** getSmtpTemplates0

-- | @GET \/smtp\/templates@
-- 
-- Get the list of email templates
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getSmtpTemplates0
  :: SendinBlueRequest GetSmtpTemplates0 MimeNoContent GetSmtpTemplates MimeJSON
getSmtpTemplates0 =
  _mkRequest "GET" ["/smtp/templates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetSmtpTemplates0  

-- | /Optional Param/ "templateStatus" - Filter on the status of the template. Active = true, inactive = false
instance HasOptionalParam GetSmtpTemplates0 TemplateStatus where
  applyOptionalParam req (TemplateStatus xs) =
    req `addQuery` toQuery ("templateStatus", Just xs)

-- | /Optional Param/ "limit" - Number of documents returned per page
instance HasOptionalParam GetSmtpTemplates0 Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "offset" - Index of the first document in the page
instance HasOptionalParam GetSmtpTemplates0 Offset where
  applyOptionalParam req (Offset xs) =
    req `addQuery` toQuery ("offset", Just xs)
-- | @application/json@
instance Produces GetSmtpTemplates0 MimeJSON


-- *** getTransacBlockedContacts0

-- | @GET \/smtp\/blockedContacts@
-- 
-- Get the list of blocked or unsubscribed transactional contacts
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getTransacBlockedContacts0
  :: SendinBlueRequest GetTransacBlockedContacts0 MimeNoContent GetTransacBlockedContacts MimeJSON
getTransacBlockedContacts0 =
  _mkRequest "GET" ["/smtp/blockedContacts"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetTransacBlockedContacts0  

-- | /Optional Param/ "startDate" - Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the blocked or unsubscribed contacts
instance HasOptionalParam GetTransacBlockedContacts0 StartDateText where
  applyOptionalParam req (StartDateText xs) =
    req `addQuery` toQuery ("startDate", Just xs)

-- | /Optional Param/ "endDate" - Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the blocked or unsubscribed contacts
instance HasOptionalParam GetTransacBlockedContacts0 EndDateText where
  applyOptionalParam req (EndDateText xs) =
    req `addQuery` toQuery ("endDate", Just xs)

-- | /Optional Param/ "limit" - Number of documents returned per page
instance HasOptionalParam GetTransacBlockedContacts0 Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "offset" - Index of the first document on the page
instance HasOptionalParam GetTransacBlockedContacts0 Offset where
  applyOptionalParam req (Offset xs) =
    req `addQuery` toQuery ("offset", Just xs)

-- | /Optional Param/ "senders" - Comma separated list of emails of the senders from which contacts are blocked or unsubscribed
instance HasOptionalParam GetTransacBlockedContacts0 Senders where
  applyOptionalParam req (Senders xs) =
    req `addQuery` toQueryColl CommaSeparated ("senders", Just xs)
-- | @application/json@
instance Produces GetTransacBlockedContacts0 MimeJSON


-- *** getTransacEmailContent0

-- | @GET \/smtp\/emails\/{uuid}@
-- 
-- Get the personalized content of a sent transactional email
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getTransacEmailContent0
  :: Uuid -- ^ "uuid" -  Unique id of the transactional email that has been sent to a particular contact
  -> SendinBlueRequest GetTransacEmailContent0 MimeNoContent GetTransacEmailContent MimeJSON
getTransacEmailContent0 (Uuid uuid) =
  _mkRequest "GET" ["/smtp/emails/",toPath uuid]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetTransacEmailContent0  
-- | @application/json@
instance Produces GetTransacEmailContent0 MimeJSON


-- *** getTransacEmailsList0

-- | @GET \/smtp\/emails@
-- 
-- Get the list of transactional emails on the basis of allowed filters
-- 
-- This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
getTransacEmailsList0
  :: SendinBlueRequest GetTransacEmailsList0 MimeNoContent GetTransacEmailsList MimeJSON
getTransacEmailsList0 =
  _mkRequest "GET" ["/smtp/emails"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data GetTransacEmailsList0  

-- | /Optional Param/ "email" - Mandatory if templateId and messageId are not passed in query filters. Email address to which transactional email has been sent.
instance HasOptionalParam GetTransacEmailsList0 Email where
  applyOptionalParam req (Email xs) =
    req `addQuery` toQuery ("email", Just xs)

-- | /Optional Param/ "templateId" - Mandatory if email and messageId are not passed in query filters. Id of the template that was used to compose transactional email.
instance HasOptionalParam GetTransacEmailsList0 TemplateId where
  applyOptionalParam req (TemplateId xs) =
    req `addQuery` toQuery ("templateId", Just xs)

-- | /Optional Param/ "messageId" - Mandatory if templateId and email are not passed in query filters. Message ID of the transactional email sent.
instance HasOptionalParam GetTransacEmailsList0 MessageId where
  applyOptionalParam req (MessageId xs) =
    req `addQuery` toQuery ("messageId", Just xs)

-- | /Optional Param/ "startDate" - Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Maximum time period that can be selected is one month.
instance HasOptionalParam GetTransacEmailsList0 StartDateDate where
  applyOptionalParam req (StartDateDate xs) =
    req `addQuery` toQuery ("startDate", Just xs)

-- | /Optional Param/ "endDate" - Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month.
instance HasOptionalParam GetTransacEmailsList0 EndDateDate where
  applyOptionalParam req (EndDateDate xs) =
    req `addQuery` toQuery ("endDate", Just xs)
-- | @application/json@
instance Produces GetTransacEmailsList0 MimeJSON


-- *** sendTemplate

-- | @POST \/smtp\/templates\/{templateId}\/send@
-- 
-- Send a template
-- 
-- This endpoint is deprecated. Prefer v3/smtp/email instead.
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
sendTemplate
  :: (Consumes SendTemplate MimeJSON, MimeRender MimeJSON SendEmail)
  => SendEmail -- ^ "sendEmail"
  -> TemplateId -- ^ "templateId" -  Id of the template
  -> SendinBlueRequest SendTemplate MimeJSON SendTemplateEmail MimeJSON
sendTemplate sendEmail (TemplateId templateId) =
  _mkRequest "POST" ["/smtp/templates/",toPath templateId,"/send"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)
    `setBodyParam` sendEmail

{-# DEPRECATED sendTemplate "" #-}

data SendTemplate 
instance HasBodyParam SendTemplate SendEmail 

-- | @application/json@
instance Consumes SendTemplate MimeJSON

-- | @application/json@
instance Produces SendTemplate MimeJSON


-- *** sendTestTemplate

-- | @POST \/smtp\/templates\/{templateId}\/sendTest@
-- 
-- Send a template to your test list
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
sendTestTemplate
  :: (Consumes SendTestTemplate MimeJSON, MimeRender MimeJSON SendTestEmail)
  => SendTestEmail -- ^ "sendTestEmail"
  -> TemplateId -- ^ "templateId" -  Id of the template
  -> SendinBlueRequest SendTestTemplate MimeJSON NoContent MimeNoContent
sendTestTemplate sendTestEmail (TemplateId templateId) =
  _mkRequest "POST" ["/smtp/templates/",toPath templateId,"/sendTest"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)
    `setBodyParam` sendTestEmail

data SendTestTemplate 
instance HasBodyParam SendTestTemplate SendTestEmail 

-- | @application/json@
instance Consumes SendTestTemplate MimeJSON

instance Produces SendTestTemplate MimeNoContent


-- *** sendTransacEmail

-- | @POST \/smtp\/email@
-- 
-- Send a transactional email
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
sendTransacEmail
  :: (Consumes SendTransacEmail MimeJSON, MimeRender MimeJSON SendSmtpEmail)
  => SendSmtpEmail -- ^ "sendSmtpEmail" -  Values to send a transactional email
  -> SendinBlueRequest SendTransacEmail MimeJSON CreateSmtpEmail MimeJSON
sendTransacEmail sendSmtpEmail =
  _mkRequest "POST" ["/smtp/email"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)
    `setBodyParam` sendSmtpEmail

data SendTransacEmail 

-- | /Body Param/ "sendSmtpEmail" - Values to send a transactional email
instance HasBodyParam SendTransacEmail SendSmtpEmail 

-- | @application/json@
instance Consumes SendTransacEmail MimeJSON

-- | @application/json@
instance Produces SendTransacEmail MimeJSON


-- *** smtpBlockedContactsEmailDelete

-- | @DELETE \/smtp\/blockedContacts\/{email}@
-- 
-- Unblock or resubscribe a transactional contact
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
smtpBlockedContactsEmailDelete
  :: Email -- ^ "email" -  contact email (urlencoded) to unblock.
  -> SendinBlueRequest SmtpBlockedContactsEmailDelete MimeNoContent NoContent MimeNoContent
smtpBlockedContactsEmailDelete (Email email) =
  _mkRequest "DELETE" ["/smtp/blockedContacts/",toPath email]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data SmtpBlockedContactsEmailDelete  
instance Produces SmtpBlockedContactsEmailDelete MimeNoContent


-- *** smtpLogMessageIdDelete

-- | @DELETE \/smtp\/log\/{messageId}@
-- 
-- Delete an SMTP transactional log
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
smtpLogMessageIdDelete
  :: MessageId -- ^ "messageId" -  MessageId of the transactional log to delete
  -> SendinBlueRequest SmtpLogMessageIdDelete MimeNoContent NoContent MimeNoContent
smtpLogMessageIdDelete (MessageId messageId) =
  _mkRequest "DELETE" ["/smtp/log/",toPath messageId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)

data SmtpLogMessageIdDelete  
instance Produces SmtpLogMessageIdDelete MimeNoContent


-- *** updateSmtpTemplate0

-- | @PUT \/smtp\/templates\/{templateId}@
-- 
-- Update an email template
-- 
-- AuthMethod: 'AuthApiKeyApiKey'
-- 
updateSmtpTemplate0
  :: (Consumes UpdateSmtpTemplate0 MimeJSON, MimeRender MimeJSON UpdateSmtpTemplate)
  => UpdateSmtpTemplate -- ^ "smtpTemplate" -  values to update in transactional email template
  -> TemplateId -- ^ "templateId" -  id of the template
  -> SendinBlueRequest UpdateSmtpTemplate0 MimeJSON NoContent MimeNoContent
updateSmtpTemplate0 smtpTemplate (TemplateId templateId) =
  _mkRequest "PUT" ["/smtp/templates/",toPath templateId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKey)
    `setBodyParam` smtpTemplate

data UpdateSmtpTemplate0 

-- | /Body Param/ "smtpTemplate" - values to update in transactional email template
instance HasBodyParam UpdateSmtpTemplate0 UpdateSmtpTemplate 

-- | @application/json@
instance Consumes UpdateSmtpTemplate0 MimeJSON

instance Produces UpdateSmtpTemplate0 MimeNoContent

